{"docstore/metadata": {"b84895b9-6f90-4975-9e13-02044300f26a": {"doc_hash": "c03ea23331fe0c61782f942e12b5b509f0de5593869898f43bab2318222d3aeb"}, "076fe90a-05da-43e4-88f6-01ba95c8d719": {"doc_hash": "449d3e04e4f878a48909597de588cd24e3e867f663af472ffcc426fd0be2b99d"}, "1e5f4b71-4211-4934-bab2-20839a1eaf52": {"doc_hash": "4a6441e3523da7c0af75dbd5bb631dec4a37ce8f4512baf95de4a249c5bc6482"}, "02d81911-24f6-4111-acfd-138239bfe6e3": {"doc_hash": "3ec433fff59e644fb657350aac7e5f904f1fd6520705865e8eb915a483487eee"}, "204eda0e-0a38-4f2a-af79-6c57b8fc0c05": {"doc_hash": "d52235812c113972326849d12956ec76a73cfff60138aa116630648c96354feb"}, "68e2c518-050f-454a-936f-33033c6dc12e": {"doc_hash": "4ff3a3a0228344fd307cb584c7b5da2acd5c5d290826603cd2b744d2f88b0d4d"}, "ff580322-4bf2-4ffa-a4ed-0582ce3217dc": {"doc_hash": "8b1106d6c98f424da8613e33d074ba047bf47ab062e3e6bca1c317e25f97f1a4"}, "30a9c6cc-73d7-4486-ac5c-b40e3bb0fb27": {"doc_hash": "e4c7f79b70a6f052ab4fc80840007440421d484f1034c48ff26648b7843a5e23"}, "d1257edc-1b8b-4a4b-b71d-bebccabaf357": {"doc_hash": "77ebcf08a689e22618416df0c905c99582dc0d3e72901e864c9f075b7864b06e"}, "7e02a3b6-4f11-44dd-a46b-65153f2a6615": {"doc_hash": "db4645a23b052c7074043acfbcbd8ddf862e7ad09507527658125db5d1df6f25"}, "293289f5-cef4-443c-9aa6-90a0d2625f2f": {"doc_hash": "a0c6bc5517fe54c83d56b1a0dce6164c414b8c16d37e0390a90e1926b9b8cc0a"}, "6904ae89-36c0-4f9f-9605-365747dac5e7": {"doc_hash": "d6bd7fff2798bf98aff544aa2ed91a4b69fec849b4e1dccc98e35dce97cc7187"}, "8bb66c66-9021-4ce4-9279-3dd0432ac1e8": {"doc_hash": "f46f147af020821256d7abe5536a3e720b91272c28d3b126eb09ccb7d31747c4"}, "f4218aa6-08f5-43d9-9655-9b58a33d2068": {"doc_hash": "e896acf5a5ffbf3aeef253e968593f521556633041f72f6777070a394ff4b809"}, "20abee10-fba9-42c1-b65f-817e871648f4": {"doc_hash": "4176c23785da6f5aec3503127b704c199f3991cbce0608be081ce3395e23f49d"}, "bf24c37a-3f3b-48c0-8447-dc2e38a19f71": {"doc_hash": "2a85f4d42bb9990b4c973afdf9855e91718637b0503cd94a5cdf64721c13e778"}, "c85c5020-e0f2-4b45-853b-87085be3569f": {"doc_hash": "67b10cdf00c4c7c1862ff2060ff01b552c8c554bd4d884e4a5fa85ddc955abe2"}, "392b824c-3e31-457b-9b2d-33c0dae061e4": {"doc_hash": "a109fa6d169a28e71cf92a7ac6bcd736eb3a37461bc4b455d1d0d9e7396c791e"}, "e170daba-74a2-497a-bdd7-4da84ff21e8e": {"doc_hash": "961d61e0d19057f87131f78e8fc23053844c2f5651bac76e75956a68cb30b9d8"}, "fc825bf2-ed57-4898-b758-79f8e272eaa2": {"doc_hash": "0eda29c3ef70055e20ea63ddeb034ba994811c6fbc22fbe61b08cbc337e9933d"}, "e44e1708-fa1a-4e97-be98-7f43f4eb361a": {"doc_hash": "9766426f4f7e569a79fed855e09d05795bfce1c38fee33f3c50a304e46df5360"}, "8cccc794-d1e2-47e7-b770-1956fab8942a": {"doc_hash": "0ba660c19815ca7663b6985ebb1b544b085e20f0a51dcb4b7210d811062fd6f3"}, "d0d481c5-a8a6-40cd-bd59-ab47cb6de26d": {"doc_hash": "d0112c20de93b7b90d9d5bb627eacb129618ef2457da8405908012b2735d8b5f"}, "cea8dda1-dd4d-4a41-900a-409eb619daa0": {"doc_hash": "7777544f6d491969e34ce524e9ee84304863e99853a6617b97bdfa1783e12b3d"}, "90e4869f-66ca-400a-9179-f09ca6b1ed8f": {"doc_hash": "56b56803564246495603f7774fdc96fc168dbfd48986bf57534373251000f83c"}, "051b9327-424d-4380-8850-65707eab7580": {"doc_hash": "a93955047bf663703a420fd4ec9ebfd8c3618e921433d99be3bee6fbaa4e0870"}, "56da1b7e-55cd-4559-9cfc-a341588f3709": {"doc_hash": "fc076b7415bd678c3841e53d9db4cd8f1cbe46c9fa0ec721c7b130fa90a61375"}, "41aae94c-6c33-4f89-bfdc-17bef1b1b595": {"doc_hash": "981da02b1cfe075891042092731a0216f9b078ee04f85c978c535632b46743b0"}, "9dc87bfc-33c2-4cc5-971c-132f9941654e": {"doc_hash": "3aec107663c240860dc9fa8d1cb0ec09dd6698a2c0091851d545fab9c4294e8e"}, "fb61839b-72af-415e-9157-612f7318e55c": {"doc_hash": "0a61b89d7403c60cff4274ee9df0a1b252002d550aaceed4295d114d2256d813"}, "89ee9942-c3b9-4bf0-aab6-bd9db6ca16f1": {"doc_hash": "e7fcbd93aa44b028478bca9c4c208bf95159e5ccc01de99d0082ef8503c0cab4"}, "bdb69170-6db0-4358-a368-82df7cef9c8d": {"doc_hash": "86993d18bcf5d28921a8a67aa5f05399f7899668a5d92b533f1bd5c5b24f08b0"}, "b5eaaec0-c9a6-452a-908d-46dc7e67609c": {"doc_hash": "1ade28ce3d8b83d229e546dfc7113081e71ad70801844979834f25e14b771d7d"}, "74b3311b-bd41-4da3-914f-f741221735f1": {"doc_hash": "ad286c837e051d1139466c5e9e51e14f069472f5a71da36ae731205af3f852fb"}, "d50d414c-102e-4555-8c3c-def649484c91": {"doc_hash": "c2cf3bf136272ad3e734f730046c98a12e59c9ba13123beff53cf87e21cc45e7"}, "700879ea-fa69-47f0-a484-f59e5a33222a": {"doc_hash": "7c449da9d0cedbecbdb787b93ade6b574a94a5722be467a37cbe1c13927ab1c3"}, "6419b92c-682e-456d-8f81-e870e89e41d1": {"doc_hash": "4b3e9d46dc3546232dfcb86f91c1af199e4ea6a8888f2ca384ef11b6f437e30c"}, "74543c26-6735-4e29-8b30-0c83c37e4eb2": {"doc_hash": "520f856b80a709b7374c2aede302b57fb276fd5eff01ed9924ebd9d59cf04cb3"}, "9accf485-e076-4427-b5dd-3e83b1de851d": {"doc_hash": "ffe10ca3770f1cd67ced46be2cb865cbee879bd8fb2f0d94c11a4130867657e3"}, "5e041b9d-da2b-4ae4-8f23-df603251e755": {"doc_hash": "b2725fd27c85acfc1278e6278026296016dd5ed8cdf2a6270620f70e33139ae8"}, "ce5260da-9638-4b8f-bac7-54c602e4fca5": {"doc_hash": "8ec21525f854c9f15eb3f76eed5d60c9d66849f8c4a5cb3f95d929d0ddc52a7e"}, "80178348-8193-4427-95fd-ca2042100e79": {"doc_hash": "b35b83337ba93ddaca3106be4300344406df202ff8ff1a38512fa5c7e43bc165"}, "3d5517b7-faaa-4fbe-a09a-34657858603b": {"doc_hash": "9ad4fafc92e98a8884e8225253a9ca8050b2b494ae947bcf47d02a117dc4e14b"}, "3a491e0e-6d33-4494-ad06-2bfff5d0225c": {"doc_hash": "3b7be1a289f5e8d64e8d3b7ce937c4016cb41065955d3a0ad4d17951b172686a"}, "557a1ac1-ce42-4e6a-8ad2-ecaaa091f7e2": {"doc_hash": "d09c8d2d6cb148cc30e2961a1efba91a8272596c9b3f34fc5811125cae7a1610"}, "6826ac6f-6e81-4ec2-bd50-887e6c471ed1": {"doc_hash": "c9b15419e92efbfc7ef03af1f239aeb807ec06912963ff1b2003971f15cd5f2e"}, "2dfb7df0-30d9-4b21-8bb7-1583c22c6b07": {"doc_hash": "1ffd7b37b2d77f3d2dd79229f8c71500b7f471de87f5a0cb9bfa16c1ab818d23"}, "6d7bc0af-6401-4680-abe9-1f944917c234": {"doc_hash": "eda086356ffaf40e8d86813bfc192d6e1d807ef9f1de71b62f1640c0c36bb90c"}, "7eb43954-0af3-4d23-8ced-7f4543102e31": {"doc_hash": "9ca3adfa57b10ebbf26190358c241fd4e8be9482acd9dcf1fab8b6fd5e06ad11"}, "6c94dc17-010b-497e-894d-4758e39d23ab": {"doc_hash": "e6215f2b5de39b979ccaaddb9bcd5fcce12504daed69dc0d345d56b44851f7de"}, "c9a5f1d4-7d47-4b7f-a050-d0384b21fe31": {"doc_hash": "e097c9f72e584bcd3ff9584c76d7a72a4df76c9f25c31453bd15a7972946eadd"}, "af70ebff-f208-4650-b5c8-eaead32a44a0": {"doc_hash": "cac4ece328ff56ec3be0db9e6ff095715261b17cd7bc514ec5ed99a9c4ec9aed"}, "2571ee34-738c-43d4-a92e-f6d7b66148ec": {"doc_hash": "9deff96df7d3fa71e51d51b91a38de51c4e3570df7eaf030dfcafa2b2c343bb7"}, "236806b3-e949-4f50-8f30-10ace87c0a7c": {"doc_hash": "8e92d101a5472ea21884f1ad6a8aed7b74188d1e174e71380254c93f95115e7f"}, "e02d000e-5d4f-4162-9018-dc239e5a201a": {"doc_hash": "ed182396a27460ea6389e9d78f830b238358311e0ba5d3a9ac5763070a562e58"}, "5022be93-401a-42ea-9d11-5c29572f28e4": {"doc_hash": "4b49b987280f678e3511c874c9ab1a5e3dc58790d1d6de3bf9c41437dfe76f1e"}, "ef37abf2-926d-4796-803a-3155467dd223": {"doc_hash": "39fd510b1f4d8811e71f9f16ebdce41bf9e02b6311b0d3955f1877ec70ddb360"}, "9917ef51-320a-4cd9-898b-94b7f904bac8": {"doc_hash": "8a87c475619750360f11c567c76e828fa0f07e2f3f6a54cf87790afbd1a7397f"}, "1cd9b5f2-c02d-476a-bbec-b7eaac8b2cf7": {"doc_hash": "5a76c27cc63544b89ab04cfa80b9029453ec4ab64ada052d72f9a8f6cc78a6d1"}, "090ddc9c-e65e-406e-9e27-792be73779ce": {"doc_hash": "df05123c73d662eba617e07b99f5bd634ec2c7769c10f5ddaac8ccfe89dfc6a9"}, "c7893d4a-0f97-46ab-9641-3d0473554ff1": {"doc_hash": "9e3c27fc9b63052339538b83b4c9419ccb8de621faed650cb93b0a6c15d2f734"}, "ddd96ceb-6a08-43ac-a3d6-5569bbb8dde6": {"doc_hash": "d07cd859526e7c5ae81dc3d0d1d6b94cc66623aaaf067c48022d75dda2e324d5"}, "f3399d71-ee43-4a02-b705-e9b6e70b5627": {"doc_hash": "95c4261a5054b303d257d59cb7e6e3e96d9182eee3667489eacedc182557abd7"}, "1fedf418-8bae-4881-a258-779292d1fa46": {"doc_hash": "a1a86a75782d39052e3eb3a041db33e4c4391688a0f4e9fcdabbabf3c2c27d3e"}, "a197d6ef-9836-4481-9a8d-ebf806025f07": {"doc_hash": "8bdf2b959a168b1857f37eecc010487ab4699860775162c00ed068159623b404"}, "ee128075-15b9-4494-95e8-69f842e66b19": {"doc_hash": "dcb4b1f2c6bacb6b4f2beb5db7d2b8fb9b220ebed3857af5fbba1cf1b1ba5161"}, "4647b4cd-37af-4431-a3ae-504c2dcf74d2": {"doc_hash": "f5a26f585ab7559d3b5ee75fd212f6c5248e885c6d3db6c616643448ac67bf5a"}, "6a0ca485-6c93-417d-9da3-b62a23fe1ccc": {"doc_hash": "467c21505f76d2cdff4cef25d09cf92f3ce92ec5800fd32a7c3fa23a32a0582e"}, "0e23cc10-5021-46b0-801a-841b98e1733f": {"doc_hash": "3d82998afb325348af74d421c4873578675802a1c48115cb5fb942f002b5283f"}, "aa7beeae-4f91-4376-8787-d80a21562319": {"doc_hash": "fca844f0f9f92bf72f3112ab8d277d523f0c70c9a4736fbe4ff9cc433a50ded9"}, "e563227a-515b-4e2f-b835-c1c6954d38ee": {"doc_hash": "d1480030ca7b6b6312ecd5b66ce6e13385640f4e6289024a10c1d23c95eb860f"}, "dcfc93af-a56b-4019-b44f-4272b9291044": {"doc_hash": "610b681db6f9eb90f9f52728eb893bca331aa8f46a57a7e68994d315ab8062fb"}, "f509fb39-5993-4e40-9a4b-bdf976e45be8": {"doc_hash": "adf5cf466cccb1fd13db83a8d47b587e44d4d741ba2acac8975caf70d0e6d35d"}, "c5c69c69-713b-4a2b-a855-e620b2469bf2": {"doc_hash": "be2987ca2faa2e9a39c71f31a992b365387937e9055ff2eb28f6b5172d1e47e8"}, "21b93e6b-daab-4c30-83ea-d7c09466d58d": {"doc_hash": "a5e821691aded1cd4443971050725dbc9b0237d3c8159450be16db11c0cc7951"}, "44bc7c3b-6672-4636-954d-d24b9d933841": {"doc_hash": "d4b0fccc049418fceb3d3334a886a9e9554acb352847d1cc24d4783fe6fceb8f"}, "56f9e0ba-4f3e-4fdc-8829-7ab05a87e493": {"doc_hash": "17b05bdffc8b57f87d38b12dc6c527ee8a75410f8c2b9cc6056d559b96284ec4"}, "17ed935a-f655-433e-b0f0-3585bcaf87b9": {"doc_hash": "7bd21865659215c5ad089dd8c9e63e2a7c4fa5dd2d06ed5908c2a3a213ce03c6"}, "da86aa0a-3ee6-428e-a336-5f70c0681132": {"doc_hash": "fa96d4b005bdbd514a82d41ff5c3fd708785006883ad473dc5e0a0b580655a4e"}, "a8896d80-cf5a-4214-8f05-e7ea877dee95": {"doc_hash": "cd0454924f9de1592c025daae707491ccfc7cc8b56d455d6612a26d1416172ca"}, "cecf2247-2f43-4d26-ac26-c05c35d78ea2": {"doc_hash": "40ca2870631f1cc42ca0f091d5ccb89d0da2ca5002c8cd30783fda5b527b7cb9"}, "5b5be961-b8de-4475-88d8-022399d68eb5": {"doc_hash": "ef9b28ee9c053819c7eb1019194dee5fb5574d6445312210e6f16471e20e02a0"}, "bf708e73-028f-4fa9-8a5e-47cf94aa6ba2": {"doc_hash": "5b80da5361aa08021ed3c9c6738a58f6ca54b5aac0638aba9fecaf673e403958"}, "114632de-9b30-46f5-a3a7-bcee359ddf7d": {"doc_hash": "6c7d0a0a1db5eaee3c08128dca421e931312a80b5e35e0434299f046fb8d8162"}, "8c106819-d756-47f1-874c-d6e955242785": {"doc_hash": "c5dfc1d8f3c513f63c82f626cd9187fe6d91fd2c3cd7975de0159cb6106f5807"}, "cb95103d-b41b-43b0-956a-dac43d64fb70": {"doc_hash": "0469889cf72f367d84e5b879514d6d7b52da8d60be0c30c33499227827ba9543"}, "2c1ceec5-b0c6-4b1e-9617-bba50e0170cc": {"doc_hash": "6c170792aecd5301ec4f0498154a4763f1dd182321ee59d4e42d234e07801204"}, "26830022-9ff3-4fb0-81b0-d4b5c9e5321d": {"doc_hash": "543bd931fdf440c232939a8da3831003448409c670f0100195a1b2baa4454ab7"}, "3e17fed6-e802-4f8a-bad3-1cb66691e67a": {"doc_hash": "4cae3abed3db71872592c376f00a799b00427b29b72d2a043ccd120bbf4d1d43"}, "e45f51b1-2a7a-481f-8ccb-d153a9213491": {"doc_hash": "39dae1653f942722aec0ceb2b5d3a3ef8c4eb9378ffd4a39f4d50b2d4fd07c3d"}, "9167fb89-433d-4762-b746-a232f845d992": {"doc_hash": "98819ddcf77877cd8c94da7658fb767e8562e2bef12b6fc9feff8fca12db0534"}, "b9f290f9-4b77-48cd-9335-619aa436cb73": {"doc_hash": "c2cec5f004a3d0619c0f6793187ac4a584935b943c79945f81efb9e9f2374209"}, "ccafac37-112b-4763-ae18-85c43f5567c5": {"doc_hash": "b825e31f0b587e9766a28108bda83fd0a90a1756f8fb2c68b5b9aa8ea90d54cf"}, "6aa6ddc9-85ac-44b3-a5dc-b737e01d9b70": {"doc_hash": "782ff055b2560afd1c0815546d95ea4cea4b5dca36866c2d9b3e67604d3f3dfc"}, "14239045-30eb-4dd9-91fb-11aab4a3ef27": {"doc_hash": "9e08b541712e49951970aa6a5f86c8a7237fbc1e98c817b330eadf7b0a0a558a"}, "4608da6f-0ad0-4231-b0cd-ece358a687a7": {"doc_hash": "39c5b21e1a84ef2032c510098fabeb7cf051d700949b3bb6394269ee9d695d3e"}, "39fb1508-64b5-4849-acaf-f6ce430c6596": {"doc_hash": "4ab278889aa6acbc66a4536648dd0455fbae83fd6be5d5d8910e47f23202da03"}, "87d52158-91ec-4e54-973d-dc499b24f210": {"doc_hash": "89e9a43c5f6b2e7e55b9cbc5426119ebb5581bd7ce9d0a635c1d122fb7f5d71d"}, "bafc3091-f305-47af-b0ba-b563498e9bd6": {"doc_hash": "cfbba4a6a6c31b838bf85a1482172061a1578c5168de41c455d35e8709183fee"}, "efc2fe1b-45fd-4c10-be41-7bf03b69e1c1": {"doc_hash": "2b932ac2c4a9bac3fcc8455d9141a59b30e112fab2d00cb9423457b82babd195"}, "3346a9d4-3cfa-40ed-8052-4befab2915e3": {"doc_hash": "e15e32899a2247724f269b6d9ac1ae1bc625f0b40a834a9c7c64199c88c01768"}, "e540e024-a838-4dd0-ad68-5a7d5e927088": {"doc_hash": "37fe8304b79e07808ec452e7baa8e6c1dfac00a039641de8c024c0f0b5aa2cfd"}, "2b553800-957d-4f68-94d7-bca9a054fdd0": {"doc_hash": "88f6667ff26add92c3f2d60f6112c33a4fdbf9164c46fc4f00ef443461e93ba3"}, "7f401720-59ec-4d44-8364-f6df8a5c8649": {"doc_hash": "b5ea873716757a4c775a695372fc39f10fbc5edc0f5f33dfb6978462771ec493"}, "15d15e79-4fe0-4306-b06d-f32c3bb1ae3e": {"doc_hash": "a33d2e2aa116bb4bd2c6427f63470716c8323c43aff2043fe2f39c9972879148"}, "bc4bbee5-e8db-4b52-b29a-da25a6faca46": {"doc_hash": "8f2913788dad18e650f22a935b2629410e6f766a5ad2dacfa007dabcb1346ecb"}, "e1d8cf19-4dd6-4682-8e28-520b502de329": {"doc_hash": "7d84e112ccdc2662ea0f5944462047ee08178974f764018d0b33e4acfa5d14d9"}, "0ce00458-a9fb-40d3-a306-0ef1d34190ef": {"doc_hash": "6e95b0bfce5912ed9f9b0842e6ba670456b21e152abe3427e602615adc81580a"}, "3a1856b2-b6b6-4205-bf0d-852eca18c0ad": {"doc_hash": "d7b666079bb7aa5a03dde599511a4e66058a586bf96409ff05863d79b6bff298"}, "457c1c42-ade1-4b82-845e-44e59115c28d": {"doc_hash": "d9b6f71e113a0c6405b6583042234906e0d226594967fa07b4cf95e0fb605520"}, "03bae95b-083b-4d2b-bafc-b1573ea5a6c5": {"doc_hash": "4b0e99bc3dd301812efe22abfb0b3937bb1b6a7466325f06bdc23a8f599c6395"}, "8f662ad1-2c47-4939-a066-f72699dc706e": {"doc_hash": "7d1e01ac7562bb0152862bcdd20a85531abb05642c89dafb11518382f194afd6"}, "5d0d79f9-8443-4827-a00f-d877c124c94a": {"doc_hash": "6837f13c881309757d4b147ffb7aa6ef410a263cde84ea9ea44ac3522f416cb2"}, "80184271-f926-4a49-86d5-97be07677f66": {"doc_hash": "c69366b808002d481d531944b1130e75746039677922753aac1c2d33f7332c9f"}, "c775a736-baf5-4116-bdba-5968271262e9": {"doc_hash": "4ac3e37595cb2a2d0f3331de67783472a6738c414079a84b729e4e70bb639a05"}, "eca13ed7-1787-46fc-8d41-2a1f8ece1ae7": {"doc_hash": "fc7a412449bfe358404d290467a9222225cd02f21a456e00da34718f12ea126a"}, "6904bba4-c48a-4801-885a-a32484b981fe": {"doc_hash": "4c6d636c04b9a384e60b9f153734968b9994a3aaaf2f72194570f699a8714501"}, "38151ae5-019f-4f99-b324-7df5ed92b5c9": {"doc_hash": "b4be424e712d1ed25a62b4e6a68a7f679fa4fcf5af62d5e6355573970e56b14c"}, "971d8269-c87e-4c17-a49d-fcc3deea8074": {"doc_hash": "b2909bd8c1a20682bde38161920938a2955c53eb0208fd5369c7d7affe16ebbd"}, "7c24d009-5108-42f1-9092-ced92f6f122a": {"doc_hash": "ebb6bc92880b7bbf37309e1039e8f5f1c1d1e03c273a7fb26e85c24be41705d8"}, "a581ae2a-654b-4cb6-9aad-64526a04f76a": {"doc_hash": "97d442426be78295bd5dbb7f7bb12f760eac19e04dfc4bbb05b3ebe77805fafe"}, "0276b75e-f3d1-49ee-b4fc-236aa4d0de82": {"doc_hash": "c148c126de2f34d1ba91e147cfd3b13b587c7d9099b93959bb0fbb5343edf703"}, "04c8efb9-91db-4be8-8990-c5905fe3b4f3": {"doc_hash": "b34ae9901a295522e4d522de021d093267e114f4f7aae50634f595432aeae8ed"}, "fe6ba256-f571-4f60-a6d6-2f5d76fbc4f2": {"doc_hash": "63ef58d0b8e10a32ef89b5a4d1165f9f930173f668e2ce0126cdc3e5f3fcb225"}, "8fdd045c-b452-4d92-91bf-9b299c248a24": {"doc_hash": "9f5cc19dadf67c1752b0b481b57d22bec4170759270081db0ea590e338bb3c14"}, "234721b9-6b02-4866-8e80-213ba2c1459b": {"doc_hash": "7e7887ae81dc3d9bd94a0ec7e699184e21eb5ff683b1cea02d381416a7dc6b71"}, "0ba40b67-ae26-4674-9e9a-acb2a56f3394": {"doc_hash": "4159e719764373e859cb1d8eb5f7fb3fa77847f85429476bfd4e7bac5be72ad7"}, "d02311e9-d5bd-4e06-b784-322e73f26c57": {"doc_hash": "06f1f96476c364c5c4b5db16dabe2baf56fa3df9aaa0170b64d5a6a72933dcb9"}, "785d8154-8807-44df-9dd6-af769b07f0aa": {"doc_hash": "09ae936fa9ecc680156c511a72b2c0bac6dc4637f30d2f5af99c10497f5b323a"}, "c5997d7a-b89d-4b61-8761-2507394e40a0": {"doc_hash": "2a799a5efbe67b9077b62b521b00315c7867b1486554108283dadbb81d048975"}, "19e93801-918d-4282-9a4b-30cddf48c0da": {"doc_hash": "e837e72de4e5621aeff0ee3e2ceb77917dce4ca7e4b94b5c93718431fb009e98"}, "0063fd8e-5d1b-4add-8c82-045fe6ff6f3a": {"doc_hash": "37620311ad9faa1d41db69e98d651e3b1078284a6acc319b8d57d945e47489e3"}, "8b50b211-4d4b-4821-a539-16359be8f707": {"doc_hash": "72b0185fe33818159794cec2c280075994e5f082cba8b1c75daa59b5e7467d15"}, "dfd067fe-0603-49d5-a708-cafac975920b": {"doc_hash": "117efb54caad6c288b321a3524dbc0d59f231b3e6b28320518c179817ef17b92"}, "c5c165ea-2e69-4106-b490-3e88aa7a6cf1": {"doc_hash": "4fdc387f973c28d5c3dc0123037df83d5736a6d80dde9b927381b97093d37d8c"}, "3e1357db-0d6c-417a-ac58-5a204ea30351": {"doc_hash": "20a8aa416acb4045176b14cfbc58f4e723efc1d0eca005ee32a7d2709615817a"}, "bb8cb03c-b84d-45c8-8111-1ea6652c5e10": {"doc_hash": "ebd4032091c29589a71b207b2abb15782e458c4a973560f75818cd7f711fc772"}, "9f9ea3b1-e133-45f9-925b-a881bd94f9bd": {"doc_hash": "d21f40d59d29cfb5e9bb946cd06d9815707eb62de94d4e31f828880fae0e6e65"}, "53956d4c-29dd-4108-9497-1da36dc63c6f": {"doc_hash": "4c2d63d3648810ef5c981a87f9e68c6caff79cca7b5d46f9ae27325b2d022bef"}, "762165b3-cf30-40a1-9890-05b1bd6a7aa0": {"doc_hash": "a58886618f305815db6689b2c6bc77ce6486f792bac9b30a793f78cad5d84ac6"}, "ee687696-8b4d-46fe-858f-496a3d4dda20": {"doc_hash": "d07fc6dc79a7a39db8b89764f88f056579daea9ba7221080a750f7f0d9692ba9"}, "d4476196-7a25-4dfb-939c-657bf8852838": {"doc_hash": "f085ccefdaeb02bee00e4cb83fb444bc4aad9e98067cc3d7be71159daea96cb0"}, "8b8b6da9-a36f-440d-90c8-f6434dffb4d2": {"doc_hash": "606d8889904d458fe7dc281f4b3963ba5ab4a5d23ed8a70debb0b8e7a20a0f3b"}, "6650b649-d903-4435-bf1b-d7a26e61fe86": {"doc_hash": "a01bdf4d058799ac7ab64c49cbfbb1199883374d3171efc42e83149bb58d666e"}, "c2fd7088-d6e0-430a-babd-5f72b6b5aa9d": {"doc_hash": "774cfbeb08d75eb171be920e47af1f54ad02db5668872e7c4ce53ff5a4d14eb2"}, "e690c4d2-8baf-4595-9640-e564cc8d472b": {"doc_hash": "9d96ac753a5ea2a76e1b57cddfc170a8540432405fdf8c13ed26bf31b1e26ddb"}, "05747e15-8e37-488f-9692-e33ef86e8ce0": {"doc_hash": "d963dd4e2f0385d2029db13d1c91450b372c354b3c69bb13736eb4013a4508f3"}, "69f5ee2e-4e66-47ca-8e65-dc1010d73b0b": {"doc_hash": "157fd406cf0d42e685ab07de00f83661065925835dc5a90774e3f0cf286f7c8f"}, "33ad6aa0-b2ef-4e06-b5df-a26aeb760b34": {"doc_hash": "3c861d510a4bbc7be6ddde928c4af715d0b394f23b17a3084e4a70899023af01"}, "5be53cfa-ce6c-4f79-b84e-0144051b36df": {"doc_hash": "9832d21da0b04f6bb466bae7d39aaae1a8000feaede8d914eea33b4b0357873a"}, "48e829f2-6f0b-40bc-91e3-d3e60df8dbf2": {"doc_hash": "c0799397e21b94812d79fa80e3a2ef3a4c77ac080ade261120ef43289a6ed058"}, "7359bfb4-f319-4cec-9fa4-5ff20b7d1356": {"doc_hash": "52094c64703096c325a12866ae261b66e7ad05d0ef56977ed541ca459c9d337d"}, "7a7b53a5-e10b-4db9-b62a-a4fb8e73c083": {"doc_hash": "6f4d1008e9783edd8ab468d0556eeec3806c3a6f3a02751cde42c0a132d953fa"}, "5f40c19d-e13d-4ecd-84ca-53b30f4ca2b1": {"doc_hash": "6c3f41af35be143a89b9adb311fad84f2772dafccfbfa944f0f64ecaaa11dcda"}, "04f47935-4eb2-413c-a396-3ee88762431a": {"doc_hash": "116d1f58661e0ab8e009877a595d2689f106503775b5308cf011a87060013848"}, "9abc826b-aaac-4f70-92e4-56573e5d8295": {"doc_hash": "0abb5248bfc97c982f66c6f4a57823c2d981e7493efd93deb6e151ce2a2966d6"}, "bf77a913-0cbd-4f71-b224-5f9c204e497b": {"doc_hash": "ed4e834fac535014088f36bebb2fb2da9e569d69c8bae8696212a7da3ec23edc"}, "d8697d45-c8d6-46b2-81b4-061c436099d9": {"doc_hash": "88194ccee2fdf140a595bd0b64c979c8cd55ee673367a7b71159ead144df1832"}, "5a64a2df-968e-4f10-a4d0-38d68d4b22f9": {"doc_hash": "24247d2cd3f0875312d65581f748d5903559d0951aaaf05eb4ea80ab75e9696d"}, "672c52db-1169-4d88-9422-a873ce53b643": {"doc_hash": "8ba070586ef608d226b4590f8d18537baf511bd7ce518282cb22e660947744be"}, "fef06e5c-c24b-430a-92f0-4e1b10b3ccdf": {"doc_hash": "f7de28d86c4cafd31fb149976c0a42ed96b35ae8788897e569e351b5248ef38e"}, "98dc8c61-0938-40a0-bcd1-865c86dd1d6f": {"doc_hash": "f7c935b4d97fc51632e3d364437d88d41049e237f3d22f9349afaa4c1ddb3cd5"}, "e777113e-ee66-495a-8484-fa5a32bcc454": {"doc_hash": "1b862f6418ab892521676633215407369c4a490d9c4e9ed8ea681351afeaed35"}, "6f6c2f5f-6b4c-4296-a8b1-a9ec10497351": {"doc_hash": "e13eb96d6b00abee1a0f2f015f7cdccbb177511b1af2d5f4262169473545e13f"}, "66108743-8e72-4c8f-a2a5-34d8b61b174f": {"doc_hash": "4c820fc5025e57a136e9edf7ba5e2b83cc98344d9ebbd80e970dd78895f1a6c8"}, "521e1d8b-fbaf-4ab2-b69b-2e48b8230a7a": {"doc_hash": "637ed75cd760902073c66bdbf5bf67ee818ea716d5845cd310354266683429f7"}, "e36849d0-c59d-42ce-8dca-b23571fb2860": {"doc_hash": "a80d3456541be68167ff82563977ef247b8e838b0f7bb909f5ff1100d0609c51"}, "3fd3611c-2a79-4be7-8fc6-a7deced046e0": {"doc_hash": "96baaee09ec01ff359877ff048650dd7b53b36e7b5c0c77fe2087374e550d0cc"}, "666b246d-da04-463f-a8e9-c11b622f7fc3": {"doc_hash": "d484d90367c921e366f31107027a9b7ef3c511bce1d38dd25c36352a729922d5"}, "e5fe52ac-d081-419e-8b6b-b6d548f3d0cb": {"doc_hash": "90f9c209946b3335b57e2a14915b10d4823ab102323bfbc7b5fc4d67e11dacf4"}, "17da1750-e889-43c4-b7b3-35be6ee52db0": {"doc_hash": "ca512b4472782409bfad34bb8dfd4694e532cc8c4a71b78d2015bb5e4c5e5334"}, "ddaf3c7c-18e8-4213-b2c5-d99f960bef47": {"doc_hash": "df90574a5ef77b0f9c85b8cafe1be3e6522c50c7ee86dffb3d92650baee04787"}, "221eeb34-7b96-4f24-82ab-7881bc01e7ea": {"doc_hash": "23fadc65633ace430a6a4ba4004a0fafb17ba5f764e43171370ea4964f794f66"}, "7f5f8800-2f00-4524-a28f-0f0746e72ab0": {"doc_hash": "94a5833a41dd3ec2627824b3e48b826a50fa337a411a45d452298bc1fecdec04"}, "4164172b-ca9e-42f0-89ba-bc7e969461cf": {"doc_hash": "288a43b6168e4be9a5b25e708670d8fd3a8c3788e21f92d49a880a381a9efaa9"}, "e0f9db8d-428c-424f-8a25-ca6c429119e0": {"doc_hash": "fde4dd7963cb05c6bf2a3540b04a0391f95a742cccf883c200b2f38d5e3fc72c"}, "7b2ba05b-7a15-424c-ad27-c400e81550a6": {"doc_hash": "c33e3257d05af112aafe4ac2e8d06ae700cdcb1e7e500d47317c05599ca98708"}, "a1614889-9620-4646-9cd9-2887e75271f7": {"doc_hash": "66efdef306b627369b4a6c879ec4f06300c51ed0c321af3daea07ea94a0089b0"}, "0f1a1264-ec42-4ed5-948a-64a1883b02ee": {"doc_hash": "074b4447af410f4ad5906b1cb9f00c920213d219710d02dd509e3f292e718428"}, "9c8a1a6f-0bdb-4f4d-8081-8c911d3bf814": {"doc_hash": "f9b05b8cbb990697ee6d667c51cdedf8d6e6aae508740c6cb735162c413e1cd9"}, "0fa3cadb-bdee-4e32-9bbf-6f4544a28df4": {"doc_hash": "f4eb827c3f664f79d973899ae97a8b8ee74bb41828b0b9360255a4be9bf42a65"}, "86b27ff7-96bf-45fd-a18e-4c5a531270cd": {"doc_hash": "4543c92a26d1034c334442a46fbdbee6d7b3cc2add8076341607b02ec51ebf15"}, "4a967455-ff90-443b-aac0-f253d5cad787": {"doc_hash": "a0c6bc09eb30b602eec292fbcba2abb5e0a80e3c4464a085b1e35e95eb948c58"}, "47bafb77-7ede-4031-88a9-d1a15f1b4174": {"doc_hash": "c747ce690cc86182d103fba824b8f3436801007dbdfbc820c04748e4ae945f07"}, "6bb9f562-08b4-482c-879b-f5204c24863c": {"doc_hash": "d1134e3fb42078302abaa3e82c71735deccaf885e0d553aed197979c32fe13f2"}, "020c9962-814c-4544-b47d-bd5e088dc0d6": {"doc_hash": "1ede4c6f73e097c2f86b293365f7f6ac0e434401d2d2d4ecd387ceea3724a188"}, "3589c68e-a936-4f7c-a72f-b52d267396ae": {"doc_hash": "3573095b1a5cac6967702a0f7e8ca9d4c9bcca8368610fbefe476ac81a409030"}, "cc07f000-f142-4a45-a1c6-3c973f3ab86d": {"doc_hash": "b6e0d140ae1f3cda52b2fc274d77dc852d5d40c84f13d3265e621362a3062a4b"}, "3e31bb1e-7bca-4f6b-ba14-043a85d9b35f": {"doc_hash": "98d71c1a26eb4300df0f4196ef1145c2086d238dfc854c6a637e61dffb053d3c"}, "cf35a497-039f-4925-b96b-0853163d220e": {"doc_hash": "695bb83812e856b38714f9ab051b91dad54c5cee8fbca585b49071c4ab4408d9"}, "3973cf5e-04b2-4f24-8bf1-86bfd34c0766": {"doc_hash": "e7cbbcfb8c59c587c9b0a3c55b1f7b58904530a0507e8f485e8d9fa4a6a5e46d"}, "76c870a1-9718-401d-a4b8-31c12741fb34": {"doc_hash": "901e44fc4d8c0d632ac8a337ad66bb7da6aaa0acb6781471631fb1744867c927"}, "a931dbc2-698d-468d-a59a-ac3ef6a6ed5d": {"doc_hash": "0f0860fd6a353ae4f2a49c5c2ee275c4d3e70fdb6f8ad5512b770888b2701e52"}, "beba3d6a-0c00-41ad-8245-0795732d0820": {"doc_hash": "c300d80bc72d10a5f95187514f9146b4908742d42a3a99734b49df7ed4fcb3e4"}, "422d5eba-01e0-463b-9950-66defc80145d": {"doc_hash": "6e721a23529c3d78412f26f3ef975081d08c3aa074f85c368bd0f7fe567cc444"}, "5b4fd09f-cf8a-40d7-a32b-4c05b37fb621": {"doc_hash": "d713fc46398b5e67ad437b0219ab575f1921a9663e42cfd667b5e6f2046e1ee4"}, "90cd8423-ad69-4429-b027-53fad49f1557": {"doc_hash": "8f8b05e6ad700fb353357d0311438bdc40f8c7ce3ec254ba23dddaad722deef9"}, "2f24ccb9-6097-4d2b-ba05-cf6a835d6cf8": {"doc_hash": "b75eafaeb65eb85934c1034ad60099a401afd157939b238de5be135996aeae3d"}, "b01ffb6e-6570-4e73-97f9-ea92357b20a0": {"doc_hash": "65c6b306381b57fa7d3c783a3fc7e791b3c19b0d1aec82e8527f06b74232f4c2"}, "80efb101-c438-4a56-9570-247a51f2d5b5": {"doc_hash": "677ee5b5e1304a5b268ac93c1d3d355b689846aff5f108cc04c9ed2c9e941e39"}, "b23e1269-93f4-4c88-b3b1-37058eafacf2": {"doc_hash": "45d88005a037d9e479c858e334f08144487e0fe980508d6f21700293603251d2"}, "83632113-3b93-4dbe-8baa-5492636c0cad": {"doc_hash": "78caad2ad7b1456710cdee866936ddd6a94d255a4a182a1b4ab9b39230419d38"}, "8ab14ae7-3e5a-47ff-87cc-29d655c0f217": {"doc_hash": "37820b8d406430f340825088e02b6795b99dcb587bd22a404c9d6dc464ffdb69"}, "b1c36591-ecdc-469b-acee-2323ddd22057": {"doc_hash": "e5738402c7454ba917f351d670f0522e950857715fda61268a57878c7b894b73"}, "8b61f980-b631-4fa1-bcb3-4545ef71f0e2": {"doc_hash": "4abb2809de058ec19569fc203ffb3bf900e1c4ed2383f8f76985c2e72abeed8c"}, "62807149-20bb-4ea0-88a9-b388296a678b": {"doc_hash": "477ebebf63c26dda1e96dc7eb387d33e4ab7f8c4fa1ea1d4e475c6a1ca3f48e3"}, "4239e245-38c5-48bf-8c5e-5ab54771505a": {"doc_hash": "ce2171cf74a6bc04337d2f292fa8297d9ea8c5a4208532973d4f3f1c0c995081"}, "5dc95019-dd8a-4163-ba49-8a86f9bab2be": {"doc_hash": "a988af7ab2f5eb484dd40a129e216a74031a58d0872c71e8c19245ec0e07d32d"}, "b210da89-1cc5-4301-8579-b769944ca6c7": {"doc_hash": "1a6e01b44a6a0a458c3947e64aa5094c763213f3503e782566768cc001d8148e"}, "835380c0-696a-46f4-ae60-27ff7743de58": {"doc_hash": "f7cb9baaf6e62bab9a8770634434e2fb8907a2cca2d2d069defe4b284b2abfb1"}, "d19893bb-b70c-41e9-b28f-e963217d0772": {"doc_hash": "74f28f0a8079c61d36f3d555fbab2d0400ea25f7fc474d4c273c6d4f123585eb"}, "534eec77-5499-42ab-a7cc-6e08916763ae": {"doc_hash": "a7a48ea9df4b6b4f661561c60c6955ff58e378f5600c51bb7c004d63c23f9ffb"}, "ea20ea8f-b79c-43f6-8de4-4a863a9d5c36": {"doc_hash": "dfbf045610564afcecd98a425d1a88b212451b74d801a3a11ba20347f315d53b"}, "421728b7-8c71-49b4-b01c-db40d671cc7e": {"doc_hash": "139f7cc388d524a97aec077b759ec3e8283bca7624d6a0e7044f6590a6be3ddb"}, "4bb40782-9d07-4fd6-9471-5594a5ece7f9": {"doc_hash": "c16a2091614dbe612467e2d96a9cb710505d8136e389f333f6fa64b97dd83ba6"}, "9d9790f9-0c0d-4abd-a9b2-cac5867c3cb2": {"doc_hash": "6c1b768abffaef863cc51335964ecec186feba984bea9605874a06b66ecd66f4"}, "a7a1fac0-f06c-46c7-a259-40c3a0447dc9": {"doc_hash": "d25aab84b86160c2b8d8ee96512151e6800761d59609f4dd00c2da051bd1e3a1"}, "0513a6ff-37d1-49e2-996f-e00190978814": {"doc_hash": "fe75da84bb2f72acc0bb46f725dd17f00fed5ec2415e0811b266dec6e224454c"}, "d163693a-db12-4f49-80f4-20720b5d771a": {"doc_hash": "b3518e43eab28da79593ced41d7f2cd1870925d28696baac92d3a68ef478f87c"}, "04e90bd5-78b8-4576-baad-68fca27cb845": {"doc_hash": "833432ac3dc805669bd111011fc2bb67753942a44c977874ee59a0628970668d"}, "51aad2c8-e317-409c-acc2-6c68a59b386d": {"doc_hash": "1e6ae59d02f8ed5e69d607ee58fbf8fde68b5b02775613a29681b98c3a0a54db"}, "355a0b1d-e050-4e4e-8118-e13795aecd31": {"doc_hash": "451a6591f37799782496c895fc1c6ddb1f8d96f084cc41ca542fc4a9e52e189b"}, "2aa3f0ba-12df-4f3a-ac5a-6dc7763d04cd": {"doc_hash": "ebfcb5425e74a6f174c05b69dff38b3285eeb8e0fe89624ec86816f3904e53e9"}, "ffb92656-4510-4f1d-a9a8-6daf413e70ec": {"doc_hash": "d901a005cbb9548d3e36d111e292738bb7af5a7c12e069a940238454d43953c1"}, "991644ea-d5cb-43ab-9a3f-f18e7b808f76": {"doc_hash": "fa5516e6fd148e029a211b40ede1c9e439daaffb41895bd8b396f3ec91f8cac9"}, "26739b1e-9b08-4610-bd98-2c3d1e56b1df": {"doc_hash": "dd9e8cf9f9eb2bcc2b2ccdc04192b0467ff7ee3613092a177e5c674b28c8cae9"}, "3d64891d-cbfb-479a-acc5-7c2439671a15": {"doc_hash": "5d8b53fe882e51229f737d6dc87a13090608ac6a885506e85dbabdf8c61d709e"}, "adb98f3b-d644-4796-86d1-fdcd0a21d197": {"doc_hash": "53b15e01665899dd2772312fdf45529845d8416da49c570db22f24c6308d1f19"}, "b36374c6-dd3c-47d9-b0c4-e1da34b314ac": {"doc_hash": "272d146f68fd06e47920941deb46ea47412daba465967628448ed1790825a9e7"}, "c496cf3f-db7c-4676-96e3-985300013278": {"doc_hash": "f8547aabd7c2fb2302bbbc96232309c278beb9c3462c64f38bf2addcdd6b53fa"}, "3936185a-e789-4c20-9a73-0436893c3cf5": {"doc_hash": "c98ea071f96aca425353a7ec5bbb2820ba117d7345ebe49ae7a1610c06cabad5"}, "d489f49e-eb06-4d55-bedc-9fcde8ebfa8b": {"doc_hash": "f869d353d06ce6e5baf5370b8628ae806efce209e0aa0a93126a7361e7e82834"}, "1167e740-3499-4055-80d8-2b1e36c0db47": {"doc_hash": "458982a0f22be57e264e96f9ada140dc8f07d1a66b7bb433210a61de9f2cd24f"}, "5d2fa64f-63ad-4567-937f-80cd736792cb": {"doc_hash": "ac2fab64b8bdf2786fb895e35f8ff8f911bb3bcad03f4f9be444e357cfebc884"}, "61ca1e37-ff76-487d-89b5-0e104b4f162f": {"doc_hash": "5c38d32a7337d78915a9cb733c30cecbec39554a4f87b033c9277e834888cbca"}, "45f1e8bc-cd76-454a-9209-6481d61aaf2f": {"doc_hash": "df4cd0fe5783b7498d555783978786b6d1e6770c9a1fea259e76b474d42afb80"}, "9124a20b-faf2-4a4e-b484-4be817e719e3": {"doc_hash": "65a6746b20a992c81c3f58f124ab7752b29cb17c54ecbe918b5180ca38ba79fd"}, "f36f125b-1496-4cd6-9a71-ce3fae0223fd": {"doc_hash": "b5851c1a915d82b6d9b3347c27aadd18f73a1db301b34228b68aae72aa335543"}, "b52adccf-20ac-4702-83b4-4427290b3b6e": {"doc_hash": "6a0f6b9ef46ee4674309a4389c4205ac238566e33af9e86990e43b547f7d0929"}, "16543eeb-ac14-4029-8648-f26aa526e10f": {"doc_hash": "fe97bb0ea6e856534f45c747c9008da8e185f929b2b30938c08f528adbfa13a4"}, "5d5400c7-c8b7-4bcd-b06b-43121fa9a67c": {"doc_hash": "c79da383657e7752c113148c57999fda1e576a3ff82f3af8321deaebdf234645"}, "4fc8c988-dfcf-4bdc-81aa-ace38e2be9be": {"doc_hash": "72ff032552bae0053aa312b8b1acb6aebe47668441fefd80a664872f335fc6d2"}, "e8976e21-25dc-4b16-ad08-a19d677726d6": {"doc_hash": "cbbb2ba5198e3a2b5a3314857d811e2a0d87ffe6d89cdef79620f81e4fb2e818"}, "3491a0f8-7885-424a-9421-b76b94c74c39": {"doc_hash": "d40909cd69c3ab3b0bd5c66c550f7e4a3e6c41068a66805213201718e5c89fad"}, "1e4f4924-aa33-45d5-a297-f62a3ad8f904": {"doc_hash": "921038edbb70ad306875095461313e6679d6ff8c7f41641791294d714f6b903e"}, "74ba0371-961a-455d-80f1-aa3516b441ce": {"doc_hash": "f72df64cc7b4cd43a40e3f7b2c7fd8dbf11e91e2b0f316dacf455a1b6098697a"}, "a951f138-1070-4ed3-9f72-4d54ac44b4f8": {"doc_hash": "69330acd4f61369e5f5ee036fdbf4ded3a1dbf45c9b6515ea1ffd91c64593f02"}, "74b15e6b-e45a-42e9-9501-c1c9de739b29": {"doc_hash": "27e0a19a75b27563b20e6283e7e00afe63b6fdafb8600e86eb3cf61786efa9db"}, "c103fa70-4986-4919-87ad-5c0afc65a55c": {"doc_hash": "54a841e1117e900d01b01dfd0fd3a45a656f64f52d758ab459da027209e276e3"}, "1bd0666f-a984-45fb-8d43-bbe717549c59": {"doc_hash": "fc064adc044c79786813e6e3fb2fe1f15756918b61c5bc216b257966e79f8bc8"}, "f9057212-8280-49f5-8633-560064ca7e85": {"doc_hash": "1f3b9c158faab71cf9aca74a50c1be80edcc27d54ffe0af21f98ebd399c89f5e"}, "73d30326-d346-444b-8427-60423669af22": {"doc_hash": "41eeb06140b7fc2193924552c8cc54104fff5255aba1824fbafecafdb2eaf208"}, "ddc5011c-48e6-4995-9116-b1dabcf29a6e": {"doc_hash": "b57fa59b3d8e4a6dc056b53c24ad69fc436cd6b3a870f83f08d330f39cb9662e"}, "0048b2ab-bbec-41a3-825a-237df653dc3f": {"doc_hash": "e98ccbc1f9745421df9741724cc46592c8b7a97939134de63e62a8ea89e99e61"}, "b263ad4e-acba-44ee-858c-66516c49a1a7": {"doc_hash": "e5cc4ade696368d48eb9a3ef5bafa26cc4625416ec560be94e0bd88ad4c3c81f"}, "f1e400dd-661c-4f6d-b041-d5af93ab6a14": {"doc_hash": "4793a44b7f2978050839c11e68fe1ffef7c2720b05a362aa9a5b18691d3bd7e7"}, "d1caed6c-ee34-4245-b916-a15da6b54bc2": {"doc_hash": "2661dfd3f22a6f56d7d44bdd6a832dd74fbc6dff7ea7c17a08bd0c2be58af740"}, "b1bf2f8d-6b8d-475c-a0d8-42bf64e1c085": {"doc_hash": "a14fa0268a64ff5b5d62c15943a8313228d2c9a809bc09f345ce6abf790f5291"}, "fdd13f4c-1205-4d85-908f-2501d10b8439": {"doc_hash": "243b2030386804a79370ced3c96bb30bea8ed984dd6e46ffd7df79ee76489366"}, "0042a8be-64ad-41a8-842c-38e95d1a43e4": {"doc_hash": "c96aee67143c3ba6570713411f89fb39f6c2751f7508dda89f819f52428623d1"}, "d312320e-84f0-4848-b89e-678f0e249b16": {"doc_hash": "02b8d4c6f829c6ea4aeafd66a2557e2f0b7a40728323822695e255bead531182"}, "f19b4a22-e22d-4574-80ce-78857f8dd971": {"doc_hash": "673bba7880c8a9612ba0147612af86f525ea49ebb94d074c113f9180b531aac9"}, "c813164e-7534-45ca-b9d0-689c537fd914": {"doc_hash": "b4167e4fbd628fb7fba1e8ec74fe06998bf24da93c1702485a789447de49b213"}, "cba44fcb-580b-4544-92c7-ec1282434a12": {"doc_hash": "4debef183c15e29b723f85a2770374574677ce56791a7944b1b8e93bfb1bf999"}, "4d594d2e-fc1a-43e3-9943-125e8794d69d": {"doc_hash": "1c4a3b700f253d8ce5708efdb318dbe6bca0de58da2d0eb1361d00c37824d74f"}, "33ef6d4e-4ec5-458f-94f2-a65b4d005832": {"doc_hash": "f3f939f8245d8d1b4570e18e145b92fb82b6ca51dbbe795ed1d99f86850f427c"}, "f68544ad-0038-43c6-9a8b-53e0ee19c017": {"doc_hash": "d7fe416af0a8ea47029b35f29e3b30355e6c6c4435bbb1c28dbce77804fc4b01"}, "f90a875c-76d8-42ec-9e84-91cdbabf3749": {"doc_hash": "d8dacf5dd0e5f2244b0ad96f734bca12497e75b6138638518c866b830ef2a212"}, "05e5fddb-4fc1-4ce4-8203-d3c12b06876e": {"doc_hash": "ebf80a629c2060b98f4252a455977920518c80febba8d78425dbd427fdde3890"}, "34114b5c-f30a-49eb-913b-4c029b66924b": {"doc_hash": "5343fd0294bcada0b152a8960d56a156d82d412c6f440b16816ebd71af0bde01"}, "24d0e59e-7c0e-4d9c-8694-862da5bd9c9e": {"doc_hash": "979fa49445ebb4bc85d6941cef9557594d83f311f10f7114842c121aeef8942e"}, "22b3f44f-4ad1-4d34-a82d-571c2b577b6e": {"doc_hash": "a8621583215182dfaa0beeac9dba386e390167b7478c2beb709a6cfebab0ab9b"}, "1a76c8e1-ebca-4586-a5da-e59a20636cca": {"doc_hash": "ae66225ecc6f63b01da54f9ca15bad8980d242613b1de70bd40c7be14bb8f802"}, "3672e5cf-e2c6-4a0a-b5f2-20e5bdc4187b": {"doc_hash": "a4ae7415f8b8b12a4093ff4ee54f85ffd45c06fe5851a987b24a2c18d3c48b0b"}, "172c2c71-ee13-4afb-ba6a-0fd681edc954": {"doc_hash": "5b036ed87ad4735af039080744d9a72ddea511e7cafe84274d31a4fa6c8673de"}, "53a407b0-b77c-42d7-b003-4e4980be6e11": {"doc_hash": "3c621eac4f7ba2f789b228377852bc63a5a3deee3b628c5d9cb3c76e41520c89"}, "8a597797-d489-45be-9578-b1f11480e9fd": {"doc_hash": "eefa1b57927501f7a3452dbccaf92c29d2948ec877fecbb1efe779c37f051fcf"}, "00a8a64f-a260-4723-9ca2-905e109f75ce": {"doc_hash": "b26f8cae5f9104b183434416bbfd49ade857d77b77a038f835cea17f75c1c5ba"}, "47c0629d-452f-4451-87b6-06af971fa3e0": {"doc_hash": "6a7a0e22a27dccb69ab9a1a9592c81ae2392073eb5b8683cbc46d759f4e2f164"}, "d37b295f-ea6c-4bee-a644-19a1951d38c9": {"doc_hash": "9547f25fd7a1d7d8504151a3874106641395408f14f3edda62402d9a1a7a6a1a"}, "4f65aa5a-c28e-473a-8ebc-46652cce472a": {"doc_hash": "f29fb808207bb699df082481e0317d39468f6aa00268641744c3bdcaa640862f"}, "7f23e810-8db4-4937-a758-99e6a5459297": {"doc_hash": "96b40b581b068a22b6deafc58a7340e8f54506284613bd2e572f814d688b5bd8"}, "49fbf5fc-83f9-461f-9835-416e44914a4c": {"doc_hash": "8d99699af3361ac2460ced1e2a837d56c9583fc3892b6e6cb99904ae613b235b"}, "076682ff-baaa-4474-8b2d-d2a31e7d0f6e": {"doc_hash": "0d315b7964f042c9158e162414ffbdd3929f85ddfbbc36754a63847083407160"}, "802109ea-1595-4395-9f9f-8d08ec973ce6": {"doc_hash": "66632541981fa29a441fc994b6901e6975b64810a4b418f580506bd30d8e0233"}, "ec51867a-8144-4cbb-9a1e-cd08f30ea021": {"doc_hash": "9dfd89ea5d70711f49acb874f3d42c600b389688e16f2390488072b0e41c7aa0"}, "c3f5dd12-57a6-4a0c-a35f-a2c956b303fa": {"doc_hash": "632eaa893ebbd5be926c7d3e8ef949c9d5196d7c2d52ff21b4b2390b6e30fa1e"}, "a8f88bf6-abb2-4231-8cbd-de26991d3960": {"doc_hash": "b3520e6bd8f377d57dc83ad9af78e02a5316b57b07b2915f6e5936a13c855563"}, "cff4897c-4ac5-4f1b-839c-860ae2dc8940": {"doc_hash": "8c7ae08c2edaff3b5f97b9d19b81e3b6c11285740ab22d03d5032cab1e3eead5"}, "2191a06e-6b93-4504-a434-41d54402c08a": {"doc_hash": "d7a044c82a792f71db0dcec567bb7bda30689e48f5f8cc984e2cc8ad1198cf90"}, "d7b9d93c-ac45-4c8e-bd66-696ebfec0b95": {"doc_hash": "1b43d9ad5c45865df2933f943b0fb0e479ee95a6d5ecca5494185fb53f7835fe"}, "0f3b430f-d94e-4094-8987-a82abc37cbef": {"doc_hash": "999eedbdd685a8442e203167e4fb6630d1cdcdbf35d8242a025e4c0f4b12305a"}, "c7900d1f-274a-424d-a9e7-9fa10579c4e5": {"doc_hash": "635677fac13eeacbf68e693a66b6b3a39c4f8f6246ce24e012adf61927807d6b"}, "b6564d06-a3d1-4a35-a6bf-bb075580aca3": {"doc_hash": "5fc78165d1cac2a2dd85b8db3f61caa5cf72237b48e03324e06f03ac59fea40b"}, "883da25f-2f2f-4aeb-a855-b3aff3ce6e1a": {"doc_hash": "2c3fdb8b61267f248268bc60b1777908d72de1675b579897e6ed409ce6ab981d"}, "ed99338a-8f5a-4e52-a126-b188170f8ac3": {"doc_hash": "da47689ae430c7a173f0174a5aa8a4c9706a1cbef17648c85c819e2b59aafbd8"}, "d0c9644f-9363-4b47-b654-bab46ffe7129": {"doc_hash": "8bb05c6610137e1b01a33e7c8f85ffda247c1625c39bb9b305bcc1329acce45c"}, "482a15e4-81de-4ad3-b20d-dc2c329b3546": {"doc_hash": "32277b20febfe9e9b639bf2d4dcf9e96b6cf3fabeecead412e811cfeb15e7dd3"}, "968764ab-bf07-4e25-869e-b2b523b82596": {"doc_hash": "46552998095cf90222329099f31650d9727fc24c6332f5c0834b41b2c3266d1c"}, "e8752142-6031-487d-9763-25029c1306c4": {"doc_hash": "34e0888976643ac033955976d27d1b15098cc913a8af5245f051a9c89e4d9b21"}, "33789f51-26a7-4f00-a805-80a0e048d022": {"doc_hash": "fdbc47f0d94c03505b53f9b3737c810c89f03037c4ced91ac6ee2f7fd0b05890"}, "844d4de6-5546-48a4-8e19-52ff5f53db1f": {"doc_hash": "e60675633c6fc930389d167928048bfa4635a6783ecd6624610d6f1f696c46a7"}, "f7181f86-4f43-4e3c-bd98-fac5bd944c09": {"doc_hash": "f1429ce3a1f2847b46ab21069b1d1cb95002e339c48e32e192d85587fcca400d"}, "cfc6e13c-a2bd-4544-9f3e-962289387ad9": {"doc_hash": "518f9d342f30d1bc3498ffbdd766208ee89a5f0760203945368a98593c97088a"}, "ad738fc2-314f-4daf-8323-49459a457289": {"doc_hash": "69f81427e09ffb4816226f63bc1107ae6775a10dd637da75f05c04dad7af9f53"}, "155b8336-3c6a-4660-9090-eca9d4950100": {"doc_hash": "95edfd747696ca2262e5967bbab956f1de048efcbb4229bbc1273e4038f0699f"}, "a1a3ba85-82a9-438d-b0f0-575d72eb6a60": {"doc_hash": "313cf535692b3b0c99207e75c6d2ba66eb278781869e09cd7745be99024336db"}, "cfd75abe-704e-449a-a0e8-6b029a54bb2a": {"doc_hash": "7960308b8e51e523b0de4dd141c00811062640bac493c305bb21728305a8bcb7"}, "46c8b4e6-3700-44b5-a09f-c2a27d74c433": {"doc_hash": "5cd8cefcc0cf8d2cc1c557240913b539853a99d36a69d225a4f452270c81417c"}, "e769ceca-6dde-4184-a601-83a332f11aa5": {"doc_hash": "ba8dcf0a66feec66c490947b932494958cb5639e08b8e5159e5555c524218649"}, "c5cf832c-8969-4bd0-b5a7-e8298744b247": {"doc_hash": "315cbd13c0a5fe66bba7ad6221013c84041aea1f0d5915234779166758d6d231"}, "3261e187-a18b-4de0-abc0-e4106d8b878c": {"doc_hash": "c70a44204e6a54bd4b95d51bcd5b81224289c4698bd72f7d1680b6d8c61a5e60"}, "889978af-4efc-4ae5-ac49-3aca7427c233": {"doc_hash": "e0f5bf598a36228cf90462775ce84e9c28b2163dfc0954f1064949da96d9a66e"}, "f5b9a272-52f0-46e9-82a7-fc9a7bac64f6": {"doc_hash": "79fe971c32ced315bc48eadb2152d7ee3bacad24ed852ad5a02f1ec7afa20ecc"}, "1c039564-05c2-4d21-8f8e-404c80798eaa": {"doc_hash": "b345acd422b6369cf438649613221d32b785605c7d87fefa95126e84d1648eb6"}, "0c051f7f-aca1-4685-b374-3b3d200d86f2": {"doc_hash": "c26b47023473a3b0e6dd1267a156d0e95411a66ee814af5dfa2b6a695c250896"}, "9024f802-544f-4a3b-90ec-742cc7fc7c02": {"doc_hash": "732b58885c9c1907bd464511375b3a5c3fee7efff597f53411030dc3af2f7f62"}, "c010ea09-376e-4217-9b2c-d5e95baf2ff7": {"doc_hash": "293cc3a94904b36c66bb622a89b0aca8764b1bc20c3d58c3692d5b61b92dee70"}, "905799e5-769f-4ae3-bac5-391c9b564d86": {"doc_hash": "81e8bb71779fa9edb0a81445d11bf12e1385fbc2e0da9ee1b4d1d93353c4deb1"}, "c3a8dc9e-e5fc-4420-960e-35e084b0f6de": {"doc_hash": "8725a968e12367a4d16d9b6c8d0695ff7dcf3ab602af85c44f3c75c294637d65"}, "614bbbac-9060-4071-8078-a73c0aaaf020": {"doc_hash": "25b0caada5b8d0d63340be0efcd361f899bcf8dee560755024d04f314f68a51f"}, "4f82ee2f-9dec-4bbd-85ca-6c164ae4e794": {"doc_hash": "91f288e17534f435849328517ad1d83acc03e4c8e27e2c51cdb09aca8b724934"}, "47c52128-3a12-40af-8840-870dbad382ba": {"doc_hash": "da93de9b25ba17325922835c0df8d1bd3783ebfe76e8e604b09d2484a7c20693"}, "fc0f6a60-0c1a-426f-9825-756c24a702d6": {"doc_hash": "19c92b39d474e3f04a46b3cf629cb7c6b29b1e8fd1df780436b675fabbf45ccb"}, "34e9dd64-72e7-40ba-8c05-70c869a1ce6c": {"doc_hash": "c741884c1b677c16db805f93c4013cca41d8c45713277de77c5912de879bcecf"}, "bed28dad-2521-4457-84de-5025f3aa9eec": {"doc_hash": "f204147ee36df6d8fff2cf193a21329303cd60aafa01324fe66fa72d0bf0bd6e"}, "746e8702-e1d2-462f-b68b-a2a580c798e2": {"doc_hash": "9be9d796151da1f450511a91da6c02c5766655e2b4044f4eaad4086b4cc49243"}, "c6c17ada-9385-4879-943c-0dc4cfab4a51": {"doc_hash": "9f0981505a9254655be5cfcb5c505d4c27037b3ae69043b0f0050edae5223f04"}, "838f266c-8f34-48d1-9a8a-9b66a0cf9807": {"doc_hash": "7c17838ab0186223114f8536d0464629f1c1df635ff43b976f0077bc58763274"}, "6a869f76-60de-41ad-88ed-b1c56945f82e": {"doc_hash": "b00ce22cc02034c1bfecff26ebb4537709286c76900947fc150b59092f822c8d"}, "26c61b21-edd2-45bc-9302-7081e47f61e4": {"doc_hash": "9b2574d4cdec28cd6eea7bc86e3409aea3490b3493f861f1e9dd576ce89a070e"}, "8a53a2ad-3546-4d7f-9e2b-f254537ebc76": {"doc_hash": "4855023ecb36b6e96ce1305286f7a45603c8da24433b38ef1ad5b19113400f4d"}, "4611c81c-c88f-440d-90c7-669b6d7d25df": {"doc_hash": "7cecc91dc02076e7846394a2bf44a7383d627aff4ffceedc340c3a0152c53bb3"}, "70df3869-c245-40bb-a93b-1c25436bae83": {"doc_hash": "2fc199e7c996636ed2511be3aad86917b278a83c1086976932ed6d773340eddb"}, "ff4d22b3-bf1c-4586-8d64-256ff1110ea5": {"doc_hash": "ea56ee3e8fe2accdce24347d3b612b8b9d7393bfa7e2b9dac0242a40d24ceab8"}, "f6d69a42-c29f-479a-817e-23f51227b364": {"doc_hash": "52c7ea90cc7cef7154f57dcb36719ebe8c1fb8df2f17eeeb1ad6a14bbd128abf"}, "30e7205f-3ac3-4711-b58f-811ffe6f0be0": {"doc_hash": "5a8c4fd995bcdfad33637c10b6748fa2aafac6b5e2b38dd4c67b5d52e8c98495"}, "0dd0c550-a44a-4b85-9edf-4593ea71542e": {"doc_hash": "eff23119b6cc04464b868f5bf9eebe89b1482e50d3553fcab6a4094aea1b6c71"}, "70658702-f82c-42d4-ad07-e53301c7e050": {"doc_hash": "84c27adfd47d6b30572ab2f20f44189f4de5b2267e478c4377c31cb305b74ffe"}, "5069b1f4-1d39-41c0-8e17-767d13722f84": {"doc_hash": "02f344b31decc71e666f2d7cb810f9690727189191ad270ea4b8f4f0dac4160c"}, "6858ba3d-159f-44ef-b661-651263c7e3b5": {"doc_hash": "245515ce175caffb4a332e38bc1e247e4b4f19bfd0260f75cfa40ef384396207"}, "7a739bd0-22f9-4e85-a4f9-0646e4800563": {"doc_hash": "8a7149d7920f5fe75ed7f2f16f93a95d750edcb3522b50be8a4d0275124b66f5"}, "e68fa4c5-c89a-414e-bb92-2820e59103a9": {"doc_hash": "71601779c06807860f409e6fb71f55c7a843ad2754b222aa4f35e963e6ae8da2"}, "dbeabe24-38d9-4ff1-8221-db3589a23fb3": {"doc_hash": "3435eece8fac210228db79b79d196cf98e619e06a9cb81b56dfb063f63b68a30"}, "b255843f-1d69-4fbe-a89f-d4fb76cfc6c3": {"doc_hash": "4e7d5d4ab44f181a9d5aa7ef7f20fdb1ae28e19016d2d95efdaa5e8e1670a257"}, "5342c86e-c4f6-4594-9a01-ecb17f9b248b": {"doc_hash": "115612a7613b80e379701d4b36071330853ce083584a2cf6a31d602081168547"}, "50788a88-2280-4b4e-b0d3-30e0cabc936c": {"doc_hash": "3d9aa71f77b4ef63cdb40777e0ae58fee5718e93d2634d9fdc77a4fe79f28dd4"}, "93db66c9-b14f-40ed-bcb4-cf5710d62d8f": {"doc_hash": "8ca851a00e0642a01eb2b0a1204d60a3b6b25245f9b22976753ccdbb7a72cf62"}, "4b52f1c5-74b9-4641-8048-2a73c819321d": {"doc_hash": "7c84d722047b238ad0ec19518063e6d27618153a0b02387507c3536843da9e79"}, "e931c90e-c109-435e-80f4-63f676108ddd": {"doc_hash": "4fcac2d4e2c15092a36e49cc27ac523de220b392a720ca6fc95f44f986021720"}, "141dfc70-0054-487b-ba69-abaa0c4c07bf": {"doc_hash": "f4ca76cbff206c9dd5ebbff50639952e64b74e19049f74c0f7fd4433bd060067"}, "6a1bd7c6-3f1c-40ef-8f7a-8ecb8a6d117e": {"doc_hash": "ed06526524ee77ca8858802597fe4e45a0c3f16816faa888f33c10340eb31ad2"}, "d7b2d760-9668-494a-8e8f-af6f7c53f00b": {"doc_hash": "dbd87a19865f10f58fd2a1a3c527f7df7ba133af1c9e9c75135417d2501ade6a"}, "bb094c39-8be6-40ed-9575-dfb2ca8e9cfb": {"doc_hash": "c342fd663507851858c584c85491be4a8a36d7edf99382043d05c55a94c204b0"}, "09bfd729-7e4c-4dc6-8c49-4e6bd9f34a97": {"doc_hash": "1d35b5e0f08679bf67029c6476a3228c5a24550b7e898255503bb6a12b8540eb"}, "796abaf7-a83b-4a50-8494-12b9a0b3f009": {"doc_hash": "cbf79c061f4210c8132c991e9d9526d36856d9691e7fa348e51445e6d6ba8fa0"}, "0a76efa1-c7ee-4930-99e2-6295784ad09e": {"doc_hash": "e7dc706de69993114be8953c758f9d052ad8e275d611ccf8199f54a0c8a26f9b"}, "5854b555-e73c-4661-ac22-519badc131ce": {"doc_hash": "7728eae40165a0bddac4c6180877bc43f1a98cb159338004691090057bf29833"}, "e9276e96-4fea-4383-a464-5876d3bcfa28": {"doc_hash": "6c89b6aab13b619305252d0ed54a3f777a5018e679d804b7375f7b7ae36aafb2"}, "3890bc5e-c149-4fab-8844-d6444f43e232": {"doc_hash": "d915a93bb5961fbca659629f8bdd3ab9ddb554ee60f3f0c39d8611f7b6cd3747"}, "0f4062a4-9e47-4ce5-82a8-7b871e60bea0": {"doc_hash": "69633c79aecfc4bf14f576704bc9e43bb0da6cf73cdf4d30e50384bc8cb9d50f"}, "2dff44f0-219e-48ff-9041-a33b8a37d2ee": {"doc_hash": "9c98bfa5db70b433c4a86a1012834b266b38a9f518722d0082962a58d621ab5b"}, "2b9f704a-3e4b-4d63-84e2-84310f2675b8": {"doc_hash": "f2f6cff2db2005785659a22bf782766132e58d165bffa071710676966b8dec82"}, "20cbb7c1-cc96-4ad3-8ff3-e25288a11f87": {"doc_hash": "240916a63e69e81240ca9c6098dc34f7980ad901e6985b9a9b47964a821b632a"}, "a610f46e-cbbf-4f5a-9b4e-9ee79ae31d36": {"doc_hash": "341cba8ddd98c6f4874478de69031508bb06e47322258556ef748c30b6327f52"}, "0307de24-6a4c-41cf-8b56-e1aea18f578c": {"doc_hash": "d792c298c56a42676c015c6c1ec833ea05209651052341e27f099eb460fac3c6"}, "cc6d33e0-1200-4bef-9303-05d032d40d90": {"doc_hash": "c03bfe9b09227a07cbde801288af58ada07e9146ca75cf0f7c17145c3ac3a7fe"}, "7395be4c-cb51-4d67-867a-6154e39a6151": {"doc_hash": "bb04ebbfb3351d07265a0f0a9890a8876fbedee8f21be43c6f929fdea5f3571f"}, "994b4c38-83a4-4c99-8386-b634332dbcfa": {"doc_hash": "b08d7418aeb750d06eeb36544478df340459cc0ee415cfcb5bd7f0085f185ea9"}, "0823693c-ea54-4e40-98f4-ee062c4d3b7c": {"doc_hash": "61984d667c292a4bc729181dde9ff426d76067dde7465b2952b778ebe292f947"}, "a11be51c-c7c1-4050-8bd8-ee8f478a7109": {"doc_hash": "68bed4aaebbb43576c1e6cd54dbb5085511a2268e591de74b553a836f249541e"}, "41e8389e-9056-4db3-aabc-7101af07b372": {"doc_hash": "796a01e752556b1d53016061a7121c6c3921bd28a0f79a687dabc24bbf92eccb"}, "488a1e20-70b7-442a-ba09-c1b234618e5e": {"doc_hash": "8d7af74be629dbae1a00e47d8898fcb9aaade9b29451483b626d8929e61f61e8"}, "9efe6404-82a3-4af7-8203-65ebb280dfd8": {"doc_hash": "b1c98710b29948800cb0d60b61ba10d9ef3efb7e49e218fef714655aa5e43539"}, "15c74424-8f12-4162-9180-6fbd21284850": {"doc_hash": "afacbcfe4416ea866e12ee38531455074ed0e57993f0ac49fb31d711c6e448fa"}, "35c4e781-aee3-4688-a2ea-2b75da09a5ce": {"doc_hash": "80821463854a482d03f832bfcbd18097fda092b29822bb8736ff9864da0094e5"}, "3323c86c-d8ea-4a1b-b619-905945b89771": {"doc_hash": "2fa0cfe91789c31b0c396004419950e6bf7498fec5652877c5ff92032d323884"}, "b7dcb9b2-58b4-438c-8f68-dc78c7846e5e": {"doc_hash": "a8738e489fd02c3e487e1bd0e1470516efcf3a3dc34d65e81fd336abcc5558b5"}, "529b6c59-00b2-49b2-8f78-9c6f8a599516": {"doc_hash": "9359471661eea66c04c8cb516df9e52665004e8835443901dd07a58d95e9cf93"}, "e6b9c5a7-76aa-4b07-bb00-182bb17f2260": {"doc_hash": "905ecae6091a9c6d8a59a86b5838576f97cf7b77b1849cbdff3e3ecc835a7fc2"}, "7ffe0d6e-0824-4b30-832e-da3aef08a3ff": {"doc_hash": "8e0f4937b0e3b614bc06ae824fe9fa35435c639b4b0704a469bbf4b59bac468a", "ref_doc_id": "b84895b9-6f90-4975-9e13-02044300f26a"}, "602d80fc-d4ab-40de-8af1-19ab3c85fc7a": {"doc_hash": "119614cddfc9beca753be91c1e8ed5d0244f94325e68f110bc8bcb839098289f", "ref_doc_id": "b84895b9-6f90-4975-9e13-02044300f26a"}, "871adc23-b7b6-43bd-9349-bb5c72464e91": {"doc_hash": "f61fe1fdcdad42761a20eff3e32cce61f8505569165bcab330fef0f068bbe97f", "ref_doc_id": "076fe90a-05da-43e4-88f6-01ba95c8d719"}, "0639d255-56c4-4ac2-978d-ac20e39c47c4": {"doc_hash": "719eef6fc41487c03ef1588f1f65de591ce3bce0b34cf0b8310776ddb137a0b7", "ref_doc_id": "076fe90a-05da-43e4-88f6-01ba95c8d719"}, "e99898fa-794f-44e5-b667-999a2b6f5431": {"doc_hash": "81430c967c20ea72148d8d1d5757ad02f632ed86b18e5b93c881d97f429cd945", "ref_doc_id": "1e5f4b71-4211-4934-bab2-20839a1eaf52"}, "31611764-f065-42ac-a804-c800eba90d2c": {"doc_hash": "632a82acf243034ecb56903b02b89e60776c045aa744e810ae6ac9067c92acb6", "ref_doc_id": "1e5f4b71-4211-4934-bab2-20839a1eaf52"}, "ec4aee05-21e3-4da7-b065-9af72dd1015a": {"doc_hash": "c4e8350027a6d509fe8a99bff013f2efc783d6c41e07c42e7f726dbe0a7801c9", "ref_doc_id": "02d81911-24f6-4111-acfd-138239bfe6e3"}, "b34259db-7339-46e8-b9da-91543f6072d2": {"doc_hash": "f74ba9770d01663d271f3c01e154553dc9b9e88357c802dcc65446ec7f2fbc10", "ref_doc_id": "02d81911-24f6-4111-acfd-138239bfe6e3"}, "1be1b294-05bf-4d25-9c53-20d2f2fc8be9": {"doc_hash": "d52235812c113972326849d12956ec76a73cfff60138aa116630648c96354feb", "ref_doc_id": "204eda0e-0a38-4f2a-af79-6c57b8fc0c05"}, "a29cc3f6-0465-40f9-be43-7041a2686f30": {"doc_hash": "3738c8077dd6942567870fb6ac81ee3a8d1b0500555faf204f2891598a12694c", "ref_doc_id": "68e2c518-050f-454a-936f-33033c6dc12e"}, "3def7a1b-a1ba-4680-b88c-fbb1f5904f8c": {"doc_hash": "02b338a27c5ebc88098054ad5adb4aa2de457485d83a8daaeaeaa14212c97833", "ref_doc_id": "68e2c518-050f-454a-936f-33033c6dc12e"}, "abf02d24-4bf5-4b83-8d89-d7ab8ec3b0b5": {"doc_hash": "f382f2838d584a71a11031f3d2b8819bc7d4016b0584468c0ccb95205026b4ce", "ref_doc_id": "ff580322-4bf2-4ffa-a4ed-0582ce3217dc"}, "e6dfc4ae-972a-428b-9698-0a633e459fb2": {"doc_hash": "763697a7791b00126cdbb2322b3d84e57c8c8b8eb0e40d3e6dbce2004c9fa1df", "ref_doc_id": "ff580322-4bf2-4ffa-a4ed-0582ce3217dc"}, "255b23a2-8409-40e0-a8d8-92d7af6ae648": {"doc_hash": "83d64786c5e9d239b01c74c2fab33d9de3550101f47ebfba21bcf34a091c61df", "ref_doc_id": "30a9c6cc-73d7-4486-ac5c-b40e3bb0fb27"}, "f50705fa-7fd9-48f3-98b5-9922a51ea0a3": {"doc_hash": "9e69db9a6bfbad2fdd8a5716b6c7fa8c1ce9e20417a85244e087d1242cc1e584", "ref_doc_id": "30a9c6cc-73d7-4486-ac5c-b40e3bb0fb27"}, "107517f8-a175-49df-ae13-599e0bb0042b": {"doc_hash": "77ebcf08a689e22618416df0c905c99582dc0d3e72901e864c9f075b7864b06e", "ref_doc_id": "d1257edc-1b8b-4a4b-b71d-bebccabaf357"}, "67b0b59c-100a-401d-adde-5cea369ef8e9": {"doc_hash": "db4645a23b052c7074043acfbcbd8ddf862e7ad09507527658125db5d1df6f25", "ref_doc_id": "7e02a3b6-4f11-44dd-a46b-65153f2a6615"}, "36025681-6282-4404-986c-d44c342f6fd5": {"doc_hash": "a0c6bc5517fe54c83d56b1a0dce6164c414b8c16d37e0390a90e1926b9b8cc0a", "ref_doc_id": "293289f5-cef4-443c-9aa6-90a0d2625f2f"}, "20933971-29cf-4e40-9766-49e8887c5d1e": {"doc_hash": "d6bd7fff2798bf98aff544aa2ed91a4b69fec849b4e1dccc98e35dce97cc7187", "ref_doc_id": "6904ae89-36c0-4f9f-9605-365747dac5e7"}, "ba695c7f-4ddc-4985-9879-f9b95762ec03": {"doc_hash": "f46f147af020821256d7abe5536a3e720b91272c28d3b126eb09ccb7d31747c4", "ref_doc_id": "8bb66c66-9021-4ce4-9279-3dd0432ac1e8"}, "ca46a54f-b287-40b1-a9a4-d6a97cf0c7b7": {"doc_hash": "e896acf5a5ffbf3aeef253e968593f521556633041f72f6777070a394ff4b809", "ref_doc_id": "f4218aa6-08f5-43d9-9655-9b58a33d2068"}, "613bca0a-5ba4-4ea6-ad43-429dcba5b7fe": {"doc_hash": "4176c23785da6f5aec3503127b704c199f3991cbce0608be081ce3395e23f49d", "ref_doc_id": "20abee10-fba9-42c1-b65f-817e871648f4"}, "baf1e610-4526-47c7-af7c-7f7583751f68": {"doc_hash": "2a85f4d42bb9990b4c973afdf9855e91718637b0503cd94a5cdf64721c13e778", "ref_doc_id": "bf24c37a-3f3b-48c0-8447-dc2e38a19f71"}, "701b5773-47a3-4803-997e-8ee5607583d6": {"doc_hash": "67b10cdf00c4c7c1862ff2060ff01b552c8c554bd4d884e4a5fa85ddc955abe2", "ref_doc_id": "c85c5020-e0f2-4b45-853b-87085be3569f"}, "904efe8a-f578-46df-b7b6-bcdd06262bd1": {"doc_hash": "a109fa6d169a28e71cf92a7ac6bcd736eb3a37461bc4b455d1d0d9e7396c791e", "ref_doc_id": "392b824c-3e31-457b-9b2d-33c0dae061e4"}, "133a796b-9c78-400f-8fd2-9f77f85a80b8": {"doc_hash": "961d61e0d19057f87131f78e8fc23053844c2f5651bac76e75956a68cb30b9d8", "ref_doc_id": "e170daba-74a2-497a-bdd7-4da84ff21e8e"}, "94585289-8d07-470e-9b71-82e1b4024687": {"doc_hash": "0eda29c3ef70055e20ea63ddeb034ba994811c6fbc22fbe61b08cbc337e9933d", "ref_doc_id": "fc825bf2-ed57-4898-b758-79f8e272eaa2"}, "5a30a69b-a419-4a73-8dfa-1e3d97ebc0c6": {"doc_hash": "9766426f4f7e569a79fed855e09d05795bfce1c38fee33f3c50a304e46df5360", "ref_doc_id": "e44e1708-fa1a-4e97-be98-7f43f4eb361a"}, "ed70dfde-19d6-46a5-9891-a329c02f9af2": {"doc_hash": "0ba660c19815ca7663b6985ebb1b544b085e20f0a51dcb4b7210d811062fd6f3", "ref_doc_id": "8cccc794-d1e2-47e7-b770-1956fab8942a"}, "98ebb1c2-1437-4045-a5ca-44740f952a03": {"doc_hash": "d0112c20de93b7b90d9d5bb627eacb129618ef2457da8405908012b2735d8b5f", "ref_doc_id": "d0d481c5-a8a6-40cd-bd59-ab47cb6de26d"}, "16cd6dd9-e80e-48c1-a0fd-6ff5ee351566": {"doc_hash": "7777544f6d491969e34ce524e9ee84304863e99853a6617b97bdfa1783e12b3d", "ref_doc_id": "cea8dda1-dd4d-4a41-900a-409eb619daa0"}, "8e25f32d-7f79-4ea7-8201-cb13362f4a16": {"doc_hash": "56b56803564246495603f7774fdc96fc168dbfd48986bf57534373251000f83c", "ref_doc_id": "90e4869f-66ca-400a-9179-f09ca6b1ed8f"}, "1d70d226-442c-4872-a50f-ac778cf1e0b5": {"doc_hash": "a93955047bf663703a420fd4ec9ebfd8c3618e921433d99be3bee6fbaa4e0870", "ref_doc_id": "051b9327-424d-4380-8850-65707eab7580"}, "aab0b21c-710d-4cda-99d3-b3b6a11b4909": {"doc_hash": "fc076b7415bd678c3841e53d9db4cd8f1cbe46c9fa0ec721c7b130fa90a61375", "ref_doc_id": "56da1b7e-55cd-4559-9cfc-a341588f3709"}, "0c9ce1c2-f8b0-4fa6-b153-6e513510d2c3": {"doc_hash": "981da02b1cfe075891042092731a0216f9b078ee04f85c978c535632b46743b0", "ref_doc_id": "41aae94c-6c33-4f89-bfdc-17bef1b1b595"}, "5495b377-23fa-4910-81ed-50fa61522076": {"doc_hash": "3aec107663c240860dc9fa8d1cb0ec09dd6698a2c0091851d545fab9c4294e8e", "ref_doc_id": "9dc87bfc-33c2-4cc5-971c-132f9941654e"}, "159c69a2-b9fc-476c-a5d3-059981abd0af": {"doc_hash": "0a61b89d7403c60cff4274ee9df0a1b252002d550aaceed4295d114d2256d813", "ref_doc_id": "fb61839b-72af-415e-9157-612f7318e55c"}, "7646e76e-84f5-4902-afab-a184a50ae987": {"doc_hash": "e7fcbd93aa44b028478bca9c4c208bf95159e5ccc01de99d0082ef8503c0cab4", "ref_doc_id": "89ee9942-c3b9-4bf0-aab6-bd9db6ca16f1"}, "159936ab-de8f-4392-b3ed-fafd84c95604": {"doc_hash": "86993d18bcf5d28921a8a67aa5f05399f7899668a5d92b533f1bd5c5b24f08b0", "ref_doc_id": "bdb69170-6db0-4358-a368-82df7cef9c8d"}, "58a26b75-12a1-4b2a-b489-851d81976092": {"doc_hash": "1ade28ce3d8b83d229e546dfc7113081e71ad70801844979834f25e14b771d7d", "ref_doc_id": "b5eaaec0-c9a6-452a-908d-46dc7e67609c"}, "cce19518-909c-4615-86ed-9ad1fafb3b38": {"doc_hash": "ad286c837e051d1139466c5e9e51e14f069472f5a71da36ae731205af3f852fb", "ref_doc_id": "74b3311b-bd41-4da3-914f-f741221735f1"}, "bb65157b-db10-4def-9b5d-20e3ccf9ab8b": {"doc_hash": "c2cf3bf136272ad3e734f730046c98a12e59c9ba13123beff53cf87e21cc45e7", "ref_doc_id": "d50d414c-102e-4555-8c3c-def649484c91"}, "7d93967a-a2cb-497b-a84a-2ebe92ac5c92": {"doc_hash": "7c449da9d0cedbecbdb787b93ade6b574a94a5722be467a37cbe1c13927ab1c3", "ref_doc_id": "700879ea-fa69-47f0-a484-f59e5a33222a"}, "ab81c9ac-97ca-4608-9176-b482eb3485a1": {"doc_hash": "4b3e9d46dc3546232dfcb86f91c1af199e4ea6a8888f2ca384ef11b6f437e30c", "ref_doc_id": "6419b92c-682e-456d-8f81-e870e89e41d1"}, "85c8f08f-1796-408c-9fc5-a42cd02b5677": {"doc_hash": "520f856b80a709b7374c2aede302b57fb276fd5eff01ed9924ebd9d59cf04cb3", "ref_doc_id": "74543c26-6735-4e29-8b30-0c83c37e4eb2"}, "e7f6602a-36f9-4d3c-b3a3-214944fb8b47": {"doc_hash": "ffe10ca3770f1cd67ced46be2cb865cbee879bd8fb2f0d94c11a4130867657e3", "ref_doc_id": "9accf485-e076-4427-b5dd-3e83b1de851d"}, "f134613a-31f9-4792-bc53-f43f8ababd02": {"doc_hash": "b2725fd27c85acfc1278e6278026296016dd5ed8cdf2a6270620f70e33139ae8", "ref_doc_id": "5e041b9d-da2b-4ae4-8f23-df603251e755"}, "3a0fd6f6-592c-478b-8aee-05e83cb5a9a1": {"doc_hash": "8ec21525f854c9f15eb3f76eed5d60c9d66849f8c4a5cb3f95d929d0ddc52a7e", "ref_doc_id": "ce5260da-9638-4b8f-bac7-54c602e4fca5"}, "8aabe95a-727c-476b-b1d9-11b453d6aebf": {"doc_hash": "b35b83337ba93ddaca3106be4300344406df202ff8ff1a38512fa5c7e43bc165", "ref_doc_id": "80178348-8193-4427-95fd-ca2042100e79"}, "86cba470-f618-4f30-a537-5863665cef42": {"doc_hash": "9ad4fafc92e98a8884e8225253a9ca8050b2b494ae947bcf47d02a117dc4e14b", "ref_doc_id": "3d5517b7-faaa-4fbe-a09a-34657858603b"}, "f13ecdb8-eb87-4115-ad66-1bfe6e1773cc": {"doc_hash": "3b7be1a289f5e8d64e8d3b7ce937c4016cb41065955d3a0ad4d17951b172686a", "ref_doc_id": "3a491e0e-6d33-4494-ad06-2bfff5d0225c"}, "22a32777-ac96-431e-89f3-091b1719ad3f": {"doc_hash": "d09c8d2d6cb148cc30e2961a1efba91a8272596c9b3f34fc5811125cae7a1610", "ref_doc_id": "557a1ac1-ce42-4e6a-8ad2-ecaaa091f7e2"}, "d49455ae-54e6-47ed-9c98-e9bfcc4c7ac3": {"doc_hash": "c9b15419e92efbfc7ef03af1f239aeb807ec06912963ff1b2003971f15cd5f2e", "ref_doc_id": "6826ac6f-6e81-4ec2-bd50-887e6c471ed1"}, "198938e6-a1d5-4518-97d0-04d279484e7c": {"doc_hash": "1ffd7b37b2d77f3d2dd79229f8c71500b7f471de87f5a0cb9bfa16c1ab818d23", "ref_doc_id": "2dfb7df0-30d9-4b21-8bb7-1583c22c6b07"}, "70166911-5fb1-4a1a-8485-1994a475961d": {"doc_hash": "eda086356ffaf40e8d86813bfc192d6e1d807ef9f1de71b62f1640c0c36bb90c", "ref_doc_id": "6d7bc0af-6401-4680-abe9-1f944917c234"}, "aa059345-ec07-4762-a581-5d4022738b80": {"doc_hash": "9ca3adfa57b10ebbf26190358c241fd4e8be9482acd9dcf1fab8b6fd5e06ad11", "ref_doc_id": "7eb43954-0af3-4d23-8ced-7f4543102e31"}, "ec73a79f-fc30-4c41-86a1-4cf887ba31e7": {"doc_hash": "e6215f2b5de39b979ccaaddb9bcd5fcce12504daed69dc0d345d56b44851f7de", "ref_doc_id": "6c94dc17-010b-497e-894d-4758e39d23ab"}, "eec79c67-3ef0-48b1-a83e-192d1d91e2a1": {"doc_hash": "e097c9f72e584bcd3ff9584c76d7a72a4df76c9f25c31453bd15a7972946eadd", "ref_doc_id": "c9a5f1d4-7d47-4b7f-a050-d0384b21fe31"}, "b9eb5cb3-d221-4222-8259-c4541015fa82": {"doc_hash": "cac4ece328ff56ec3be0db9e6ff095715261b17cd7bc514ec5ed99a9c4ec9aed", "ref_doc_id": "af70ebff-f208-4650-b5c8-eaead32a44a0"}, "9bcc5764-5a2f-4c6f-84e0-02c9190072d4": {"doc_hash": "9deff96df7d3fa71e51d51b91a38de51c4e3570df7eaf030dfcafa2b2c343bb7", "ref_doc_id": "2571ee34-738c-43d4-a92e-f6d7b66148ec"}, "051e0217-b9b0-4bef-a2a6-c69d32ccb9b8": {"doc_hash": "8e92d101a5472ea21884f1ad6a8aed7b74188d1e174e71380254c93f95115e7f", "ref_doc_id": "236806b3-e949-4f50-8f30-10ace87c0a7c"}, "b79dabd0-8a1a-40e6-b12e-53bcd781eabe": {"doc_hash": "ed182396a27460ea6389e9d78f830b238358311e0ba5d3a9ac5763070a562e58", "ref_doc_id": "e02d000e-5d4f-4162-9018-dc239e5a201a"}, "78307ee3-ffae-40db-a952-c140c264a4bf": {"doc_hash": "4b49b987280f678e3511c874c9ab1a5e3dc58790d1d6de3bf9c41437dfe76f1e", "ref_doc_id": "5022be93-401a-42ea-9d11-5c29572f28e4"}, "17b96e04-09d3-48c3-b94a-680085856207": {"doc_hash": "39fd510b1f4d8811e71f9f16ebdce41bf9e02b6311b0d3955f1877ec70ddb360", "ref_doc_id": "ef37abf2-926d-4796-803a-3155467dd223"}, "a9be4e21-a963-44bc-bf13-07bf8d8cbe82": {"doc_hash": "8a87c475619750360f11c567c76e828fa0f07e2f3f6a54cf87790afbd1a7397f", "ref_doc_id": "9917ef51-320a-4cd9-898b-94b7f904bac8"}, "e5ba8d10-6a04-4fcb-91b6-5435cd292e1c": {"doc_hash": "5a76c27cc63544b89ab04cfa80b9029453ec4ab64ada052d72f9a8f6cc78a6d1", "ref_doc_id": "1cd9b5f2-c02d-476a-bbec-b7eaac8b2cf7"}, "fa29066c-8cca-4828-896e-313c50e4d4d0": {"doc_hash": "df05123c73d662eba617e07b99f5bd634ec2c7769c10f5ddaac8ccfe89dfc6a9", "ref_doc_id": "090ddc9c-e65e-406e-9e27-792be73779ce"}, "11fe3572-3869-4e39-bc45-5af527a859c7": {"doc_hash": "9e3c27fc9b63052339538b83b4c9419ccb8de621faed650cb93b0a6c15d2f734", "ref_doc_id": "c7893d4a-0f97-46ab-9641-3d0473554ff1"}, "8da9ddc3-b1d6-467f-8822-f60301ea3cfc": {"doc_hash": "d07cd859526e7c5ae81dc3d0d1d6b94cc66623aaaf067c48022d75dda2e324d5", "ref_doc_id": "ddd96ceb-6a08-43ac-a3d6-5569bbb8dde6"}, "d31821ef-d476-4626-a7d1-d616530d5049": {"doc_hash": "95c4261a5054b303d257d59cb7e6e3e96d9182eee3667489eacedc182557abd7", "ref_doc_id": "f3399d71-ee43-4a02-b705-e9b6e70b5627"}, "4320f7dd-1184-4e8e-8a31-446eacc8d6ec": {"doc_hash": "a1a86a75782d39052e3eb3a041db33e4c4391688a0f4e9fcdabbabf3c2c27d3e", "ref_doc_id": "1fedf418-8bae-4881-a258-779292d1fa46"}, "7c018814-41ae-4a24-9559-c80116b6ff84": {"doc_hash": "8bdf2b959a168b1857f37eecc010487ab4699860775162c00ed068159623b404", "ref_doc_id": "a197d6ef-9836-4481-9a8d-ebf806025f07"}, "b706542c-36ab-43f3-812a-09f1d5a835b9": {"doc_hash": "dcb4b1f2c6bacb6b4f2beb5db7d2b8fb9b220ebed3857af5fbba1cf1b1ba5161", "ref_doc_id": "ee128075-15b9-4494-95e8-69f842e66b19"}, "37a5ee0a-30ae-4d0a-b0c1-5a93c879697b": {"doc_hash": "f5a26f585ab7559d3b5ee75fd212f6c5248e885c6d3db6c616643448ac67bf5a", "ref_doc_id": "4647b4cd-37af-4431-a3ae-504c2dcf74d2"}, "6272fc67-9183-4bdd-885f-bf81d36db1dd": {"doc_hash": "467c21505f76d2cdff4cef25d09cf92f3ce92ec5800fd32a7c3fa23a32a0582e", "ref_doc_id": "6a0ca485-6c93-417d-9da3-b62a23fe1ccc"}, "32c494f2-1d06-443a-b591-1e00106114ed": {"doc_hash": "3d82998afb325348af74d421c4873578675802a1c48115cb5fb942f002b5283f", "ref_doc_id": "0e23cc10-5021-46b0-801a-841b98e1733f"}, "0785ae11-f7f6-42b8-b245-498d3b95ba5c": {"doc_hash": "fca844f0f9f92bf72f3112ab8d277d523f0c70c9a4736fbe4ff9cc433a50ded9", "ref_doc_id": "aa7beeae-4f91-4376-8787-d80a21562319"}, "ee7efc66-d099-4091-900c-e2da76cfb457": {"doc_hash": "d1480030ca7b6b6312ecd5b66ce6e13385640f4e6289024a10c1d23c95eb860f", "ref_doc_id": "e563227a-515b-4e2f-b835-c1c6954d38ee"}, "439b4c0b-582d-41e6-b379-c1af78a8c972": {"doc_hash": "610b681db6f9eb90f9f52728eb893bca331aa8f46a57a7e68994d315ab8062fb", "ref_doc_id": "dcfc93af-a56b-4019-b44f-4272b9291044"}, "abdd009c-0e6c-461f-ae95-d339a599785e": {"doc_hash": "adf5cf466cccb1fd13db83a8d47b587e44d4d741ba2acac8975caf70d0e6d35d", "ref_doc_id": "f509fb39-5993-4e40-9a4b-bdf976e45be8"}, "92eb5feb-8e27-44e0-a601-01afa9af26c2": {"doc_hash": "be2987ca2faa2e9a39c71f31a992b365387937e9055ff2eb28f6b5172d1e47e8", "ref_doc_id": "c5c69c69-713b-4a2b-a855-e620b2469bf2"}, "fe12dcef-2f2d-4e5e-9c9c-a01a8640374a": {"doc_hash": "a5e821691aded1cd4443971050725dbc9b0237d3c8159450be16db11c0cc7951", "ref_doc_id": "21b93e6b-daab-4c30-83ea-d7c09466d58d"}, "2483e054-85d1-4f30-8b1e-7f1b7e8800f0": {"doc_hash": "d4b0fccc049418fceb3d3334a886a9e9554acb352847d1cc24d4783fe6fceb8f", "ref_doc_id": "44bc7c3b-6672-4636-954d-d24b9d933841"}, "b2791746-967c-4734-9013-5c6e7de5489a": {"doc_hash": "17b05bdffc8b57f87d38b12dc6c527ee8a75410f8c2b9cc6056d559b96284ec4", "ref_doc_id": "56f9e0ba-4f3e-4fdc-8829-7ab05a87e493"}, "077bf166-95b1-41fb-a0bb-bc780e2a82d2": {"doc_hash": "7bd21865659215c5ad089dd8c9e63e2a7c4fa5dd2d06ed5908c2a3a213ce03c6", "ref_doc_id": "17ed935a-f655-433e-b0f0-3585bcaf87b9"}, "3595dc72-3215-4622-9525-d56a5b947943": {"doc_hash": "fa96d4b005bdbd514a82d41ff5c3fd708785006883ad473dc5e0a0b580655a4e", "ref_doc_id": "da86aa0a-3ee6-428e-a336-5f70c0681132"}, "7a70b554-eff8-4b0e-a35a-973f0f518200": {"doc_hash": "cd0454924f9de1592c025daae707491ccfc7cc8b56d455d6612a26d1416172ca", "ref_doc_id": "a8896d80-cf5a-4214-8f05-e7ea877dee95"}, "27ccb3ba-c898-472c-81bd-bf9b6c874136": {"doc_hash": "40ca2870631f1cc42ca0f091d5ccb89d0da2ca5002c8cd30783fda5b527b7cb9", "ref_doc_id": "cecf2247-2f43-4d26-ac26-c05c35d78ea2"}, "997915f9-7a8d-4ba0-af4b-4cebcfbd3761": {"doc_hash": "ef9b28ee9c053819c7eb1019194dee5fb5574d6445312210e6f16471e20e02a0", "ref_doc_id": "5b5be961-b8de-4475-88d8-022399d68eb5"}, "98cc8976-1db4-4043-b48b-1cc68787f71f": {"doc_hash": "5b80da5361aa08021ed3c9c6738a58f6ca54b5aac0638aba9fecaf673e403958", "ref_doc_id": "bf708e73-028f-4fa9-8a5e-47cf94aa6ba2"}, "7573d4c1-dbf8-4501-a402-00ed0c4b9d81": {"doc_hash": "6c7d0a0a1db5eaee3c08128dca421e931312a80b5e35e0434299f046fb8d8162", "ref_doc_id": "114632de-9b30-46f5-a3a7-bcee359ddf7d"}, "5dd9444e-cfd6-430b-8dab-aec1786e1b96": {"doc_hash": "c5dfc1d8f3c513f63c82f626cd9187fe6d91fd2c3cd7975de0159cb6106f5807", "ref_doc_id": "8c106819-d756-47f1-874c-d6e955242785"}, "92efb306-b55e-4564-915e-855359719d79": {"doc_hash": "0469889cf72f367d84e5b879514d6d7b52da8d60be0c30c33499227827ba9543", "ref_doc_id": "cb95103d-b41b-43b0-956a-dac43d64fb70"}, "6b7be912-5f70-43d4-93dc-64134f580a58": {"doc_hash": "6c170792aecd5301ec4f0498154a4763f1dd182321ee59d4e42d234e07801204", "ref_doc_id": "2c1ceec5-b0c6-4b1e-9617-bba50e0170cc"}, "3da0cb07-530b-485e-a8d5-26cd10e10ab6": {"doc_hash": "543bd931fdf440c232939a8da3831003448409c670f0100195a1b2baa4454ab7", "ref_doc_id": "26830022-9ff3-4fb0-81b0-d4b5c9e5321d"}, "08e1120f-d6ea-4191-a07f-8ff0ef4cdbe6": {"doc_hash": "4cae3abed3db71872592c376f00a799b00427b29b72d2a043ccd120bbf4d1d43", "ref_doc_id": "3e17fed6-e802-4f8a-bad3-1cb66691e67a"}, "85a6f611-f1ee-417f-85de-a755354d345b": {"doc_hash": "39dae1653f942722aec0ceb2b5d3a3ef8c4eb9378ffd4a39f4d50b2d4fd07c3d", "ref_doc_id": "e45f51b1-2a7a-481f-8ccb-d153a9213491"}, "a8a43c0a-47e6-4012-821c-0114c37bfea3": {"doc_hash": "98819ddcf77877cd8c94da7658fb767e8562e2bef12b6fc9feff8fca12db0534", "ref_doc_id": "9167fb89-433d-4762-b746-a232f845d992"}, "62a5874a-6ceb-43f9-b621-def05f21946c": {"doc_hash": "c2cec5f004a3d0619c0f6793187ac4a584935b943c79945f81efb9e9f2374209", "ref_doc_id": "b9f290f9-4b77-48cd-9335-619aa436cb73"}, "11deeedb-f29f-40f1-9531-f6c19befbbf1": {"doc_hash": "b825e31f0b587e9766a28108bda83fd0a90a1756f8fb2c68b5b9aa8ea90d54cf", "ref_doc_id": "ccafac37-112b-4763-ae18-85c43f5567c5"}, "cc00db61-2db4-427b-8e61-92d5b584569b": {"doc_hash": "782ff055b2560afd1c0815546d95ea4cea4b5dca36866c2d9b3e67604d3f3dfc", "ref_doc_id": "6aa6ddc9-85ac-44b3-a5dc-b737e01d9b70"}, "9c16a282-639e-4e96-b176-a17801c93a63": {"doc_hash": "9e08b541712e49951970aa6a5f86c8a7237fbc1e98c817b330eadf7b0a0a558a", "ref_doc_id": "14239045-30eb-4dd9-91fb-11aab4a3ef27"}, "6081f2ff-0462-4966-94f1-df044ebbc5e3": {"doc_hash": "39c5b21e1a84ef2032c510098fabeb7cf051d700949b3bb6394269ee9d695d3e", "ref_doc_id": "4608da6f-0ad0-4231-b0cd-ece358a687a7"}, "677abf42-8c04-43a2-a067-b91398340fbf": {"doc_hash": "4ab278889aa6acbc66a4536648dd0455fbae83fd6be5d5d8910e47f23202da03", "ref_doc_id": "39fb1508-64b5-4849-acaf-f6ce430c6596"}, "517b13be-a40b-463d-b372-beafafc4785b": {"doc_hash": "89e9a43c5f6b2e7e55b9cbc5426119ebb5581bd7ce9d0a635c1d122fb7f5d71d", "ref_doc_id": "87d52158-91ec-4e54-973d-dc499b24f210"}, "2cee24e0-f557-49f0-8e0d-222488c4d97f": {"doc_hash": "cfbba4a6a6c31b838bf85a1482172061a1578c5168de41c455d35e8709183fee", "ref_doc_id": "bafc3091-f305-47af-b0ba-b563498e9bd6"}, "3f65437e-847d-418f-b885-985f2f79e4ca": {"doc_hash": "2b932ac2c4a9bac3fcc8455d9141a59b30e112fab2d00cb9423457b82babd195", "ref_doc_id": "efc2fe1b-45fd-4c10-be41-7bf03b69e1c1"}, "7c6e9c89-adf4-44b5-ab4e-9932ccc80279": {"doc_hash": "e15e32899a2247724f269b6d9ac1ae1bc625f0b40a834a9c7c64199c88c01768", "ref_doc_id": "3346a9d4-3cfa-40ed-8052-4befab2915e3"}, "9ce697af-9d98-4b9a-a043-c0f6adaf317d": {"doc_hash": "37fe8304b79e07808ec452e7baa8e6c1dfac00a039641de8c024c0f0b5aa2cfd", "ref_doc_id": "e540e024-a838-4dd0-ad68-5a7d5e927088"}, "3bca96f8-8999-4b64-b966-d601cbf71c2a": {"doc_hash": "88f6667ff26add92c3f2d60f6112c33a4fdbf9164c46fc4f00ef443461e93ba3", "ref_doc_id": "2b553800-957d-4f68-94d7-bca9a054fdd0"}, "9b3d6fc4-bc67-4a19-902e-056eb533ea4b": {"doc_hash": "b5ea873716757a4c775a695372fc39f10fbc5edc0f5f33dfb6978462771ec493", "ref_doc_id": "7f401720-59ec-4d44-8364-f6df8a5c8649"}, "b11b705e-67e0-4446-b138-32a7d1874a21": {"doc_hash": "a33d2e2aa116bb4bd2c6427f63470716c8323c43aff2043fe2f39c9972879148", "ref_doc_id": "15d15e79-4fe0-4306-b06d-f32c3bb1ae3e"}, "85188aa8-3974-4dee-b1d0-e640d3752bad": {"doc_hash": "8f2913788dad18e650f22a935b2629410e6f766a5ad2dacfa007dabcb1346ecb", "ref_doc_id": "bc4bbee5-e8db-4b52-b29a-da25a6faca46"}, "924233a9-09c8-4c10-a28f-83324d8108f2": {"doc_hash": "7d84e112ccdc2662ea0f5944462047ee08178974f764018d0b33e4acfa5d14d9", "ref_doc_id": "e1d8cf19-4dd6-4682-8e28-520b502de329"}, "d99a8b89-e12f-415e-b511-c8eadefb0648": {"doc_hash": "6e95b0bfce5912ed9f9b0842e6ba670456b21e152abe3427e602615adc81580a", "ref_doc_id": "0ce00458-a9fb-40d3-a306-0ef1d34190ef"}, "d7be4361-5548-467c-9aee-922c8c01c2a1": {"doc_hash": "d7b666079bb7aa5a03dde599511a4e66058a586bf96409ff05863d79b6bff298", "ref_doc_id": "3a1856b2-b6b6-4205-bf0d-852eca18c0ad"}, "a1e91f87-2783-4dca-8e4d-d1a98c8eb242": {"doc_hash": "d9b6f71e113a0c6405b6583042234906e0d226594967fa07b4cf95e0fb605520", "ref_doc_id": "457c1c42-ade1-4b82-845e-44e59115c28d"}, "477b8e43-e6d0-40ed-90ff-670b5fc7e925": {"doc_hash": "4b0e99bc3dd301812efe22abfb0b3937bb1b6a7466325f06bdc23a8f599c6395", "ref_doc_id": "03bae95b-083b-4d2b-bafc-b1573ea5a6c5"}, "acdbfbc5-0267-47d6-92c4-059695bffda1": {"doc_hash": "7d1e01ac7562bb0152862bcdd20a85531abb05642c89dafb11518382f194afd6", "ref_doc_id": "8f662ad1-2c47-4939-a066-f72699dc706e"}, "0df18f33-aa85-4ca0-8bd7-743969d8d807": {"doc_hash": "6837f13c881309757d4b147ffb7aa6ef410a263cde84ea9ea44ac3522f416cb2", "ref_doc_id": "5d0d79f9-8443-4827-a00f-d877c124c94a"}, "d403fd87-cd04-41a4-91f8-3033ce0a9bdf": {"doc_hash": "c69366b808002d481d531944b1130e75746039677922753aac1c2d33f7332c9f", "ref_doc_id": "80184271-f926-4a49-86d5-97be07677f66"}, "016ab5cf-685e-4bc6-80b2-4389ecf03535": {"doc_hash": "4ac3e37595cb2a2d0f3331de67783472a6738c414079a84b729e4e70bb639a05", "ref_doc_id": "c775a736-baf5-4116-bdba-5968271262e9"}, "c27b2e73-8b3f-409b-b2e4-9fcbf5122bb7": {"doc_hash": "fc7a412449bfe358404d290467a9222225cd02f21a456e00da34718f12ea126a", "ref_doc_id": "eca13ed7-1787-46fc-8d41-2a1f8ece1ae7"}, "848c723b-1c70-42c3-b6bd-eaae13ae0ea9": {"doc_hash": "4c6d636c04b9a384e60b9f153734968b9994a3aaaf2f72194570f699a8714501", "ref_doc_id": "6904bba4-c48a-4801-885a-a32484b981fe"}, "dad43463-3492-4dd7-b83e-eef46b9b33e2": {"doc_hash": "b4be424e712d1ed25a62b4e6a68a7f679fa4fcf5af62d5e6355573970e56b14c", "ref_doc_id": "38151ae5-019f-4f99-b324-7df5ed92b5c9"}, "66e3258b-1d3c-43b7-b577-dafe91bfbd63": {"doc_hash": "b2909bd8c1a20682bde38161920938a2955c53eb0208fd5369c7d7affe16ebbd", "ref_doc_id": "971d8269-c87e-4c17-a49d-fcc3deea8074"}, "c5959a23-2d6c-4417-87db-d43ac7f8f559": {"doc_hash": "c8a0e4f9dd9a1fc68aeef5a8c11f3b92ae851c51f5294ef50a5c289732fead82", "ref_doc_id": "7c24d009-5108-42f1-9092-ced92f6f122a"}, "ce41bafc-e1af-4f03-b452-f0a8d1c0df26": {"doc_hash": "fa276b964757ddc4dc1a6f7b541a70f0db7919785f2b3fe19db9f745b3477db0", "ref_doc_id": "7c24d009-5108-42f1-9092-ced92f6f122a"}, "9133e626-bf32-45f9-9076-2e3607725f55": {"doc_hash": "97d442426be78295bd5dbb7f7bb12f760eac19e04dfc4bbb05b3ebe77805fafe", "ref_doc_id": "a581ae2a-654b-4cb6-9aad-64526a04f76a"}, "62198fb0-1d6b-443a-b60e-739d738233c2": {"doc_hash": "c148c126de2f34d1ba91e147cfd3b13b587c7d9099b93959bb0fbb5343edf703", "ref_doc_id": "0276b75e-f3d1-49ee-b4fc-236aa4d0de82"}, "93a8ecff-c04f-4c40-ae4a-68e4ee49e9bd": {"doc_hash": "b34ae9901a295522e4d522de021d093267e114f4f7aae50634f595432aeae8ed", "ref_doc_id": "04c8efb9-91db-4be8-8990-c5905fe3b4f3"}, "3a1a71ec-69c4-4542-b32b-2a0ffad7b137": {"doc_hash": "63ef58d0b8e10a32ef89b5a4d1165f9f930173f668e2ce0126cdc3e5f3fcb225", "ref_doc_id": "fe6ba256-f571-4f60-a6d6-2f5d76fbc4f2"}, "1286b271-f7c6-4594-8619-f120cfe391cf": {"doc_hash": "9f5cc19dadf67c1752b0b481b57d22bec4170759270081db0ea590e338bb3c14", "ref_doc_id": "8fdd045c-b452-4d92-91bf-9b299c248a24"}, "dab7fc72-61d6-4d47-a6fb-8bafcf9c4747": {"doc_hash": "7e7887ae81dc3d9bd94a0ec7e699184e21eb5ff683b1cea02d381416a7dc6b71", "ref_doc_id": "234721b9-6b02-4866-8e80-213ba2c1459b"}, "b15f9cb3-4e37-4d07-95f0-d8165dde5203": {"doc_hash": "4159e719764373e859cb1d8eb5f7fb3fa77847f85429476bfd4e7bac5be72ad7", "ref_doc_id": "0ba40b67-ae26-4674-9e9a-acb2a56f3394"}, "29485d82-043c-42f7-bf1b-5c093797ca72": {"doc_hash": "06f1f96476c364c5c4b5db16dabe2baf56fa3df9aaa0170b64d5a6a72933dcb9", "ref_doc_id": "d02311e9-d5bd-4e06-b784-322e73f26c57"}, "9160406c-4317-42de-83bd-b02c29f09cce": {"doc_hash": "09ae936fa9ecc680156c511a72b2c0bac6dc4637f30d2f5af99c10497f5b323a", "ref_doc_id": "785d8154-8807-44df-9dd6-af769b07f0aa"}, "d4aa39c5-267b-4fd1-8a78-f250d52223e2": {"doc_hash": "2a799a5efbe67b9077b62b521b00315c7867b1486554108283dadbb81d048975", "ref_doc_id": "c5997d7a-b89d-4b61-8761-2507394e40a0"}, "50671a7a-f068-4e5c-a625-50e14bdfb738": {"doc_hash": "e837e72de4e5621aeff0ee3e2ceb77917dce4ca7e4b94b5c93718431fb009e98", "ref_doc_id": "19e93801-918d-4282-9a4b-30cddf48c0da"}, "52827f85-7134-4794-b1c0-96a1eb266f2b": {"doc_hash": "37620311ad9faa1d41db69e98d651e3b1078284a6acc319b8d57d945e47489e3", "ref_doc_id": "0063fd8e-5d1b-4add-8c82-045fe6ff6f3a"}, "6cbfa301-f914-4db1-b2cd-a0e7b3ab8609": {"doc_hash": "72b0185fe33818159794cec2c280075994e5f082cba8b1c75daa59b5e7467d15", "ref_doc_id": "8b50b211-4d4b-4821-a539-16359be8f707"}, "ed4c75bb-678b-4403-8321-b02e7953532d": {"doc_hash": "117efb54caad6c288b321a3524dbc0d59f231b3e6b28320518c179817ef17b92", "ref_doc_id": "dfd067fe-0603-49d5-a708-cafac975920b"}, "6898adb5-101b-48d4-a2bb-f0c32f673c96": {"doc_hash": "4fdc387f973c28d5c3dc0123037df83d5736a6d80dde9b927381b97093d37d8c", "ref_doc_id": "c5c165ea-2e69-4106-b490-3e88aa7a6cf1"}, "6c755554-2e0a-4ce0-a45a-b107ac0836db": {"doc_hash": "20a8aa416acb4045176b14cfbc58f4e723efc1d0eca005ee32a7d2709615817a", "ref_doc_id": "3e1357db-0d6c-417a-ac58-5a204ea30351"}, "cec21d6f-04e2-474e-ada7-ce40a5410507": {"doc_hash": "ebd4032091c29589a71b207b2abb15782e458c4a973560f75818cd7f711fc772", "ref_doc_id": "bb8cb03c-b84d-45c8-8111-1ea6652c5e10"}, "9ad0da2c-2865-455c-94ef-4ec35f1eb79b": {"doc_hash": "d21f40d59d29cfb5e9bb946cd06d9815707eb62de94d4e31f828880fae0e6e65", "ref_doc_id": "9f9ea3b1-e133-45f9-925b-a881bd94f9bd"}, "75cdd08e-a2e1-4721-8dab-9cf2a00c7b78": {"doc_hash": "4c2d63d3648810ef5c981a87f9e68c6caff79cca7b5d46f9ae27325b2d022bef", "ref_doc_id": "53956d4c-29dd-4108-9497-1da36dc63c6f"}, "78d91caa-36f4-424a-af48-414b7a4548f5": {"doc_hash": "a58886618f305815db6689b2c6bc77ce6486f792bac9b30a793f78cad5d84ac6", "ref_doc_id": "762165b3-cf30-40a1-9890-05b1bd6a7aa0"}, "a66f8708-11b5-4beb-b3fa-ae79a71c16ae": {"doc_hash": "d07fc6dc79a7a39db8b89764f88f056579daea9ba7221080a750f7f0d9692ba9", "ref_doc_id": "ee687696-8b4d-46fe-858f-496a3d4dda20"}, "c65d8bcb-eab9-42cb-b1d8-0c910b867f28": {"doc_hash": "f085ccefdaeb02bee00e4cb83fb444bc4aad9e98067cc3d7be71159daea96cb0", "ref_doc_id": "d4476196-7a25-4dfb-939c-657bf8852838"}, "18c5cb38-7dec-441c-aba3-45cd9ae7a57a": {"doc_hash": "606d8889904d458fe7dc281f4b3963ba5ab4a5d23ed8a70debb0b8e7a20a0f3b", "ref_doc_id": "8b8b6da9-a36f-440d-90c8-f6434dffb4d2"}, "f999694d-be96-4621-b713-7e9e15915870": {"doc_hash": "a01bdf4d058799ac7ab64c49cbfbb1199883374d3171efc42e83149bb58d666e", "ref_doc_id": "6650b649-d903-4435-bf1b-d7a26e61fe86"}, "771bdba7-42f5-452b-83a1-2ee8b27882df": {"doc_hash": "774cfbeb08d75eb171be920e47af1f54ad02db5668872e7c4ce53ff5a4d14eb2", "ref_doc_id": "c2fd7088-d6e0-430a-babd-5f72b6b5aa9d"}, "cc68e32d-5c6b-4472-842a-71495f0bfcc1": {"doc_hash": "9d96ac753a5ea2a76e1b57cddfc170a8540432405fdf8c13ed26bf31b1e26ddb", "ref_doc_id": "e690c4d2-8baf-4595-9640-e564cc8d472b"}, "d21cfd19-30ba-4210-b470-b9bccf74f1cf": {"doc_hash": "d963dd4e2f0385d2029db13d1c91450b372c354b3c69bb13736eb4013a4508f3", "ref_doc_id": "05747e15-8e37-488f-9692-e33ef86e8ce0"}, "17c3ea39-de87-4f56-817f-5ce8e3cd8248": {"doc_hash": "157fd406cf0d42e685ab07de00f83661065925835dc5a90774e3f0cf286f7c8f", "ref_doc_id": "69f5ee2e-4e66-47ca-8e65-dc1010d73b0b"}, "7b5bf126-0a4e-49f3-80b4-530f7ec84131": {"doc_hash": "3c861d510a4bbc7be6ddde928c4af715d0b394f23b17a3084e4a70899023af01", "ref_doc_id": "33ad6aa0-b2ef-4e06-b5df-a26aeb760b34"}, "fe5af126-fb62-46be-b02d-10ea2f80b1f5": {"doc_hash": "9832d21da0b04f6bb466bae7d39aaae1a8000feaede8d914eea33b4b0357873a", "ref_doc_id": "5be53cfa-ce6c-4f79-b84e-0144051b36df"}, "f1c16bba-8c7c-4ed8-a837-b52c8d2686ff": {"doc_hash": "c0799397e21b94812d79fa80e3a2ef3a4c77ac080ade261120ef43289a6ed058", "ref_doc_id": "48e829f2-6f0b-40bc-91e3-d3e60df8dbf2"}, "078ab933-ead9-4998-87c8-74150d9ed248": {"doc_hash": "52094c64703096c325a12866ae261b66e7ad05d0ef56977ed541ca459c9d337d", "ref_doc_id": "7359bfb4-f319-4cec-9fa4-5ff20b7d1356"}, "245ce618-bd18-478c-bfcf-18d9555140ee": {"doc_hash": "6f4d1008e9783edd8ab468d0556eeec3806c3a6f3a02751cde42c0a132d953fa", "ref_doc_id": "7a7b53a5-e10b-4db9-b62a-a4fb8e73c083"}, "ec653924-a576-4a59-876d-4057a73f9878": {"doc_hash": "6c3f41af35be143a89b9adb311fad84f2772dafccfbfa944f0f64ecaaa11dcda", "ref_doc_id": "5f40c19d-e13d-4ecd-84ca-53b30f4ca2b1"}, "83a94922-b1cc-45de-beb0-b4060a4b1005": {"doc_hash": "116d1f58661e0ab8e009877a595d2689f106503775b5308cf011a87060013848", "ref_doc_id": "04f47935-4eb2-413c-a396-3ee88762431a"}, "8af00d5c-5958-418e-9a32-f9ab00c63441": {"doc_hash": "0abb5248bfc97c982f66c6f4a57823c2d981e7493efd93deb6e151ce2a2966d6", "ref_doc_id": "9abc826b-aaac-4f70-92e4-56573e5d8295"}, "e28efa31-8a17-46a2-a1e2-37f4d0a73cf0": {"doc_hash": "ed4e834fac535014088f36bebb2fb2da9e569d69c8bae8696212a7da3ec23edc", "ref_doc_id": "bf77a913-0cbd-4f71-b224-5f9c204e497b"}, "ccea796f-fc4e-4228-9eae-6e4a61c8f2e2": {"doc_hash": "88194ccee2fdf140a595bd0b64c979c8cd55ee673367a7b71159ead144df1832", "ref_doc_id": "d8697d45-c8d6-46b2-81b4-061c436099d9"}, "2cf8df8a-dffc-4088-94a1-fe1daed08f1b": {"doc_hash": "24247d2cd3f0875312d65581f748d5903559d0951aaaf05eb4ea80ab75e9696d", "ref_doc_id": "5a64a2df-968e-4f10-a4d0-38d68d4b22f9"}, "c30c87ee-cf45-4a7c-adcf-cb1a8efee26e": {"doc_hash": "8ba070586ef608d226b4590f8d18537baf511bd7ce518282cb22e660947744be", "ref_doc_id": "672c52db-1169-4d88-9422-a873ce53b643"}, "19f47f77-aee3-40b9-a68b-dfb2135cc2ef": {"doc_hash": "f7de28d86c4cafd31fb149976c0a42ed96b35ae8788897e569e351b5248ef38e", "ref_doc_id": "fef06e5c-c24b-430a-92f0-4e1b10b3ccdf"}, "e5f6d7f7-9670-40ed-a15c-ac7e233ce616": {"doc_hash": "f7c935b4d97fc51632e3d364437d88d41049e237f3d22f9349afaa4c1ddb3cd5", "ref_doc_id": "98dc8c61-0938-40a0-bcd1-865c86dd1d6f"}, "d9030338-2be4-4856-bb1e-64a2a9fdf852": {"doc_hash": "1b862f6418ab892521676633215407369c4a490d9c4e9ed8ea681351afeaed35", "ref_doc_id": "e777113e-ee66-495a-8484-fa5a32bcc454"}, "3f0d11df-538c-4959-b75d-17647f4acd23": {"doc_hash": "e13eb96d6b00abee1a0f2f015f7cdccbb177511b1af2d5f4262169473545e13f", "ref_doc_id": "6f6c2f5f-6b4c-4296-a8b1-a9ec10497351"}, "18ee8e8a-cdf5-42ca-9347-1dd8a2cb028a": {"doc_hash": "4c820fc5025e57a136e9edf7ba5e2b83cc98344d9ebbd80e970dd78895f1a6c8", "ref_doc_id": "66108743-8e72-4c8f-a2a5-34d8b61b174f"}, "6b383aa2-ffd3-40a1-8248-b54e1d570312": {"doc_hash": "637ed75cd760902073c66bdbf5bf67ee818ea716d5845cd310354266683429f7", "ref_doc_id": "521e1d8b-fbaf-4ab2-b69b-2e48b8230a7a"}, "42ca0333-0ae1-4717-8ca5-aa48833657e4": {"doc_hash": "a80d3456541be68167ff82563977ef247b8e838b0f7bb909f5ff1100d0609c51", "ref_doc_id": "e36849d0-c59d-42ce-8dca-b23571fb2860"}, "6bb00794-0153-45d9-b27c-8439d0de0d46": {"doc_hash": "96baaee09ec01ff359877ff048650dd7b53b36e7b5c0c77fe2087374e550d0cc", "ref_doc_id": "3fd3611c-2a79-4be7-8fc6-a7deced046e0"}, "0d5cd916-fd99-4b68-ab4c-99cd55bc8fc5": {"doc_hash": "d484d90367c921e366f31107027a9b7ef3c511bce1d38dd25c36352a729922d5", "ref_doc_id": "666b246d-da04-463f-a8e9-c11b622f7fc3"}, "451ff369-0ffe-43ce-8c47-5435c31f8cc4": {"doc_hash": "90f9c209946b3335b57e2a14915b10d4823ab102323bfbc7b5fc4d67e11dacf4", "ref_doc_id": "e5fe52ac-d081-419e-8b6b-b6d548f3d0cb"}, "26d9bc63-0878-463e-be6c-c08ab76d96ff": {"doc_hash": "ca512b4472782409bfad34bb8dfd4694e532cc8c4a71b78d2015bb5e4c5e5334", "ref_doc_id": "17da1750-e889-43c4-b7b3-35be6ee52db0"}, "77ed7a80-857a-4560-a0e8-f0cda970db00": {"doc_hash": "df90574a5ef77b0f9c85b8cafe1be3e6522c50c7ee86dffb3d92650baee04787", "ref_doc_id": "ddaf3c7c-18e8-4213-b2c5-d99f960bef47"}, "6a9fa445-5130-4aa2-8032-db67cc547efe": {"doc_hash": "23fadc65633ace430a6a4ba4004a0fafb17ba5f764e43171370ea4964f794f66", "ref_doc_id": "221eeb34-7b96-4f24-82ab-7881bc01e7ea"}, "e04a2bf7-fabc-4c4f-81b2-8f117c6c1649": {"doc_hash": "94a5833a41dd3ec2627824b3e48b826a50fa337a411a45d452298bc1fecdec04", "ref_doc_id": "7f5f8800-2f00-4524-a28f-0f0746e72ab0"}, "b2e4f21c-cb75-46fd-85c4-ad51674a7140": {"doc_hash": "288a43b6168e4be9a5b25e708670d8fd3a8c3788e21f92d49a880a381a9efaa9", "ref_doc_id": "4164172b-ca9e-42f0-89ba-bc7e969461cf"}, "0c4216d6-de23-4054-83bd-868e84f849f4": {"doc_hash": "fde4dd7963cb05c6bf2a3540b04a0391f95a742cccf883c200b2f38d5e3fc72c", "ref_doc_id": "e0f9db8d-428c-424f-8a25-ca6c429119e0"}, "8311a3a7-add2-48a5-9526-704de163ff79": {"doc_hash": "c33e3257d05af112aafe4ac2e8d06ae700cdcb1e7e500d47317c05599ca98708", "ref_doc_id": "7b2ba05b-7a15-424c-ad27-c400e81550a6"}, "3f1c05f1-8e44-4306-83b7-c9a63b6f13b8": {"doc_hash": "66efdef306b627369b4a6c879ec4f06300c51ed0c321af3daea07ea94a0089b0", "ref_doc_id": "a1614889-9620-4646-9cd9-2887e75271f7"}, "d34314bb-13be-4ded-bea4-4b151595da5f": {"doc_hash": "074b4447af410f4ad5906b1cb9f00c920213d219710d02dd509e3f292e718428", "ref_doc_id": "0f1a1264-ec42-4ed5-948a-64a1883b02ee"}, "1c16e524-caca-4bf9-ad43-8bce687bc1da": {"doc_hash": "f9b05b8cbb990697ee6d667c51cdedf8d6e6aae508740c6cb735162c413e1cd9", "ref_doc_id": "9c8a1a6f-0bdb-4f4d-8081-8c911d3bf814"}, "c3038e20-909c-4975-8f2e-f8d6981f0324": {"doc_hash": "f4eb827c3f664f79d973899ae97a8b8ee74bb41828b0b9360255a4be9bf42a65", "ref_doc_id": "0fa3cadb-bdee-4e32-9bbf-6f4544a28df4"}, "7508c5f0-c125-4c7d-8958-2077c3110e1f": {"doc_hash": "4543c92a26d1034c334442a46fbdbee6d7b3cc2add8076341607b02ec51ebf15", "ref_doc_id": "86b27ff7-96bf-45fd-a18e-4c5a531270cd"}, "aa507699-fdd4-444d-9652-69e50dd48c78": {"doc_hash": "a0c6bc09eb30b602eec292fbcba2abb5e0a80e3c4464a085b1e35e95eb948c58", "ref_doc_id": "4a967455-ff90-443b-aac0-f253d5cad787"}, "00e5ffb9-21cc-463c-b548-34d571d5095c": {"doc_hash": "c747ce690cc86182d103fba824b8f3436801007dbdfbc820c04748e4ae945f07", "ref_doc_id": "47bafb77-7ede-4031-88a9-d1a15f1b4174"}, "77dc5ea3-67f1-46c5-8b25-18654893767b": {"doc_hash": "d1134e3fb42078302abaa3e82c71735deccaf885e0d553aed197979c32fe13f2", "ref_doc_id": "6bb9f562-08b4-482c-879b-f5204c24863c"}, "79e79cc2-8e5c-4d49-bd0a-7d96b1ea98b1": {"doc_hash": "1ede4c6f73e097c2f86b293365f7f6ac0e434401d2d2d4ecd387ceea3724a188", "ref_doc_id": "020c9962-814c-4544-b47d-bd5e088dc0d6"}, "b1daa9c1-6268-484b-ba91-072c936296b6": {"doc_hash": "3573095b1a5cac6967702a0f7e8ca9d4c9bcca8368610fbefe476ac81a409030", "ref_doc_id": "3589c68e-a936-4f7c-a72f-b52d267396ae"}, "407468c5-c892-4e1d-8488-10b04bb5cc28": {"doc_hash": "b6e0d140ae1f3cda52b2fc274d77dc852d5d40c84f13d3265e621362a3062a4b", "ref_doc_id": "cc07f000-f142-4a45-a1c6-3c973f3ab86d"}, "b45ca332-fa0a-4457-bc18-1ea1396ad35d": {"doc_hash": "98d71c1a26eb4300df0f4196ef1145c2086d238dfc854c6a637e61dffb053d3c", "ref_doc_id": "3e31bb1e-7bca-4f6b-ba14-043a85d9b35f"}, "8c3f08ff-0645-46d8-b39f-a201d280897b": {"doc_hash": "695bb83812e856b38714f9ab051b91dad54c5cee8fbca585b49071c4ab4408d9", "ref_doc_id": "cf35a497-039f-4925-b96b-0853163d220e"}, "db6a0687-1441-437f-995e-6c4eb8eb2f1c": {"doc_hash": "e7cbbcfb8c59c587c9b0a3c55b1f7b58904530a0507e8f485e8d9fa4a6a5e46d", "ref_doc_id": "3973cf5e-04b2-4f24-8bf1-86bfd34c0766"}, "10e12f1c-8b48-49d4-ab6a-56bc06fa4f41": {"doc_hash": "901e44fc4d8c0d632ac8a337ad66bb7da6aaa0acb6781471631fb1744867c927", "ref_doc_id": "76c870a1-9718-401d-a4b8-31c12741fb34"}, "e4e85057-d88d-4b01-80b1-d21bfc22595d": {"doc_hash": "0f0860fd6a353ae4f2a49c5c2ee275c4d3e70fdb6f8ad5512b770888b2701e52", "ref_doc_id": "a931dbc2-698d-468d-a59a-ac3ef6a6ed5d"}, "7780dfff-26aa-423f-80db-7ecfcd68c66a": {"doc_hash": "c300d80bc72d10a5f95187514f9146b4908742d42a3a99734b49df7ed4fcb3e4", "ref_doc_id": "beba3d6a-0c00-41ad-8245-0795732d0820"}, "0d7ae8b6-5030-4348-9273-a1ce4400ca20": {"doc_hash": "6e721a23529c3d78412f26f3ef975081d08c3aa074f85c368bd0f7fe567cc444", "ref_doc_id": "422d5eba-01e0-463b-9950-66defc80145d"}, "919e7b9b-909f-4dbd-9884-f26c86cc0e60": {"doc_hash": "d713fc46398b5e67ad437b0219ab575f1921a9663e42cfd667b5e6f2046e1ee4", "ref_doc_id": "5b4fd09f-cf8a-40d7-a32b-4c05b37fb621"}, "fd255e85-c96f-4be8-8510-b9972ab07405": {"doc_hash": "8f8b05e6ad700fb353357d0311438bdc40f8c7ce3ec254ba23dddaad722deef9", "ref_doc_id": "90cd8423-ad69-4429-b027-53fad49f1557"}, "c1bd448e-09ff-4285-84ee-a49053f29bae": {"doc_hash": "b75eafaeb65eb85934c1034ad60099a401afd157939b238de5be135996aeae3d", "ref_doc_id": "2f24ccb9-6097-4d2b-ba05-cf6a835d6cf8"}, "48a36d01-fbba-4ee0-a779-8002a3745055": {"doc_hash": "65c6b306381b57fa7d3c783a3fc7e791b3c19b0d1aec82e8527f06b74232f4c2", "ref_doc_id": "b01ffb6e-6570-4e73-97f9-ea92357b20a0"}, "999607f1-8b17-4060-8e8c-20ef8efcaa5f": {"doc_hash": "677ee5b5e1304a5b268ac93c1d3d355b689846aff5f108cc04c9ed2c9e941e39", "ref_doc_id": "80efb101-c438-4a56-9570-247a51f2d5b5"}, "97b9fb50-6fd7-4374-88c7-3b3dc47578d1": {"doc_hash": "45d88005a037d9e479c858e334f08144487e0fe980508d6f21700293603251d2", "ref_doc_id": "b23e1269-93f4-4c88-b3b1-37058eafacf2"}, "fc44d2dd-aef1-4b43-9cc6-59d130ca6d93": {"doc_hash": "78caad2ad7b1456710cdee866936ddd6a94d255a4a182a1b4ab9b39230419d38", "ref_doc_id": "83632113-3b93-4dbe-8baa-5492636c0cad"}, "69d174a5-e926-43c1-b75e-d94e330792d3": {"doc_hash": "37820b8d406430f340825088e02b6795b99dcb587bd22a404c9d6dc464ffdb69", "ref_doc_id": "8ab14ae7-3e5a-47ff-87cc-29d655c0f217"}, "4fc31d55-0109-4f4c-96d7-6d6d45537ae7": {"doc_hash": "e5738402c7454ba917f351d670f0522e950857715fda61268a57878c7b894b73", "ref_doc_id": "b1c36591-ecdc-469b-acee-2323ddd22057"}, "3ddb8602-8d83-4149-bb79-8b931417e4f8": {"doc_hash": "4abb2809de058ec19569fc203ffb3bf900e1c4ed2383f8f76985c2e72abeed8c", "ref_doc_id": "8b61f980-b631-4fa1-bcb3-4545ef71f0e2"}, "8693f4f8-51f1-4936-af4a-9aec63cbf336": {"doc_hash": "477ebebf63c26dda1e96dc7eb387d33e4ab7f8c4fa1ea1d4e475c6a1ca3f48e3", "ref_doc_id": "62807149-20bb-4ea0-88a9-b388296a678b"}, "29a972bf-47cb-4a45-8421-07873bb6cb4e": {"doc_hash": "ce2171cf74a6bc04337d2f292fa8297d9ea8c5a4208532973d4f3f1c0c995081", "ref_doc_id": "4239e245-38c5-48bf-8c5e-5ab54771505a"}, "40f6b157-58dd-4879-8d02-6cddca160578": {"doc_hash": "a988af7ab2f5eb484dd40a129e216a74031a58d0872c71e8c19245ec0e07d32d", "ref_doc_id": "5dc95019-dd8a-4163-ba49-8a86f9bab2be"}, "bb1c3834-e822-46a2-9654-67ed0c7a0650": {"doc_hash": "1a6e01b44a6a0a458c3947e64aa5094c763213f3503e782566768cc001d8148e", "ref_doc_id": "b210da89-1cc5-4301-8579-b769944ca6c7"}, "0aeeecfd-2c76-41fc-adbd-6544fc936760": {"doc_hash": "f7cb9baaf6e62bab9a8770634434e2fb8907a2cca2d2d069defe4b284b2abfb1", "ref_doc_id": "835380c0-696a-46f4-ae60-27ff7743de58"}, "ad0dd0eb-f04b-4d4e-8a81-cfdb1c644f8a": {"doc_hash": "74f28f0a8079c61d36f3d555fbab2d0400ea25f7fc474d4c273c6d4f123585eb", "ref_doc_id": "d19893bb-b70c-41e9-b28f-e963217d0772"}, "28c34bd1-c5f6-4ddf-a984-7031ef7e6141": {"doc_hash": "a7a48ea9df4b6b4f661561c60c6955ff58e378f5600c51bb7c004d63c23f9ffb", "ref_doc_id": "534eec77-5499-42ab-a7cc-6e08916763ae"}, "f994cd55-5e3d-4866-a09c-724b2e5c8911": {"doc_hash": "dfbf045610564afcecd98a425d1a88b212451b74d801a3a11ba20347f315d53b", "ref_doc_id": "ea20ea8f-b79c-43f6-8de4-4a863a9d5c36"}, "af858b52-7aca-42fd-93cd-72c1bbd520e8": {"doc_hash": "139f7cc388d524a97aec077b759ec3e8283bca7624d6a0e7044f6590a6be3ddb", "ref_doc_id": "421728b7-8c71-49b4-b01c-db40d671cc7e"}, "593dc5f5-1409-4e84-87bb-d3211cdadbbc": {"doc_hash": "c16a2091614dbe612467e2d96a9cb710505d8136e389f333f6fa64b97dd83ba6", "ref_doc_id": "4bb40782-9d07-4fd6-9471-5594a5ece7f9"}, "a53494d2-18bc-4974-b11d-b5bc346bf6ae": {"doc_hash": "6c1b768abffaef863cc51335964ecec186feba984bea9605874a06b66ecd66f4", "ref_doc_id": "9d9790f9-0c0d-4abd-a9b2-cac5867c3cb2"}, "8d8e919b-5563-4849-94c3-397b166476a2": {"doc_hash": "d25aab84b86160c2b8d8ee96512151e6800761d59609f4dd00c2da051bd1e3a1", "ref_doc_id": "a7a1fac0-f06c-46c7-a259-40c3a0447dc9"}, "8baf1cec-3823-47a6-9915-5eb8b2a531a7": {"doc_hash": "fe75da84bb2f72acc0bb46f725dd17f00fed5ec2415e0811b266dec6e224454c", "ref_doc_id": "0513a6ff-37d1-49e2-996f-e00190978814"}, "e9fee898-bac3-4c9b-9ccf-697f55c4b76c": {"doc_hash": "b3518e43eab28da79593ced41d7f2cd1870925d28696baac92d3a68ef478f87c", "ref_doc_id": "d163693a-db12-4f49-80f4-20720b5d771a"}, "393fd87b-db4d-4079-ade3-bd64d9a629e5": {"doc_hash": "833432ac3dc805669bd111011fc2bb67753942a44c977874ee59a0628970668d", "ref_doc_id": "04e90bd5-78b8-4576-baad-68fca27cb845"}, "9bcf0375-2f27-4609-a9ed-c32d6ecea9d2": {"doc_hash": "1e6ae59d02f8ed5e69d607ee58fbf8fde68b5b02775613a29681b98c3a0a54db", "ref_doc_id": "51aad2c8-e317-409c-acc2-6c68a59b386d"}, "4fdf45c8-d8c6-4a47-afcb-dabb3f624306": {"doc_hash": "451a6591f37799782496c895fc1c6ddb1f8d96f084cc41ca542fc4a9e52e189b", "ref_doc_id": "355a0b1d-e050-4e4e-8118-e13795aecd31"}, "2f6dff31-e8f9-4543-bfe4-79aecbf87d39": {"doc_hash": "ebfcb5425e74a6f174c05b69dff38b3285eeb8e0fe89624ec86816f3904e53e9", "ref_doc_id": "2aa3f0ba-12df-4f3a-ac5a-6dc7763d04cd"}, "24253d98-a89b-4f85-bd8c-89782a193bcd": {"doc_hash": "d901a005cbb9548d3e36d111e292738bb7af5a7c12e069a940238454d43953c1", "ref_doc_id": "ffb92656-4510-4f1d-a9a8-6daf413e70ec"}, "23e3e992-2796-422d-b59b-12b7a933c4a3": {"doc_hash": "fa5516e6fd148e029a211b40ede1c9e439daaffb41895bd8b396f3ec91f8cac9", "ref_doc_id": "991644ea-d5cb-43ab-9a3f-f18e7b808f76"}, "fbfcd7a6-967d-4c74-bf2a-b2ca457349c0": {"doc_hash": "dd9e8cf9f9eb2bcc2b2ccdc04192b0467ff7ee3613092a177e5c674b28c8cae9", "ref_doc_id": "26739b1e-9b08-4610-bd98-2c3d1e56b1df"}, "a63a7445-23b5-4364-bef9-b25d6175d40b": {"doc_hash": "5d8b53fe882e51229f737d6dc87a13090608ac6a885506e85dbabdf8c61d709e", "ref_doc_id": "3d64891d-cbfb-479a-acc5-7c2439671a15"}, "80660fb5-3b2a-4a58-b318-213b8803fae8": {"doc_hash": "53b15e01665899dd2772312fdf45529845d8416da49c570db22f24c6308d1f19", "ref_doc_id": "adb98f3b-d644-4796-86d1-fdcd0a21d197"}, "a1afa5c9-b630-41d4-a131-4ebfd857c431": {"doc_hash": "272d146f68fd06e47920941deb46ea47412daba465967628448ed1790825a9e7", "ref_doc_id": "b36374c6-dd3c-47d9-b0c4-e1da34b314ac"}, "b3cb46e9-82c7-4e43-92ee-b723a886cb76": {"doc_hash": "f8547aabd7c2fb2302bbbc96232309c278beb9c3462c64f38bf2addcdd6b53fa", "ref_doc_id": "c496cf3f-db7c-4676-96e3-985300013278"}, "01a131bf-931b-41c0-b9a8-d0b787b60b1b": {"doc_hash": "c98ea071f96aca425353a7ec5bbb2820ba117d7345ebe49ae7a1610c06cabad5", "ref_doc_id": "3936185a-e789-4c20-9a73-0436893c3cf5"}, "0e7b9a01-5615-4c29-944c-6006634acbe7": {"doc_hash": "f869d353d06ce6e5baf5370b8628ae806efce209e0aa0a93126a7361e7e82834", "ref_doc_id": "d489f49e-eb06-4d55-bedc-9fcde8ebfa8b"}, "89b7b66a-1610-4e8b-ab23-afb22c3a0b82": {"doc_hash": "458982a0f22be57e264e96f9ada140dc8f07d1a66b7bb433210a61de9f2cd24f", "ref_doc_id": "1167e740-3499-4055-80d8-2b1e36c0db47"}, "8390c7ad-db5d-42ab-85fd-fb64a86090a9": {"doc_hash": "ac2fab64b8bdf2786fb895e35f8ff8f911bb3bcad03f4f9be444e357cfebc884", "ref_doc_id": "5d2fa64f-63ad-4567-937f-80cd736792cb"}, "f006e955-5ac8-4f98-b1ca-e7e4c1ea1c2d": {"doc_hash": "5c38d32a7337d78915a9cb733c30cecbec39554a4f87b033c9277e834888cbca", "ref_doc_id": "61ca1e37-ff76-487d-89b5-0e104b4f162f"}, "b152d274-605e-4e2d-84eb-5ab56cf61540": {"doc_hash": "df4cd0fe5783b7498d555783978786b6d1e6770c9a1fea259e76b474d42afb80", "ref_doc_id": "45f1e8bc-cd76-454a-9209-6481d61aaf2f"}, "fe1108ab-fe1a-438f-8cd5-07474c5960c7": {"doc_hash": "65a6746b20a992c81c3f58f124ab7752b29cb17c54ecbe918b5180ca38ba79fd", "ref_doc_id": "9124a20b-faf2-4a4e-b484-4be817e719e3"}, "d07c65fc-95a1-40f4-a865-36f8045c68f8": {"doc_hash": "b5851c1a915d82b6d9b3347c27aadd18f73a1db301b34228b68aae72aa335543", "ref_doc_id": "f36f125b-1496-4cd6-9a71-ce3fae0223fd"}, "5978a372-0d7b-4eae-bc52-80ab6a639828": {"doc_hash": "6a0f6b9ef46ee4674309a4389c4205ac238566e33af9e86990e43b547f7d0929", "ref_doc_id": "b52adccf-20ac-4702-83b4-4427290b3b6e"}, "16952eee-7490-43c4-9896-815f12f07593": {"doc_hash": "fe97bb0ea6e856534f45c747c9008da8e185f929b2b30938c08f528adbfa13a4", "ref_doc_id": "16543eeb-ac14-4029-8648-f26aa526e10f"}, "64c51607-5fe3-458d-8c87-d0d7251ba8c7": {"doc_hash": "c79da383657e7752c113148c57999fda1e576a3ff82f3af8321deaebdf234645", "ref_doc_id": "5d5400c7-c8b7-4bcd-b06b-43121fa9a67c"}, "2713b3fb-a4d5-4f7e-8b71-e5080c6721ac": {"doc_hash": "72ff032552bae0053aa312b8b1acb6aebe47668441fefd80a664872f335fc6d2", "ref_doc_id": "4fc8c988-dfcf-4bdc-81aa-ace38e2be9be"}, "d054fb83-36a1-4310-a9df-35148fb693a8": {"doc_hash": "cbbb2ba5198e3a2b5a3314857d811e2a0d87ffe6d89cdef79620f81e4fb2e818", "ref_doc_id": "e8976e21-25dc-4b16-ad08-a19d677726d6"}, "c768791e-4045-4f8d-bfc5-8ecf2a2b6b81": {"doc_hash": "d40909cd69c3ab3b0bd5c66c550f7e4a3e6c41068a66805213201718e5c89fad", "ref_doc_id": "3491a0f8-7885-424a-9421-b76b94c74c39"}, "8020715c-97ec-4ac5-99b0-05d78c71bb15": {"doc_hash": "921038edbb70ad306875095461313e6679d6ff8c7f41641791294d714f6b903e", "ref_doc_id": "1e4f4924-aa33-45d5-a297-f62a3ad8f904"}, "335cbb26-9966-4ac6-a138-c9b9a3884534": {"doc_hash": "f72df64cc7b4cd43a40e3f7b2c7fd8dbf11e91e2b0f316dacf455a1b6098697a", "ref_doc_id": "74ba0371-961a-455d-80f1-aa3516b441ce"}, "452f3e00-5a78-497b-a165-01720ec02ee2": {"doc_hash": "69330acd4f61369e5f5ee036fdbf4ded3a1dbf45c9b6515ea1ffd91c64593f02", "ref_doc_id": "a951f138-1070-4ed3-9f72-4d54ac44b4f8"}, "914e0e80-d7c8-4955-847a-f85596cd5183": {"doc_hash": "27e0a19a75b27563b20e6283e7e00afe63b6fdafb8600e86eb3cf61786efa9db", "ref_doc_id": "74b15e6b-e45a-42e9-9501-c1c9de739b29"}, "bf494829-b7b3-481a-b998-7565694b2d80": {"doc_hash": "54a841e1117e900d01b01dfd0fd3a45a656f64f52d758ab459da027209e276e3", "ref_doc_id": "c103fa70-4986-4919-87ad-5c0afc65a55c"}, "230370d4-410d-47ab-9da7-25d4e7706ad4": {"doc_hash": "fc064adc044c79786813e6e3fb2fe1f15756918b61c5bc216b257966e79f8bc8", "ref_doc_id": "1bd0666f-a984-45fb-8d43-bbe717549c59"}, "4e55b646-ac3c-464b-af17-d8c464b756db": {"doc_hash": "1f3b9c158faab71cf9aca74a50c1be80edcc27d54ffe0af21f98ebd399c89f5e", "ref_doc_id": "f9057212-8280-49f5-8633-560064ca7e85"}, "c3523cc5-97f1-42c5-9908-9aa9278ccd00": {"doc_hash": "41eeb06140b7fc2193924552c8cc54104fff5255aba1824fbafecafdb2eaf208", "ref_doc_id": "73d30326-d346-444b-8427-60423669af22"}, "e8d5ef94-5438-431f-b189-1b030835e3a0": {"doc_hash": "b57fa59b3d8e4a6dc056b53c24ad69fc436cd6b3a870f83f08d330f39cb9662e", "ref_doc_id": "ddc5011c-48e6-4995-9116-b1dabcf29a6e"}, "b4196a97-3292-46dd-b1aa-44f17496bb6e": {"doc_hash": "e98ccbc1f9745421df9741724cc46592c8b7a97939134de63e62a8ea89e99e61", "ref_doc_id": "0048b2ab-bbec-41a3-825a-237df653dc3f"}, "c22de179-a7d6-4071-9e68-a5227d532349": {"doc_hash": "e5cc4ade696368d48eb9a3ef5bafa26cc4625416ec560be94e0bd88ad4c3c81f", "ref_doc_id": "b263ad4e-acba-44ee-858c-66516c49a1a7"}, "7c2f83e6-174c-4275-9517-3c469d213c78": {"doc_hash": "4793a44b7f2978050839c11e68fe1ffef7c2720b05a362aa9a5b18691d3bd7e7", "ref_doc_id": "f1e400dd-661c-4f6d-b041-d5af93ab6a14"}, "d7075920-6a29-4e5b-b4ce-72493e3f5a6b": {"doc_hash": "2661dfd3f22a6f56d7d44bdd6a832dd74fbc6dff7ea7c17a08bd0c2be58af740", "ref_doc_id": "d1caed6c-ee34-4245-b916-a15da6b54bc2"}, "4b78f1e4-4133-4c3c-9639-ecf807fa4e33": {"doc_hash": "a14fa0268a64ff5b5d62c15943a8313228d2c9a809bc09f345ce6abf790f5291", "ref_doc_id": "b1bf2f8d-6b8d-475c-a0d8-42bf64e1c085"}, "667d02ee-b67e-44f0-9aaa-1fe6590506db": {"doc_hash": "243b2030386804a79370ced3c96bb30bea8ed984dd6e46ffd7df79ee76489366", "ref_doc_id": "fdd13f4c-1205-4d85-908f-2501d10b8439"}, "6eacf695-85ee-48b3-a4f7-ca1e140bfb4d": {"doc_hash": "c96aee67143c3ba6570713411f89fb39f6c2751f7508dda89f819f52428623d1", "ref_doc_id": "0042a8be-64ad-41a8-842c-38e95d1a43e4"}, "400d7f02-5c03-41cd-b9c2-742beec562fa": {"doc_hash": "02b8d4c6f829c6ea4aeafd66a2557e2f0b7a40728323822695e255bead531182", "ref_doc_id": "d312320e-84f0-4848-b89e-678f0e249b16"}, "0c8e0ec4-2d06-4902-b6cc-13a814900857": {"doc_hash": "673bba7880c8a9612ba0147612af86f525ea49ebb94d074c113f9180b531aac9", "ref_doc_id": "f19b4a22-e22d-4574-80ce-78857f8dd971"}, "74d929e5-12c6-417f-9a9b-f651b68359b5": {"doc_hash": "b4167e4fbd628fb7fba1e8ec74fe06998bf24da93c1702485a789447de49b213", "ref_doc_id": "c813164e-7534-45ca-b9d0-689c537fd914"}, "179c3b6d-2363-483d-8c35-06bc67d6440d": {"doc_hash": "4debef183c15e29b723f85a2770374574677ce56791a7944b1b8e93bfb1bf999", "ref_doc_id": "cba44fcb-580b-4544-92c7-ec1282434a12"}, "016d1b68-259b-406f-9269-ccb615f2ca2e": {"doc_hash": "1c4a3b700f253d8ce5708efdb318dbe6bca0de58da2d0eb1361d00c37824d74f", "ref_doc_id": "4d594d2e-fc1a-43e3-9943-125e8794d69d"}, "7aaba711-3a58-49f2-ae87-a8296b1ab22f": {"doc_hash": "f3f939f8245d8d1b4570e18e145b92fb82b6ca51dbbe795ed1d99f86850f427c", "ref_doc_id": "33ef6d4e-4ec5-458f-94f2-a65b4d005832"}, "da042b45-2a4b-4464-9b43-5cb49453ad65": {"doc_hash": "d7fe416af0a8ea47029b35f29e3b30355e6c6c4435bbb1c28dbce77804fc4b01", "ref_doc_id": "f68544ad-0038-43c6-9a8b-53e0ee19c017"}, "fb9b6b0a-30bf-4b98-8047-0a9cf8413382": {"doc_hash": "d8dacf5dd0e5f2244b0ad96f734bca12497e75b6138638518c866b830ef2a212", "ref_doc_id": "f90a875c-76d8-42ec-9e84-91cdbabf3749"}, "6de0d041-cd0d-4482-ae08-1d1a4c4ee88b": {"doc_hash": "ebf80a629c2060b98f4252a455977920518c80febba8d78425dbd427fdde3890", "ref_doc_id": "05e5fddb-4fc1-4ce4-8203-d3c12b06876e"}, "8d13f3f6-55c2-4a37-bbab-0e7d15fb91cb": {"doc_hash": "5343fd0294bcada0b152a8960d56a156d82d412c6f440b16816ebd71af0bde01", "ref_doc_id": "34114b5c-f30a-49eb-913b-4c029b66924b"}, "611db140-d289-46bb-93b9-758b7c5263b5": {"doc_hash": "979fa49445ebb4bc85d6941cef9557594d83f311f10f7114842c121aeef8942e", "ref_doc_id": "24d0e59e-7c0e-4d9c-8694-862da5bd9c9e"}, "fb7a946c-0d8a-4d10-a835-8b91d0ad0228": {"doc_hash": "a8621583215182dfaa0beeac9dba386e390167b7478c2beb709a6cfebab0ab9b", "ref_doc_id": "22b3f44f-4ad1-4d34-a82d-571c2b577b6e"}, "3dc626c7-34d3-4384-bba6-1cec5b7e2f01": {"doc_hash": "ae66225ecc6f63b01da54f9ca15bad8980d242613b1de70bd40c7be14bb8f802", "ref_doc_id": "1a76c8e1-ebca-4586-a5da-e59a20636cca"}, "0272bb7d-543e-4907-8cd9-7116ecefde79": {"doc_hash": "a4ae7415f8b8b12a4093ff4ee54f85ffd45c06fe5851a987b24a2c18d3c48b0b", "ref_doc_id": "3672e5cf-e2c6-4a0a-b5f2-20e5bdc4187b"}, "e4cda223-39a2-48cb-9461-39644f748f69": {"doc_hash": "5b036ed87ad4735af039080744d9a72ddea511e7cafe84274d31a4fa6c8673de", "ref_doc_id": "172c2c71-ee13-4afb-ba6a-0fd681edc954"}, "27430c41-6220-4835-9a4b-285e1d962ac6": {"doc_hash": "3c621eac4f7ba2f789b228377852bc63a5a3deee3b628c5d9cb3c76e41520c89", "ref_doc_id": "53a407b0-b77c-42d7-b003-4e4980be6e11"}, "f882ea27-9ec0-4efb-adf0-7b9295f866b0": {"doc_hash": "eefa1b57927501f7a3452dbccaf92c29d2948ec877fecbb1efe779c37f051fcf", "ref_doc_id": "8a597797-d489-45be-9578-b1f11480e9fd"}, "768e1e44-5820-468f-b202-57f26cedde5c": {"doc_hash": "b26f8cae5f9104b183434416bbfd49ade857d77b77a038f835cea17f75c1c5ba", "ref_doc_id": "00a8a64f-a260-4723-9ca2-905e109f75ce"}, "e436db12-919e-4822-b6de-ccdc2f304527": {"doc_hash": "6a7a0e22a27dccb69ab9a1a9592c81ae2392073eb5b8683cbc46d759f4e2f164", "ref_doc_id": "47c0629d-452f-4451-87b6-06af971fa3e0"}, "3843a229-4552-4fe9-8f45-6ae1e7ef2dca": {"doc_hash": "9547f25fd7a1d7d8504151a3874106641395408f14f3edda62402d9a1a7a6a1a", "ref_doc_id": "d37b295f-ea6c-4bee-a644-19a1951d38c9"}, "e4ee90e4-a1ad-42bb-b18d-725b148b77d7": {"doc_hash": "f29fb808207bb699df082481e0317d39468f6aa00268641744c3bdcaa640862f", "ref_doc_id": "4f65aa5a-c28e-473a-8ebc-46652cce472a"}, "77f6c88d-5aeb-4e3b-af72-b3a4e0c36520": {"doc_hash": "96b40b581b068a22b6deafc58a7340e8f54506284613bd2e572f814d688b5bd8", "ref_doc_id": "7f23e810-8db4-4937-a758-99e6a5459297"}, "d90c905e-65bd-40d6-a389-b68605888b9a": {"doc_hash": "8d99699af3361ac2460ced1e2a837d56c9583fc3892b6e6cb99904ae613b235b", "ref_doc_id": "49fbf5fc-83f9-461f-9835-416e44914a4c"}, "c2906f00-c702-49c5-b6aa-4ca6f302ad06": {"doc_hash": "0d315b7964f042c9158e162414ffbdd3929f85ddfbbc36754a63847083407160", "ref_doc_id": "076682ff-baaa-4474-8b2d-d2a31e7d0f6e"}, "f589a889-a384-439a-abe4-5ba2370d3a7a": {"doc_hash": "66632541981fa29a441fc994b6901e6975b64810a4b418f580506bd30d8e0233", "ref_doc_id": "802109ea-1595-4395-9f9f-8d08ec973ce6"}, "de1f07df-a9d6-4021-9c3a-9ac6a28e8155": {"doc_hash": "9dfd89ea5d70711f49acb874f3d42c600b389688e16f2390488072b0e41c7aa0", "ref_doc_id": "ec51867a-8144-4cbb-9a1e-cd08f30ea021"}, "47a9ecf0-6a3c-4240-bc0e-28384d17d41c": {"doc_hash": "632eaa893ebbd5be926c7d3e8ef949c9d5196d7c2d52ff21b4b2390b6e30fa1e", "ref_doc_id": "c3f5dd12-57a6-4a0c-a35f-a2c956b303fa"}, "11128841-fc44-4c17-af9d-39e5ee259e26": {"doc_hash": "b3520e6bd8f377d57dc83ad9af78e02a5316b57b07b2915f6e5936a13c855563", "ref_doc_id": "a8f88bf6-abb2-4231-8cbd-de26991d3960"}, "509c8708-14ec-456e-98c7-4e68d50a74ea": {"doc_hash": "8c7ae08c2edaff3b5f97b9d19b81e3b6c11285740ab22d03d5032cab1e3eead5", "ref_doc_id": "cff4897c-4ac5-4f1b-839c-860ae2dc8940"}, "ea400ccf-8c9e-4329-abb4-135793cfc07c": {"doc_hash": "d7a044c82a792f71db0dcec567bb7bda30689e48f5f8cc984e2cc8ad1198cf90", "ref_doc_id": "2191a06e-6b93-4504-a434-41d54402c08a"}, "d8e53a0d-2be6-4956-baee-f5c74efed7ac": {"doc_hash": "1b43d9ad5c45865df2933f943b0fb0e479ee95a6d5ecca5494185fb53f7835fe", "ref_doc_id": "d7b9d93c-ac45-4c8e-bd66-696ebfec0b95"}, "c14c84d0-7db0-4319-98d0-c207622d0da9": {"doc_hash": "999eedbdd685a8442e203167e4fb6630d1cdcdbf35d8242a025e4c0f4b12305a", "ref_doc_id": "0f3b430f-d94e-4094-8987-a82abc37cbef"}, "542ad568-fb21-4d3f-9bef-0d4d1b9aa60e": {"doc_hash": "635677fac13eeacbf68e693a66b6b3a39c4f8f6246ce24e012adf61927807d6b", "ref_doc_id": "c7900d1f-274a-424d-a9e7-9fa10579c4e5"}, "34192754-6eec-4218-988b-e15051ab5a8b": {"doc_hash": "5fc78165d1cac2a2dd85b8db3f61caa5cf72237b48e03324e06f03ac59fea40b", "ref_doc_id": "b6564d06-a3d1-4a35-a6bf-bb075580aca3"}, "8ae2a5aa-8105-4498-9a26-f119ff9b1aae": {"doc_hash": "2c3fdb8b61267f248268bc60b1777908d72de1675b579897e6ed409ce6ab981d", "ref_doc_id": "883da25f-2f2f-4aeb-a855-b3aff3ce6e1a"}, "c8a5c780-3a48-4184-a041-4bc15deaa02c": {"doc_hash": "da47689ae430c7a173f0174a5aa8a4c9706a1cbef17648c85c819e2b59aafbd8", "ref_doc_id": "ed99338a-8f5a-4e52-a126-b188170f8ac3"}, "b16f8589-3d0f-4b12-a9a1-e819eef355e8": {"doc_hash": "8bb05c6610137e1b01a33e7c8f85ffda247c1625c39bb9b305bcc1329acce45c", "ref_doc_id": "d0c9644f-9363-4b47-b654-bab46ffe7129"}, "eed845cf-d032-49ee-a4de-f14c5681ce4c": {"doc_hash": "32277b20febfe9e9b639bf2d4dcf9e96b6cf3fabeecead412e811cfeb15e7dd3", "ref_doc_id": "482a15e4-81de-4ad3-b20d-dc2c329b3546"}, "86bdb7b6-e5e0-4e09-bc8a-1f2c145ed0db": {"doc_hash": "46552998095cf90222329099f31650d9727fc24c6332f5c0834b41b2c3266d1c", "ref_doc_id": "968764ab-bf07-4e25-869e-b2b523b82596"}, "06087d79-6635-4ff4-8b00-95bb65ce74ab": {"doc_hash": "34e0888976643ac033955976d27d1b15098cc913a8af5245f051a9c89e4d9b21", "ref_doc_id": "e8752142-6031-487d-9763-25029c1306c4"}, "b8986a40-b4ec-4895-8823-9cbfbc17b51f": {"doc_hash": "fdbc47f0d94c03505b53f9b3737c810c89f03037c4ced91ac6ee2f7fd0b05890", "ref_doc_id": "33789f51-26a7-4f00-a805-80a0e048d022"}, "d9c62ba4-b423-49ca-bda9-e273e4ec3fce": {"doc_hash": "e60675633c6fc930389d167928048bfa4635a6783ecd6624610d6f1f696c46a7", "ref_doc_id": "844d4de6-5546-48a4-8e19-52ff5f53db1f"}, "5e19f9dd-f373-42e3-85ce-1db4a235fac6": {"doc_hash": "f1429ce3a1f2847b46ab21069b1d1cb95002e339c48e32e192d85587fcca400d", "ref_doc_id": "f7181f86-4f43-4e3c-bd98-fac5bd944c09"}, "2026d110-fc39-43d3-a7c6-31a526f56ed1": {"doc_hash": "518f9d342f30d1bc3498ffbdd766208ee89a5f0760203945368a98593c97088a", "ref_doc_id": "cfc6e13c-a2bd-4544-9f3e-962289387ad9"}, "8aa9936d-b92c-4621-ba4d-a03ceb189c54": {"doc_hash": "69f81427e09ffb4816226f63bc1107ae6775a10dd637da75f05c04dad7af9f53", "ref_doc_id": "ad738fc2-314f-4daf-8323-49459a457289"}, "bbda6786-2b92-43aa-b7fd-0be8905a1359": {"doc_hash": "95edfd747696ca2262e5967bbab956f1de048efcbb4229bbc1273e4038f0699f", "ref_doc_id": "155b8336-3c6a-4660-9090-eca9d4950100"}, "d844cb05-3997-4129-9101-1c5f5deb561c": {"doc_hash": "313cf535692b3b0c99207e75c6d2ba66eb278781869e09cd7745be99024336db", "ref_doc_id": "a1a3ba85-82a9-438d-b0f0-575d72eb6a60"}, "18aed881-87d5-4444-9de9-c759a8fabaec": {"doc_hash": "7960308b8e51e523b0de4dd141c00811062640bac493c305bb21728305a8bcb7", "ref_doc_id": "cfd75abe-704e-449a-a0e8-6b029a54bb2a"}, "f0b38288-8c9d-49c1-9cce-c44bd2d53ab7": {"doc_hash": "5cd8cefcc0cf8d2cc1c557240913b539853a99d36a69d225a4f452270c81417c", "ref_doc_id": "46c8b4e6-3700-44b5-a09f-c2a27d74c433"}, "cfd4409f-967c-4c6b-8c44-f87b5bdb6b3e": {"doc_hash": "ba8dcf0a66feec66c490947b932494958cb5639e08b8e5159e5555c524218649", "ref_doc_id": "e769ceca-6dde-4184-a601-83a332f11aa5"}, "0c92e77e-10d3-4f09-a2c6-c64ac9980110": {"doc_hash": "315cbd13c0a5fe66bba7ad6221013c84041aea1f0d5915234779166758d6d231", "ref_doc_id": "c5cf832c-8969-4bd0-b5a7-e8298744b247"}, "7f812be7-2960-4b6f-a4b6-1288ff41cc31": {"doc_hash": "c70a44204e6a54bd4b95d51bcd5b81224289c4698bd72f7d1680b6d8c61a5e60", "ref_doc_id": "3261e187-a18b-4de0-abc0-e4106d8b878c"}, "65a9e312-cd94-4593-942a-713abbca55c8": {"doc_hash": "e0f5bf598a36228cf90462775ce84e9c28b2163dfc0954f1064949da96d9a66e", "ref_doc_id": "889978af-4efc-4ae5-ac49-3aca7427c233"}, "b86abe7e-e9a9-4dd2-a3d0-4cac5540a238": {"doc_hash": "79fe971c32ced315bc48eadb2152d7ee3bacad24ed852ad5a02f1ec7afa20ecc", "ref_doc_id": "f5b9a272-52f0-46e9-82a7-fc9a7bac64f6"}, "2ba23a71-ba84-44df-80ef-f77226063a15": {"doc_hash": "b345acd422b6369cf438649613221d32b785605c7d87fefa95126e84d1648eb6", "ref_doc_id": "1c039564-05c2-4d21-8f8e-404c80798eaa"}, "81abed72-4db6-4b2d-8fd8-341e62380811": {"doc_hash": "c26b47023473a3b0e6dd1267a156d0e95411a66ee814af5dfa2b6a695c250896", "ref_doc_id": "0c051f7f-aca1-4685-b374-3b3d200d86f2"}, "fc1db42e-a113-47ae-9e8c-fadd92ba4f33": {"doc_hash": "732b58885c9c1907bd464511375b3a5c3fee7efff597f53411030dc3af2f7f62", "ref_doc_id": "9024f802-544f-4a3b-90ec-742cc7fc7c02"}, "b3bc4f64-d1a1-4168-8d72-83dc563f660d": {"doc_hash": "293cc3a94904b36c66bb622a89b0aca8764b1bc20c3d58c3692d5b61b92dee70", "ref_doc_id": "c010ea09-376e-4217-9b2c-d5e95baf2ff7"}, "281a2b78-848f-42f1-8c22-2b0d081ab8ce": {"doc_hash": "81e8bb71779fa9edb0a81445d11bf12e1385fbc2e0da9ee1b4d1d93353c4deb1", "ref_doc_id": "905799e5-769f-4ae3-bac5-391c9b564d86"}, "eb4971e7-97de-4ee2-99c0-825733e27096": {"doc_hash": "8725a968e12367a4d16d9b6c8d0695ff7dcf3ab602af85c44f3c75c294637d65", "ref_doc_id": "c3a8dc9e-e5fc-4420-960e-35e084b0f6de"}, "cf089f90-c956-498a-ba8a-cfc65b208317": {"doc_hash": "25b0caada5b8d0d63340be0efcd361f899bcf8dee560755024d04f314f68a51f", "ref_doc_id": "614bbbac-9060-4071-8078-a73c0aaaf020"}, "e7bba28a-ab03-4471-ac39-ffb4a110f2c4": {"doc_hash": "91f288e17534f435849328517ad1d83acc03e4c8e27e2c51cdb09aca8b724934", "ref_doc_id": "4f82ee2f-9dec-4bbd-85ca-6c164ae4e794"}, "9a9bc81a-59df-43de-af38-fe6c97beedd6": {"doc_hash": "da93de9b25ba17325922835c0df8d1bd3783ebfe76e8e604b09d2484a7c20693", "ref_doc_id": "47c52128-3a12-40af-8840-870dbad382ba"}, "e2ca87d9-08a6-4511-ab9f-7f6bbbf6b094": {"doc_hash": "19c92b39d474e3f04a46b3cf629cb7c6b29b1e8fd1df780436b675fabbf45ccb", "ref_doc_id": "fc0f6a60-0c1a-426f-9825-756c24a702d6"}, "1b709b0a-b58e-4c4b-89b6-d26cb3ca61b8": {"doc_hash": "c741884c1b677c16db805f93c4013cca41d8c45713277de77c5912de879bcecf", "ref_doc_id": "34e9dd64-72e7-40ba-8c05-70c869a1ce6c"}, "f47cac14-aea5-4cdb-8909-c47728ee03a4": {"doc_hash": "f204147ee36df6d8fff2cf193a21329303cd60aafa01324fe66fa72d0bf0bd6e", "ref_doc_id": "bed28dad-2521-4457-84de-5025f3aa9eec"}, "7506bae8-0f48-4cf6-9561-583f5a05b14d": {"doc_hash": "9be9d796151da1f450511a91da6c02c5766655e2b4044f4eaad4086b4cc49243", "ref_doc_id": "746e8702-e1d2-462f-b68b-a2a580c798e2"}, "f749619e-6e28-4835-bee7-1cbb802c44d0": {"doc_hash": "9f0981505a9254655be5cfcb5c505d4c27037b3ae69043b0f0050edae5223f04", "ref_doc_id": "c6c17ada-9385-4879-943c-0dc4cfab4a51"}, "ec04d862-2b1c-43cc-b3d4-3ae07749c72d": {"doc_hash": "7c17838ab0186223114f8536d0464629f1c1df635ff43b976f0077bc58763274", "ref_doc_id": "838f266c-8f34-48d1-9a8a-9b66a0cf9807"}, "a6974ac0-2dc0-405b-a97a-75d472007a6c": {"doc_hash": "b00ce22cc02034c1bfecff26ebb4537709286c76900947fc150b59092f822c8d", "ref_doc_id": "6a869f76-60de-41ad-88ed-b1c56945f82e"}, "a7dd9efe-df6a-4145-aec3-9537ce37b2f9": {"doc_hash": "9b2574d4cdec28cd6eea7bc86e3409aea3490b3493f861f1e9dd576ce89a070e", "ref_doc_id": "26c61b21-edd2-45bc-9302-7081e47f61e4"}, "5769d982-3672-4ad5-b18b-61e32c18521c": {"doc_hash": "4855023ecb36b6e96ce1305286f7a45603c8da24433b38ef1ad5b19113400f4d", "ref_doc_id": "8a53a2ad-3546-4d7f-9e2b-f254537ebc76"}, "e8eda7f7-09e2-468b-ad0a-a2065f1d5a72": {"doc_hash": "7cecc91dc02076e7846394a2bf44a7383d627aff4ffceedc340c3a0152c53bb3", "ref_doc_id": "4611c81c-c88f-440d-90c7-669b6d7d25df"}, "08964ac0-b99d-4d3a-adc6-91e69049df93": {"doc_hash": "2fc199e7c996636ed2511be3aad86917b278a83c1086976932ed6d773340eddb", "ref_doc_id": "70df3869-c245-40bb-a93b-1c25436bae83"}, "ed8dddbb-7892-43b0-a92f-ec3b00e55259": {"doc_hash": "ea56ee3e8fe2accdce24347d3b612b8b9d7393bfa7e2b9dac0242a40d24ceab8", "ref_doc_id": "ff4d22b3-bf1c-4586-8d64-256ff1110ea5"}, "2865d37f-2bc8-478d-be59-0a91b6064bdb": {"doc_hash": "52c7ea90cc7cef7154f57dcb36719ebe8c1fb8df2f17eeeb1ad6a14bbd128abf", "ref_doc_id": "f6d69a42-c29f-479a-817e-23f51227b364"}, "e3848f5b-f0bf-4697-8554-1426b28d8dc3": {"doc_hash": "5a8c4fd995bcdfad33637c10b6748fa2aafac6b5e2b38dd4c67b5d52e8c98495", "ref_doc_id": "30e7205f-3ac3-4711-b58f-811ffe6f0be0"}, "5553d4a7-8070-4348-8d2d-56d348eafa97": {"doc_hash": "eff23119b6cc04464b868f5bf9eebe89b1482e50d3553fcab6a4094aea1b6c71", "ref_doc_id": "0dd0c550-a44a-4b85-9edf-4593ea71542e"}, "b20367da-475b-4d5a-ba5b-0f0e9aa19585": {"doc_hash": "84c27adfd47d6b30572ab2f20f44189f4de5b2267e478c4377c31cb305b74ffe", "ref_doc_id": "70658702-f82c-42d4-ad07-e53301c7e050"}, "e329b516-3702-40e7-a848-845b2746b58a": {"doc_hash": "02f344b31decc71e666f2d7cb810f9690727189191ad270ea4b8f4f0dac4160c", "ref_doc_id": "5069b1f4-1d39-41c0-8e17-767d13722f84"}, "b87d5ee2-641a-4316-b981-c22682295bd3": {"doc_hash": "245515ce175caffb4a332e38bc1e247e4b4f19bfd0260f75cfa40ef384396207", "ref_doc_id": "6858ba3d-159f-44ef-b661-651263c7e3b5"}, "6ab665b3-0d0b-41c4-9a8a-7bc2452bfa45": {"doc_hash": "8a7149d7920f5fe75ed7f2f16f93a95d750edcb3522b50be8a4d0275124b66f5", "ref_doc_id": "7a739bd0-22f9-4e85-a4f9-0646e4800563"}, "0fd0fb93-8547-40e8-abe2-fe7444b3bfc8": {"doc_hash": "71601779c06807860f409e6fb71f55c7a843ad2754b222aa4f35e963e6ae8da2", "ref_doc_id": "e68fa4c5-c89a-414e-bb92-2820e59103a9"}, "6c8c11a5-9335-4296-854e-d38f77889450": {"doc_hash": "3435eece8fac210228db79b79d196cf98e619e06a9cb81b56dfb063f63b68a30", "ref_doc_id": "dbeabe24-38d9-4ff1-8221-db3589a23fb3"}, "9a59bcf2-1690-42c4-a3ee-dcdc6a07eb1e": {"doc_hash": "4e7d5d4ab44f181a9d5aa7ef7f20fdb1ae28e19016d2d95efdaa5e8e1670a257", "ref_doc_id": "b255843f-1d69-4fbe-a89f-d4fb76cfc6c3"}, "ef4d6e32-ee49-40da-8ea6-de0126ebc7cc": {"doc_hash": "115612a7613b80e379701d4b36071330853ce083584a2cf6a31d602081168547", "ref_doc_id": "5342c86e-c4f6-4594-9a01-ecb17f9b248b"}, "04270f5b-207f-46eb-93c7-f761b3db6743": {"doc_hash": "3d9aa71f77b4ef63cdb40777e0ae58fee5718e93d2634d9fdc77a4fe79f28dd4", "ref_doc_id": "50788a88-2280-4b4e-b0d3-30e0cabc936c"}, "435b4035-f184-4fe5-8a29-79c637b3c590": {"doc_hash": "8ca851a00e0642a01eb2b0a1204d60a3b6b25245f9b22976753ccdbb7a72cf62", "ref_doc_id": "93db66c9-b14f-40ed-bcb4-cf5710d62d8f"}, "b37fec70-4122-4ccb-b0d4-83715c08b2e3": {"doc_hash": "7c84d722047b238ad0ec19518063e6d27618153a0b02387507c3536843da9e79", "ref_doc_id": "4b52f1c5-74b9-4641-8048-2a73c819321d"}, "9871f313-e4c1-4c77-8b12-6e1c5f7943b5": {"doc_hash": "4fcac2d4e2c15092a36e49cc27ac523de220b392a720ca6fc95f44f986021720", "ref_doc_id": "e931c90e-c109-435e-80f4-63f676108ddd"}, "abf92290-8f8b-459d-8900-f4ae73097e04": {"doc_hash": "f4ca76cbff206c9dd5ebbff50639952e64b74e19049f74c0f7fd4433bd060067", "ref_doc_id": "141dfc70-0054-487b-ba69-abaa0c4c07bf"}, "17b69e14-978a-439f-964b-173695a81a68": {"doc_hash": "ed06526524ee77ca8858802597fe4e45a0c3f16816faa888f33c10340eb31ad2", "ref_doc_id": "6a1bd7c6-3f1c-40ef-8f7a-8ecb8a6d117e"}, "54bb80c8-d30b-408b-b3ed-efd1b50e5502": {"doc_hash": "dbd87a19865f10f58fd2a1a3c527f7df7ba133af1c9e9c75135417d2501ade6a", "ref_doc_id": "d7b2d760-9668-494a-8e8f-af6f7c53f00b"}, "60de55e1-e51e-4b81-8ea7-946d54350255": {"doc_hash": "c342fd663507851858c584c85491be4a8a36d7edf99382043d05c55a94c204b0", "ref_doc_id": "bb094c39-8be6-40ed-9575-dfb2ca8e9cfb"}, "bea2fead-015b-49a8-9613-f57bc9165a89": {"doc_hash": "1d35b5e0f08679bf67029c6476a3228c5a24550b7e898255503bb6a12b8540eb", "ref_doc_id": "09bfd729-7e4c-4dc6-8c49-4e6bd9f34a97"}, "d9134d78-b28b-49a1-8779-cad4bc172302": {"doc_hash": "cbf79c061f4210c8132c991e9d9526d36856d9691e7fa348e51445e6d6ba8fa0", "ref_doc_id": "796abaf7-a83b-4a50-8494-12b9a0b3f009"}, "35fb3914-4223-437c-a1c1-89bf3d3aa68e": {"doc_hash": "e7dc706de69993114be8953c758f9d052ad8e275d611ccf8199f54a0c8a26f9b", "ref_doc_id": "0a76efa1-c7ee-4930-99e2-6295784ad09e"}, "bbfe787b-8334-4aef-8b19-4d57d7ef6e3a": {"doc_hash": "7728eae40165a0bddac4c6180877bc43f1a98cb159338004691090057bf29833", "ref_doc_id": "5854b555-e73c-4661-ac22-519badc131ce"}, "bc3cbcdc-b8cb-4433-ba0d-1cfeabfb28da": {"doc_hash": "6c89b6aab13b619305252d0ed54a3f777a5018e679d804b7375f7b7ae36aafb2", "ref_doc_id": "e9276e96-4fea-4383-a464-5876d3bcfa28"}, "8dde49a8-13cc-4270-a51c-4c08049909b7": {"doc_hash": "d915a93bb5961fbca659629f8bdd3ab9ddb554ee60f3f0c39d8611f7b6cd3747", "ref_doc_id": "3890bc5e-c149-4fab-8844-d6444f43e232"}, "f8e15691-4060-401a-953b-67af8d6a64e4": {"doc_hash": "69633c79aecfc4bf14f576704bc9e43bb0da6cf73cdf4d30e50384bc8cb9d50f", "ref_doc_id": "0f4062a4-9e47-4ce5-82a8-7b871e60bea0"}, "bba7c29d-2ea1-411f-be51-3d4b357d4d29": {"doc_hash": "9c98bfa5db70b433c4a86a1012834b266b38a9f518722d0082962a58d621ab5b", "ref_doc_id": "2dff44f0-219e-48ff-9041-a33b8a37d2ee"}, "cd97072e-0bb0-4f90-a57b-c86930656291": {"doc_hash": "f2f6cff2db2005785659a22bf782766132e58d165bffa071710676966b8dec82", "ref_doc_id": "2b9f704a-3e4b-4d63-84e2-84310f2675b8"}, "4672f06b-ba93-4364-84f8-9d706787bdde": {"doc_hash": "240916a63e69e81240ca9c6098dc34f7980ad901e6985b9a9b47964a821b632a", "ref_doc_id": "20cbb7c1-cc96-4ad3-8ff3-e25288a11f87"}, "1d969a9f-492b-4650-a18f-eec48cfd03d2": {"doc_hash": "341cba8ddd98c6f4874478de69031508bb06e47322258556ef748c30b6327f52", "ref_doc_id": "a610f46e-cbbf-4f5a-9b4e-9ee79ae31d36"}, "b468cc24-15df-4797-840e-bbb3ee659919": {"doc_hash": "d792c298c56a42676c015c6c1ec833ea05209651052341e27f099eb460fac3c6", "ref_doc_id": "0307de24-6a4c-41cf-8b56-e1aea18f578c"}, "a6ee7a9a-e4b5-4943-a916-c97bb8e152b2": {"doc_hash": "c03bfe9b09227a07cbde801288af58ada07e9146ca75cf0f7c17145c3ac3a7fe", "ref_doc_id": "cc6d33e0-1200-4bef-9303-05d032d40d90"}, "5db8e253-aa58-4f03-a325-d88580aac457": {"doc_hash": "bb04ebbfb3351d07265a0f0a9890a8876fbedee8f21be43c6f929fdea5f3571f", "ref_doc_id": "7395be4c-cb51-4d67-867a-6154e39a6151"}, "7707a09e-f561-4f4e-a488-e896c0bd021c": {"doc_hash": "b08d7418aeb750d06eeb36544478df340459cc0ee415cfcb5bd7f0085f185ea9", "ref_doc_id": "994b4c38-83a4-4c99-8386-b634332dbcfa"}, "618365eb-7831-4fee-b96d-d49720a0f8a8": {"doc_hash": "61984d667c292a4bc729181dde9ff426d76067dde7465b2952b778ebe292f947", "ref_doc_id": "0823693c-ea54-4e40-98f4-ee062c4d3b7c"}, "da6bdc19-c30c-4e76-a483-316b61143905": {"doc_hash": "68bed4aaebbb43576c1e6cd54dbb5085511a2268e591de74b553a836f249541e", "ref_doc_id": "a11be51c-c7c1-4050-8bd8-ee8f478a7109"}, "3e46a656-60fd-4686-82fa-3ff9b95706b8": {"doc_hash": "796a01e752556b1d53016061a7121c6c3921bd28a0f79a687dabc24bbf92eccb", "ref_doc_id": "41e8389e-9056-4db3-aabc-7101af07b372"}, "738c18ff-7e08-46a8-9fc3-c257f2e370f3": {"doc_hash": "8d7af74be629dbae1a00e47d8898fcb9aaade9b29451483b626d8929e61f61e8", "ref_doc_id": "488a1e20-70b7-442a-ba09-c1b234618e5e"}, "3c213e4a-a2ec-4b29-9f05-7ed77e2d7ed8": {"doc_hash": "b1c98710b29948800cb0d60b61ba10d9ef3efb7e49e218fef714655aa5e43539", "ref_doc_id": "9efe6404-82a3-4af7-8203-65ebb280dfd8"}, "a4392b60-3f95-4521-9ad3-8b52dc627c86": {"doc_hash": "afacbcfe4416ea866e12ee38531455074ed0e57993f0ac49fb31d711c6e448fa", "ref_doc_id": "15c74424-8f12-4162-9180-6fbd21284850"}, "5afd04b2-3893-4d3d-bcde-a06dbdc4e3ff": {"doc_hash": "80821463854a482d03f832bfcbd18097fda092b29822bb8736ff9864da0094e5", "ref_doc_id": "35c4e781-aee3-4688-a2ea-2b75da09a5ce"}, "66d34a3a-f51e-4dcf-b049-b88de6d02bff": {"doc_hash": "2fa0cfe91789c31b0c396004419950e6bf7498fec5652877c5ff92032d323884", "ref_doc_id": "3323c86c-d8ea-4a1b-b619-905945b89771"}, "8af7c035-1d3e-475c-bfe2-90c04e25145e": {"doc_hash": "a8738e489fd02c3e487e1bd0e1470516efcf3a3dc34d65e81fd336abcc5558b5", "ref_doc_id": "b7dcb9b2-58b4-438c-8f68-dc78c7846e5e"}, "0f8f1865-989b-433e-8cc5-6b261fd7f023": {"doc_hash": "9359471661eea66c04c8cb516df9e52665004e8835443901dd07a58d95e9cf93", "ref_doc_id": "529b6c59-00b2-49b2-8f78-9c6f8a599516"}, "6fd13afb-fd96-4db4-8d61-9ead203607c2": {"doc_hash": "905ecae6091a9c6d8a59a86b5838576f97cf7b77b1849cbdff3e3ecc835a7fc2", "ref_doc_id": "e6b9c5a7-76aa-4b07-bb00-182bb17f2260"}}, "docstore/data": {"7ffe0d6e-0824-4b30-832e-da3aef08a3ff": {"__data__": {"id_": "7ffe0d6e-0824-4b30-832e-da3aef08a3ff", "embedding": null, "metadata": {"page_label": "1", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b84895b9-6f90-4975-9e13-02044300f26a", "node_type": "4", "metadata": {"page_label": "1", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c03ea23331fe0c61782f942e12b5b509f0de5593869898f43bab2318222d3aeb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "602d80fc-d4ab-40de-8af1-19ab3c85fc7a", "node_type": "1", "metadata": {}, "hash": "e28dab464e502978c98edd3652c00bc0697a912c3d3c52d584d19f2d50a79a47", "class_name": "RelatedNodeInfo"}}, "text": "De v elopment\nGuide\nLearning\nObjectiv es\nT h e\nl e a r n i n g\no b j e c t i v e s\nf o r\nD e v e l o p m e n t\nG u i d e\na r e :\n\u25cf\nU s i n g\nt h e\nt o o l s\nn e e d e d\nf o r\nC S\n3 4 1\nDe v elopment\nin\nCS\n341\nI n\nt h i s\nc o u r s e ,\nw e\nu s e\nV i r t u a l\nM a c h i n e s\n( V M s )\nf o r\na l l\no u r\nd e v e l o p m e n t .\nW e\nw i l l\nn o t\ns u p p o r t\nd e v e l o p m e n t\ni n\na n y\no t h e r\ne n v i r o n m e n t\n( e . g .\nE W S ) .\nW e\nw o u l d\nl i k e\nt o\ns t r e s s\nt h a t\nn o\nm a t t e r\nw h a t\nm e t h o d\ny o u\nu s e\nt o\nd e v e l o p\nc o d e\nf o r\nC S\n3 4 1 ,\nt e s t\na l l\ny o u r\n\ufb01 n a l\nc o d e\no n\ny o u r\nV M .\nT h e\na u t o g r a d i n g\ne n v i r o n m e n t\ni s\ns i m i l a r\nt o\ny o u r\nV M .\nT h u s\ne v e n\nt h o u g h\ny o u r\nc o d e\n\u201c w o r k s \u201d\no n\ny o u r\nm a c h i n e ,\ni t\nm a y\nn o t\nw o r k\no n\nt h e\nV M s\na n d\nt h u s\nf o r\nt h e\na u t o g r a d e r .\nConnecting\nt o\ny our\nVM\nF o r\na l l\nr e g i s t e r e d\ns t u d e n t s\ni n\nt h e\nc o u r s e ,\ny o u\nw i l l\nr e c e i v e\na\nV M\ni n\nt h e\nC S\nD e p a r t m e n t \u2019 s\nV M\nF a r m\np r o v i s i o n e d\nb y\nE n g r I T .\nW h e n\ny o u r\nV M\ni s\np r o v i s i o n e d\ny o u\ns h o u l d\nr e c e i v e\na n\ne m a i l\na b o u t\ny o u r\nV M .\nI f\ny o u\nr e g i s t e r e d\nl a t e ,\np l e a s e\ne m a i l\nt h e\nC S\n3 4 1\nA d m i n\n( y o u\nc a n\n\ufb01 n d\nt h e\ne m a i l\no n\no u r\ns t a f f\np a g e\n) .\nA p p r o x i m a t e l y\n1 2 - 2 4\nh o u r s\na f t e r i n g\nr e g i s t e r i n g\nf o r\nt h e\nc o u r s e\ny o u r\nV M\nh o s t\nn a m e\ns h o u l d\na l s o\nb e\no n\nt h i s\np a g e\n-\ns o\nt h a t \u2019 s\na n o t h e r\nw a y\nt o\nl o o k u p\ny o u r\nV M\nn a m e . ( V P N\nn e e d e d ) .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1668, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "602d80fc-d4ab-40de-8af1-19ab3c85fc7a": {"__data__": {"id_": "602d80fc-d4ab-40de-8af1-19ab3c85fc7a", "embedding": null, "metadata": {"page_label": "1", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b84895b9-6f90-4975-9e13-02044300f26a", "node_type": "4", "metadata": {"page_label": "1", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c03ea23331fe0c61782f942e12b5b509f0de5593869898f43bab2318222d3aeb", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7ffe0d6e-0824-4b30-832e-da3aef08a3ff", "node_type": "1", "metadata": {"page_label": "1", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8e0f4937b0e3b614bc06ae824fe9fa35435c639b4b0704a469bbf4b59bac468a", "class_name": "RelatedNodeInfo"}}, "text": "A p p r o x i m a t e l y\n1 2 - 2 4\nh o u r s\na f t e r i n g\nr e g i s t e r i n g\nf o r\nt h e\nc o u r s e\ny o u r\nV M\nh o s t\nn a m e\ns h o u l d\na l s o\nb e\no n\nt h i s\np a g e\n-\ns o\nt h a t \u2019 s\na n o t h e r\nw a y\nt o\nl o o k u p\ny o u r\nV M\nn a m e . ( V P N\nn e e d e d ) .\nO n c e\ny o u\nh a v e\nr e c e i v e d\ny o u r\nV M ,\ny o u\nc a n\nc o n n e c t\nt o\ny o u r\nV M\nv i a\nS S H .\nI f\ny o u\na r e\nn o t\no n\nt h e\nc a m p u s\nn e t w o r k\ny o u\nw i l l\nn e e d\nt o\ni n s t a l l\na n d\nu s e\nt h e\nc a m p u s\nV P N .\nT h e\nV M\nn u m b e r\nw i l l\nb e\ni n c l u d e d\ni n\nt h e\ne m a i l\ny o u\nr e c e i v e d .\nO n\nL i n u x\n/\nM a c ,\ny o u\nc a n\nd o\ns o m e t h i n g\nl i k e", "mimetype": "text/plain", "start_char_idx": 1389, "end_char_idx": 2072, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "871adc23-b7b6-43bd-9349-bb5c72464e91": {"__data__": {"id_": "871adc23-b7b6-43bd-9349-bb5c72464e91", "embedding": null, "metadata": {"page_label": "2", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "076fe90a-05da-43e4-88f6-01ba95c8d719", "node_type": "4", "metadata": {"page_label": "2", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "449d3e04e4f878a48909597de588cd24e3e867f663af472ffcc426fd0be2b99d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0639d255-56c4-4ac2-978d-ac20e39c47c4", "node_type": "1", "metadata": {}, "hash": "800bf9e589df18740308789a4f7f45c3b3dbef5d13316942fba9fb481b66bdad", "class_name": "RelatedNodeInfo"}}, "text": "$\nssh\n<NETID>@fa24-cs341-<NUM>.cs.illinois.edu\nO n\nW i n d o w s ,\ny o u\nc a n\nu s e\na n\nS S H\nc l i e n t\nl i k e\nP u T T Y\n.\nN o t e\nt h a t\ni f\ny o u\na r e\nn o t\nc o n n e c t e d\nt o\no n - c a m p u s\ni n t e r n e t ,\ny o u\nw i l l\nn e e d\nt o\nu s e\na\nV i r t u a l\nP r i v a t e\nN e t w o r k\n( V P N )\nt o\nc o n n e c t\nt o\ny o u r\nV M .\nI n s t r u c t i o n s\no n\nd o w n l o a d i n g\na n d\nu s i n g\nt h e\nU I U C\nV P N\nc a n\nb e\nf o u n d\nh e r e\n.\nA n\na l t e r n a t i v e\nt o\nu s i n g\nt h e\nU I U C\nV P N\ni s\nt o\nS S H\nt w i c e .\nY o u\nc a n\n\ufb01 r s t\nS S H\ni n t o\ny o u r\nE W S\na c c o u n t\na n d\nt h e n\ni n t o\ny o u r\np e r s o n a l\nV M .\nJ u s t\nr e m e m b e r\nt h a t\nt h i s\nc a u s e s\np o t e n t i a l l y\nd o u b l e\nt h e\nn e t w o r k\nl a g !\nA d d i t i o n a l l y ,\nm a k e\ns u r e\ny o u r\nV M\ni s\no n\na n d\nr u n n i n g ,\nw h i c h\nc a n\nb e\nd o n e\na t\nt h e\nV M\nd a s h b o a r d\n.\nU s e\nt h i s\np a g e\nt o\nl o o k u p\ny o u r\nV M\nn a m e\ni f\nn e e d e d .\nN o t e :\nB o t h\no f\nt h e\na b o v e\nl i n k s\na l s o\nr e q u i r e\nc a m p u s\nw i \ufb01\no r\na\nV P N\nSetting\nUp\nGit\nY o u\nw i l l\nb e\nu s i n g\ngit\nt o\ns u b m i t\na l l\ny o u r\na s s i g n m e n t s\ni n\nt h i s\nc o u r s e .\nF i r s t\ng o\nt o\nt h e\nr e p o s i t o r y\nc r e a t o r\n.\nCon\ufb01guring\nGit\nO n c e\ny o u\na r e\ni n\ny o u r\nV M\n,\ny o u \u2019 l l\nn e e d\nt o\ns e t\nu p\ns o m e\ng l o b a l\nd e f a u l t s .\nT h e\nn a m e\na n d\ne m a i l\ny o u\ni n p u t\nh e r e\nw i l l\nb e\nu s e d\nt o\nm a r k\ny o u r\nc o m m i t s .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1516, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0639d255-56c4-4ac2-978d-ac20e39c47c4": {"__data__": {"id_": "0639d255-56c4-4ac2-978d-ac20e39c47c4", "embedding": null, "metadata": {"page_label": "2", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "076fe90a-05da-43e4-88f6-01ba95c8d719", "node_type": "4", "metadata": {"page_label": "2", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "449d3e04e4f878a48909597de588cd24e3e867f663af472ffcc426fd0be2b99d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "871adc23-b7b6-43bd-9349-bb5c72464e91", "node_type": "1", "metadata": {"page_label": "2", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f61fe1fdcdad42761a20eff3e32cce61f8505569165bcab330fef0f068bbe97f", "class_name": "RelatedNodeInfo"}}, "text": "F i r s t\ng o\nt o\nt h e\nr e p o s i t o r y\nc r e a t o r\n.\nCon\ufb01guring\nGit\nO n c e\ny o u\na r e\ni n\ny o u r\nV M\n,\ny o u \u2019 l l\nn e e d\nt o\ns e t\nu p\ns o m e\ng l o b a l\nd e f a u l t s .\nT h e\nn a m e\na n d\ne m a i l\ny o u\ni n p u t\nh e r e\nw i l l\nb e\nu s e d\nt o\nm a r k\ny o u r\nc o m m i t s .\ngit\nconfig\n--global\nuser.name\n\"FIRST_NAME\nLAST_NAME\"\ngit\nconfig\n--global\nuser.email\nNETID@example.com\nM a k e\ns u r e\nt o\nr e p l a c e\nFIRST_NAME\na n d\nLAST_NAME\na n d\nNETID@example.com\nw i t h\ny o u r\ni n f o r m a t i o n .\nF o r\ne x a m p l e :\ngit\nconfig\n--global\nuser.name\n\"Lawrence\nAngrave\"\ngit\nconfig\n--global\nuser.email\n\"angrave@illinois.edu\"\nCloning\ny our\ncourse\nr eposit or y\nC h e c k o u t\ny o u r\nr e p o s i t o r y\na s\nf o l l o w s :", "mimetype": "text/plain", "start_char_idx": 1222, "end_char_idx": 1967, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e99898fa-794f-44e5-b667-999a2b6f5431": {"__data__": {"id_": "e99898fa-794f-44e5-b667-999a2b6f5431", "embedding": null, "metadata": {"page_label": "3", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1e5f4b71-4211-4934-bab2-20839a1eaf52", "node_type": "4", "metadata": {"page_label": "3", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4a6441e3523da7c0af75dbd5bb631dec4a37ce8f4512baf95de4a249c5bc6482", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "31611764-f065-42ac-a804-c800eba90d2c", "node_type": "1", "metadata": {}, "hash": "4fca9c8a6462c3de42b85da1cf4badab567447aff9cce0ce27662400ca52aa0b", "class_name": "RelatedNodeInfo"}}, "text": "git\nclone\nhttps://github.com/illinois-cs-coursework/fa24_cs341_NETID.git\nU n f o r t u n a t e l y ,\nc l o n i n g\na\nr e p o s i t o r y\ni s\nn o t\ns o\ne a s y .\nI f\ny o u\nf o l l o w\ng i t \u2019 s\np r o m p t\na n d\ns u b m i t\ny o u r\nu s e r n a m e\na n d\np a s s w o r d ,\ny o u\nw i l l\nl i k e l y\ns e e\na n\ne r r o r\nm e s s a g e\nl i k e\nt h e\nf o l l o w i n g .\nI f\ns o ,\nc o n t i n u e\nt o\nt h e\ni n s t r u c t i o n s\ni n\nA u t h e n t i c a t i n g\nw i t h\nG i t H u b\n.\nremote:\nSupport\nfor\npassword\nauthentication\nwas\nremoved\non\nAugust\n13,\n2021.\nremote:\nPlease\nsee\nhttps://docs.github.com/en/get-started/getting-started-with-git/about-remote-re\npositories#cloning-with-https-urls\nfor\ninformation\non\ncurrently\nrecommended\nmodes\nof\nauthentication.\nfatal:\nAuthentication\nfailed\nfor\n'https://github.com/illinois-cs-coursework/fa24_cs341_NETID.git'\nA uthenticating\nwith\nGitHub\nT h e r e\na r e\nt h r e e\nw a y s\nt h a t\nw e\nr e c o m m e n d\nf o r\na u t h e n t i c a t i n g\nw i t h\nG i t H u b\nOption\n1:\nUsing\nSSH\nk e ys\n1 .\nC r e a t e\na n\nS S H\nk e y\no n\ny o u r\nV M .\nC u r r e n t l y ,\nw e\nr e c o m m e n d\nt h e\nE d D S A\nk e y\na l g o r i t h m .\nY o u\nc a n\nc r e a t e\na n\nE d D S A\nk e y\nw i t h\nt h e\nc o m m a n d\nssh-keygen\n-t\ned25519\n-a\n100\n.\nT h i s\nc o m m a n d\ng e n e r a t e s\na\np r i v a t e\na n d\np u b l i c\nk e y\ni n\nt h e\nd i r e c t o r y\n~/.ssh\n,\nw h e r e\n~\nd e n o t e s\ny o u r\nh o m e\nd i r e c t o r y .\nI t\nw i l l\np r o m p t\ny o u\nt o\ne n t e r\na\nn a m e\nf o r\nt h e\n\ufb01 l e\ns t o r i n g\ny o u r\np r i v a t e\nk e y ,\na n d\nw i l l\ng e n e r a t e\na\n. p u b\n\ufb01 l e\nf o r\ny o u r\np u b l i c\nk e y .\nI t \u2019 s\nn o t\nn e c e s s a r y\nt o\ne n t e r\na\np a s s w o r d\nf o r\nt h e\nk e y .\n2 .\nC o p y\nt h e\np u b l i c\nk e y\nt o\ny o u r\nc l i p b o a r d .\nT h i s\ni s\nu s u a l l y\ns t o r e d\na t\na\np a t h\nl i k e\n~/.ssh/*.pub\n,\nw h e r e\n~\nd e n o t e s\ny o u r\nh o m e\nd i r e c t o r y .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1926, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "31611764-f065-42ac-a804-c800eba90d2c": {"__data__": {"id_": "31611764-f065-42ac-a804-c800eba90d2c", "embedding": null, "metadata": {"page_label": "3", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1e5f4b71-4211-4934-bab2-20839a1eaf52", "node_type": "4", "metadata": {"page_label": "3", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4a6441e3523da7c0af75dbd5bb631dec4a37ce8f4512baf95de4a249c5bc6482", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e99898fa-794f-44e5-b667-999a2b6f5431", "node_type": "1", "metadata": {"page_label": "3", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "81430c967c20ea72148d8d1d5757ad02f632ed86b18e5b93c881d97f429cd945", "class_name": "RelatedNodeInfo"}}, "text": "p u b\n\ufb01 l e\nf o r\ny o u r\np u b l i c\nk e y .\nI t \u2019 s\nn o t\nn e c e s s a r y\nt o\ne n t e r\na\np a s s w o r d\nf o r\nt h e\nk e y .\n2 .\nC o p y\nt h e\np u b l i c\nk e y\nt o\ny o u r\nc l i p b o a r d .\nT h i s\ni s\nu s u a l l y\ns t o r e d\na t\na\np a t h\nl i k e\n~/.ssh/*.pub\n,\nw h e r e\n~\nd e n o t e s\ny o u r\nh o m e\nd i r e c t o r y .\nY o u\nc a n\np r i n t\no u t\nt h e\np u b l i c\nk e y\nt o\nt h e\nt e r m i n a l\nw i t h\nt h e\ncat\nc o m m a n d .\n3 .\nL o g\ni n t o\ny o u r\nG i t H u b\na c c o u n t ,\nn a v i g a t e\nt o\nS e t t i n g s - > S S H\nK e y s ,\na n d\nf o l l o w\nt h e\np r o m p t s\nt o\na d d\na\nn e w\nS S H\nk e y\nb y\np a s t i n g\ni n\nt h e\np u b l i c\nk e y\no n\ny o u r\nc l i p b o a r d .\nP l e a s e\nk e e p\ni n\nm i n d\nt h a t ,\nw h e n\nu s i n g\nt h i s\nm e t h o d ,\ny o u\nw i l l\nn e e d\nt o\nu s e\nS S H\np r o t o c o l\nU R L s\n( e . g .\ngit@github.com:<repo>\n) ,\nn o t\nH T T P S\np r o t o c o l\nU R L s\n( e . g .\nhttps://github.com/<repo>\n)\n.\nOption\n2:\nUsing\nthe\nGH\nA uth\nt ool", "mimetype": "text/plain", "start_char_idx": 1592, "end_char_idx": 2589, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec4aee05-21e3-4da7-b065-9af72dd1015a": {"__data__": {"id_": "ec4aee05-21e3-4da7-b065-9af72dd1015a", "embedding": null, "metadata": {"page_label": "4", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "02d81911-24f6-4111-acfd-138239bfe6e3", "node_type": "4", "metadata": {"page_label": "4", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3ec433fff59e644fb657350aac7e5f904f1fd6520705865e8eb915a483487eee", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b34259db-7339-46e8-b9da-91543f6072d2", "node_type": "1", "metadata": {}, "hash": "f0902ebc9a29ed32e2a7a439c83f3b2ff69f134a76289bfdf230ed7343575b44", "class_name": "RelatedNodeInfo"}}, "text": "G i t H u b\np r o v i d e s\nt h e i r\no w n\nc o m m a n d\nl i n e\nt o o l\nf o r\na u t o m a t i n g\nt a s k s ,\ni n c l u d i n g\na u t h e n t i c a t i o n .\nT h e\nr e l e v a n t\nd o c u m e n t a t i o n\nf o r\nt h e\nt o o l\nc a n\nb e\nf o u n d\nh e r e\n.\nI n\ns u m m a r y :\n1 .\nI n s t a l l\nt h e\ngh\nt o o l\nu s i n g\nsudo\napt\nupdate\n&&\nsudo\napt\ninstall\ngh\n.\n2 .\nR u n\ngh\nauth\nlogin\nt o\na u t h e n t i c a t e .\nOption\n3:\nUsing\na\nP ersonal\nAccess\nT ok en\nY o u\nc a n\nt h i n k\no f\na\np e r s o n a l\na c c e s s\nt o k e n\na s\na\np a s s w o r d\nw i t h\nl i m i t e d\np r i v i l e g e s\na n d\na n\ne x p i r a t i o n\nd a t e .\nT o\nc r e a t e\na\nt o k e n ,\ng o\nt o\nG i t h u b\ns e t t i n g s\n,\na n d\nc l i c k\nG e n e r a t e\nn e w\nt o k e n\n( c l a s s i c )\n.\nW e\nr e c o m m e n d\no n l y\ng i v i n g\ny o u r\nn e w\nt o k e n\nr e p o\ns c o p e ,\na s\nt h a t\ni s\na l l\ny o u\nn e e d\nt o\np u s h\na n d\np u l l\nf r o m\ny o u r\nr e p o .\nO n c e\nt h e\nt o k e n\ni s\ng e n e r a t e d\n( b e\ns u r e\nt o\ns a v e\ni t\ns o m e w h e r e ) ,\ny o u\nm u s t\na u t h o r i z e\nt h e\nt o k e n\nf o r\nu s e\nw i t h\nI l l i n o i s\nS i n g l e\nS i g n - O n\n( S S O ) .\nS e e\nG i t H u b \u2019 s\nd o c s\nh e r e\n.\nF i n a l l y ,\ny o u\nc a n\nr u n\ngit\nclone\na g a i n\na n d\nu s e\ny o u r\nn e w l y\ng e n e r a t e d\nt o k e n\ni n\np l a c e\no f\ny o u r\np a s s w o r d .\nI f\ny o u \u2019 r e\nu s i n g\nV S C o d e ,\ny o u\nm a y\nn e e d\nt o\nl o g\no u t\no f\nG i t h u b\ni n\nV S C o d e\n( U s i n g\nA c c o u n t s\nb u t t o n\na t\nb o t t o m\nl e f t )\na n d\nl o g i n\na g a i n .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1558, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b34259db-7339-46e8-b9da-91543f6072d2": {"__data__": {"id_": "b34259db-7339-46e8-b9da-91543f6072d2", "embedding": null, "metadata": {"page_label": "4", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "02d81911-24f6-4111-acfd-138239bfe6e3", "node_type": "4", "metadata": {"page_label": "4", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3ec433fff59e644fb657350aac7e5f904f1fd6520705865e8eb915a483487eee", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ec4aee05-21e3-4da7-b065-9af72dd1015a", "node_type": "1", "metadata": {"page_label": "4", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c4e8350027a6d509fe8a99bff013f2efc783d6c41e07c42e7f726dbe0a7801c9", "class_name": "RelatedNodeInfo"}}, "text": "I f\ny o u \u2019 r e\nu s i n g\nV S C o d e ,\ny o u\nm a y\nn e e d\nt o\nl o g\no u t\no f\nG i t h u b\ni n\nV S C o d e\n( U s i n g\nA c c o u n t s\nb u t t o n\na t\nb o t t o m\nl e f t )\na n d\nl o g i n\na g a i n .\nF etching\nfr om\n_release\nC h a n g e\ny o u r\nd i r e c t o r y\ni n t o\ny o u r\nr e p o\nf o l d e r :\ncd\nfa24_cs341_NETID\nY o u \u2019 v e\np r o b a b l y\nn o t i c e d\nt h e\nr e p o s i t o r y\ni s\ne m p t y !\nI n\no r d e r\nt o\na c c e s s\nt h e\na s s i g n m e n t s ,\nc o m p l e t e\nt h e\nf o l l o w i n g\ns t e p s .\nT h i s\na d d s\nt h e\n_release\nr e p o s i t o r y\na s\na n\ne x t r a\nr e m o t e ,\na n d\nt h i s\ns t e p\nm u s t\nb e\nc o m p l e t e d\ne v e r y\nt i m e\ny o u\nw a n t\nt o\ni n i t i a l i z e\ny o u r\nr e p o s i t o r y\no n\na\nn e w\nm a c h i n e .\ngit\nremote\nadd\nrelease\nhttps://github.com/illinois-cs-coursework/fa24_cs341_.release.git\ngit\npull\nrelease\nmain\n--allow-unrelated-histories\n--no-rebase\ngit\npush\norigin\nmain", "mimetype": "text/plain", "start_char_idx": 1357, "end_char_idx": 2294, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1be1b294-05bf-4d25-9c53-20d2f2fc8be9": {"__data__": {"id_": "1be1b294-05bf-4d25-9c53-20d2f2fc8be9", "embedding": null, "metadata": {"page_label": "5", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "204eda0e-0a38-4f2a-af79-6c57b8fc0c05", "node_type": "4", "metadata": {"page_label": "5", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d52235812c113972326849d12956ec76a73cfff60138aa116630648c96354feb", "class_name": "RelatedNodeInfo"}}, "text": "W h e n e v e r\ny o u\ns t a r t\na n\na s s i g n m e n t ,\ny o u\nw i l l\nn e e d\nt o\nr u n\ngit\npull\nrelease\nmain\nt o\nr e t r i e v e\nt h e\ns t a r t e r\nc o d e\nf o r\nt h e\na s s i g n m e n t .\nInstall\ncompiler\nand\nCS341\nt ools\nY o u r\nV M\ns h o u l d\na l r e a d y\nb e\np r o v i s i o n e d\nw i t h\nt h e\nr e q u i r e d\nt o o l s .\nT h i s\ns e c t i o n\ni s\nf o r\nr e f e r e n c e\ni n\nc a s e\ny o u\nn e e d\nt o\nr e i n s t a l l\ns p e c i \ufb01 c\nt o o l s ,\ne . g .\ni n\nt h e\nc a s e\nw h e r e\ny o u r\nV M\nm u s t\nb e\nr e s e t\nH e r e\ni s\nt h e\ns c r i p t\nu s e d\nt o\np r o v i s i o n\nt h e\nV M s\nt h i s\ns e m e s t e r :\n#\nupdate\nsources\nand\ninstall\nbasic\ntools\nsudo\napt-get\nupdate\n&&\n\\\napt-get\ninstall\n-y\n\\\nsoftware-properties-common\n\\\nwget\n\\\nbzip2\n&&\n\\\nadd-apt-repository\nppa:deadsnakes/ppa\n&&\n\\\napt-get\nupdate\n#\ninstall\npython3.6\nsudo\napt-get\ninstall\n-y\npython3.10\npython3-pip\npython2-dev\npython3.10-dev\ncmake\niproute2\n&&\n\\\nrm\n/usr/bin/python3\n&&\n\\\nln\n-s\npython3.10\n/usr/bin/python3\n&&\n\\\nln\n-s\n-f\n/usr/lib/x86_64-linux-gnu/libc.a\n/usr/lib/x86_64-linux-gnu/liblibc.a\n#\ninstall\nbulid-related\ntools\nsudo\napt-get\ninstall\n-y\n\\\nclang\n=\n1:14.0-55~exp2\n\\\nlibncurses5-dev\n=\n6.3-2ubuntu0.1\n\\\nrpcbind\n=\n1.2.6-2build1\n\\\ngit\n=\n1:2.34.1-1ubuntu1.10\n\\\nstrace\n=\n5.16-0ubuntu3\n&&\n\\\nrm\n-rf\n/var/lib/apt/lists/\n*\n#\ninstall\nthe\nlatest\nversion\nof\nvalgrind\nwget\nhttps://sourceware.org/pub/valgrind/valgrind-3.21.0.tar.bz2\n&&\n\\\necho\n\"b8b89b327732c12191306c3d31cfd4b1\n*./valgrind-3.21.0.tar.bz2\"\n|\nmd5sum\n-c\n-\n&&\n\\\nbunzip2\nvalgrind-3.21.0.tar.bz2\n&&\n\\\ntar\nxf\nvalgrind-3.21.0.tar\ncd\n./valgrind-3.21.0\n./configure\n&&\n\\\nmake\n&&\n\\", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1610, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a29cc3f6-0465-40f9-be43-7041a2686f30": {"__data__": {"id_": "a29cc3f6-0465-40f9-be43-7041a2686f30", "embedding": null, "metadata": {"page_label": "6", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "68e2c518-050f-454a-936f-33033c6dc12e", "node_type": "4", "metadata": {"page_label": "6", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4ff3a3a0228344fd307cb584c7b5da2acd5c5d290826603cd2b744d2f88b0d4d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3def7a1b-a1ba-4680-b88c-fbb1f5904f8c", "node_type": "1", "metadata": {}, "hash": "0cafef99c2b192e2133171fe9713c2c5ddfbeaa9361be4a3751b91a1bc461f0d", "class_name": "RelatedNodeInfo"}}, "text": "make\ninstall\ncd\n..\nrm\n-rf\nvalgrind-3.21.0\n#\nvalgrind\nfix:\ninstall\ndebug\nsymbols\nfor\nlibc\nsudo\napt-get\ninstall\n-y\nlibc6-dbg\nInstalling\nOther\nStuff\nT h i s\ni s\ny o u r\nV M !\nY o u\nc a n\nsudo\na n d\ni n s t a l l\nw h a t e v e r\ny o u\nw a n t\no n\ni t\n( g i v e n\nt h a t\ni t\ni s\ns c h o o l\na p p r o p r i a t e\na n d\nc o m p l i a n t\nw i t h\nV M\nF a r m\np o l i c i e s\n)\nY o u\nc a n\ni n s t a l l\nvim\no r\nemacs\n.\nI f\ny o u \u2019 v e\ne v e r\nw a n t e d\nt o\nb e c o m e\nt e r m i n a l - s a v v y ,\nt h i s\ni s\nd e \ufb01 n i t e l y\nt h e\nc o u r s e\nt o\nd o\ni t !\nI f\na n y t h i n g\ni s\nu n c l e a r ,\ne i t h e r\np o s t\no n\nt h e\nc o u r s e\nf o r u m s\no r\na s k\ny o u r\nT A s / C A s / f e l l o w\ns t u d e n t s !\nB e\nc a r e f u l\na b o u t\nm e s s i n g\nu p\ny o u r\nV M .\nI f\ny o u r\nV M\ne v e r\ng e t s\ni n t o\na n\nu n u s a b l e\ns t a t e ,\np l e a s e\nm a k e\na\np r i v a t e\np o s t\ni n\nt h e\nc o u r s e\nf o r u m s\nw i t h\ny o u r\nV M\nn u m b e r\n,\na n d\nw e\nw i l l\nt r y\nt o\nr e s o l v e\ni t .\nY o u\nm a y\n\ufb01 n d\ns s h - c o p y - i d\nu s e f u l\n( A\nw e b\ns e a r c h\nu s i n g\nG o o g l e / D u c k\nD u c k\nG o\ni s\nu s e f u l ) .\nY o u\nc a n\na l s o\nc o n \ufb01 g u r e\nM S\nC o d e\na n d\no t h e r\nG U I\ne d i t o r s\nt o\nw o r k\nr e m o t e l y .\nH o w e v e r\ns o m e\np e o p l e\ns t i l l\nu s e\n\u2018 o u t\no f\nt h e\nb o x \u2019\nt e r m i n a l - b a s e d\ne d i t o r s\nl i k e\nv i / v i m\nt h a t\ny o u\nc a n\n\ufb01 n d\n( o r\ni n s t a l l )\no n\ne v e n\nt h e\ns m a l l e s t\no f\nL i n u x\nd i s t r i b u t i o n s ,\na n d\nw o r k\ne v e n\no n\nl o w - b a n d w i d t h\nc o n n e c t i o n s .\nH a v e\nf u n !", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1612, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3def7a1b-a1ba-4680-b88c-fbb1f5904f8c": {"__data__": {"id_": "3def7a1b-a1ba-4680-b88c-fbb1f5904f8c", "embedding": null, "metadata": {"page_label": "6", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "68e2c518-050f-454a-936f-33033c6dc12e", "node_type": "4", "metadata": {"page_label": "6", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4ff3a3a0228344fd307cb584c7b5da2acd5c5d290826603cd2b744d2f88b0d4d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a29cc3f6-0465-40f9-be43-7041a2686f30", "node_type": "1", "metadata": {"page_label": "6", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3738c8077dd6942567870fb6ac81ee3a8d1b0500555faf204f2891598a12694c", "class_name": "RelatedNodeInfo"}}, "text": "H a v e\nf u n !\nI n\nt h e\nw o r s t\nc a s e\nw e\nc a n\nr e s e t\ny o u r\nV M\nb a c k\nt o\ni t s\ni n i t i a l\ns t a t e .\nCan \u2019t\nlogin?\nI f\ny o u\nc a n \u2019 t\nc o n n e c t\n-\n1 .\nN o t\no n\nt h e\nc a m p u s\nn e t w o r k ?\nY o u\nw i l l\nn e e d\nt o\nu s e\nt h e\nU n i v e r s i t y\nV P N ,\nC i s c o\nA n y C o n n e c t\n2 .\nC h e c k\nt h e\ns t a t u s\no f\ny o u r\nV M\no n\nt h e\nV S p h e r e\nc o n s o l e\na n d\ns t a r t / r e s t a r t\ni t\ni f\nn e c e s s a r y .\nT h e\nV M s\na r e\ns h u t d o w n\nd a i l y\na t\n5 a m ,\no r\np e r h a p s\ny o u\nc r e a t e d\na\nf o r k - b o m b\nw h i l e\nw o r k i n g\no n\nt h e\nS h e l l\nM P .\nA d d i t i o n a l\nP o w e r\no n / r e s e t\ni n s t r u c t i o n s\na r e\na t\nt h i s\nI T\np a g e", "mimetype": "text/plain", "start_char_idx": 1597, "end_char_idx": 2320, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "abf02d24-4bf5-4b83-8d89-d7ab8ec3b0b5": {"__data__": {"id_": "abf02d24-4bf5-4b83-8d89-d7ab8ec3b0b5", "embedding": null, "metadata": {"page_label": "7", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ff580322-4bf2-4ffa-a4ed-0582ce3217dc", "node_type": "4", "metadata": {"page_label": "7", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8b1106d6c98f424da8613e33d074ba047bf47ab062e3e6bca1c317e25f97f1a4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e6dfc4ae-972a-428b-9698-0a633e459fb2", "node_type": "1", "metadata": {}, "hash": "32f822ca33432ebfa2ef276774b8fca5a13f9a5069e109014d3a142514170749", "class_name": "RelatedNodeInfo"}}, "text": "3 .\nC h e c k\nE n g r I T\nA n n o u c e m e n t s\na n d\ns l o w\nl o a d i n g\nS t a t u s\nP a g e\na n d\nt h e\nc l a s s\nf o r u m\nStill\nha v e\nVM\nissues?\nI f\ny o u\na r e\ns u r e\nt h a t\ny o u\nf o l l o w\nt h e\ns e t u p\ng u i d a n c e\nc o r r e c t l y\na n d\ny o u\na r e\no n\ne i t h e r\nt h e\nC a m p u s\nV P N\no r\nt h e\nI l l i n o i s N e t\nW i F i\nb u t\ny o u\ns t i l l\nh a v e\nV M\ni s s u e s\n( e . g .\nc a n n o t\na c c e s s\nv c . c s . i l l i n o i s . e d u ,\nc a n n o t\ns s h\ni n t o\nV M ) ,\nt h e n\nt h e\nf a s t e s t\nr e s o l u t i o n\nw i l l\nc o m e\nf r o m\nd i r e c t l y\nc o n t a c t i n g\nE n g r I T\nw i t h\ny o u r\ni s s u e\nu s i n g\nt h e i r\nf o r m\n.\nI n\nt h e\nf o r m ,\nu n d e r\nt h e\n\u201c W h i c h\nl a b ( s )\no r\nr e m o t e\nr e s o u r c e ( s )\ni s\ny o u r\nr e q u e s t\na b o u t ? \u201d ,\ny o u\nc a n\nt y p e\n\u201c C S\nV M\nF a r m \u201d .\nY o u\nc a n\nc o n t a c t\nI T\nb y\nd i r e c t l y\ne m a i l i n g\nc s - v m f a r m - h e l p @ i l l i n o i s . e d u .\nT h i s\na\nb i t\nf a s t e r\nt h a n\nt h e\nk n o w n\n\u2018 s t a n d a r d \u2019\ne m a i l s ,\ne w s @ i l l i n o i s . e d u ,\na n d\ne n g r i t - h e l p @ i l l i n o i s . e d u\nb e c a u s e\nt h e s e\nl a s t\nt w o\nn e e d\na n\ne x t r a\nm a n u a l\ns t e p\nt o\ng e t\ny o u r\nr e q u e s t\nt o\nt h e\nr i g h t\ns u p p o r t\np e o p l e .\nI n c l u d e\na s\nm a n y\nd e t a i l s\na s\np o s s i b l e\n( C o u r s e\nn u m b e r ,\ny o u r\nV M\nh o s t n a m e ,\nt i m e\no f\ne r r o r ,\nt y p e\no f\ne r r o r ,\na n d\nd e s c r i p t i o n\no f\nw h a t\ny o u \u2019 v e\nt r i e d .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1547, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e6dfc4ae-972a-428b-9698-0a633e459fb2": {"__data__": {"id_": "e6dfc4ae-972a-428b-9698-0a633e459fb2", "embedding": null, "metadata": {"page_label": "7", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ff580322-4bf2-4ffa-a4ed-0582ce3217dc", "node_type": "4", "metadata": {"page_label": "7", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8b1106d6c98f424da8613e33d074ba047bf47ab062e3e6bca1c317e25f97f1a4", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "abf02d24-4bf5-4b83-8d89-d7ab8ec3b0b5", "node_type": "1", "metadata": {"page_label": "7", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f382f2838d584a71a11031f3d2b8819bc7d4016b0584468c0ccb95205026b4ce", "class_name": "RelatedNodeInfo"}}, "text": "I n c l u d e\na s\nm a n y\nd e t a i l s\na s\np o s s i b l e\n( C o u r s e\nn u m b e r ,\ny o u r\nV M\nh o s t n a m e ,\nt i m e\no f\ne r r o r ,\nt y p e\no f\ne r r o r ,\na n d\nd e s c r i p t i o n\no f\nw h a t\ny o u \u2019 v e\nt r i e d .\nPr o visioning\na\nlocal\nVM\nusing\nV agr ant\n(optional)\nI f\ny o u\na r e\nt a k i n g\nt h e\nc o u r s e\nr e m o t e l y\na n d\nh a v e\na\ns l o w\ni n t e r n e t\nc o n n e c t i o n\nw h e n\nu s i n g\nt h e\nC a m p u s\nV P N ,\ny o u\nc a n\ns e t\nu p\na\nV M\nl o c a l l y\n( o n\ny o u r\no w n\nc o m p u t e r )\nu s i n g\nV a g r a n t .\nT h i s\np a g e\nh a s\ni n s t r u c t i o n s\no n\nh o w\nt o\nd o\nt h a t .\nN o t e :\nY o u r\nE n g r I T - p r o v i s i o n e d\nV M\ni s\ns t i l l\nt h e\na u t h o r i t a t i v e\np l a c e\nf o r\n\ufb01 n a l\nt e s t i n g .\nY o u r\nl o c a l\nV a g r a n t\nV M\ni s\nj u s t\na\nw a y\nt o\nh e l p\nr e m o t e\ns t u d e n t s\nw i t h\nd e v e l o p m e n t .", "mimetype": "text/plain", "start_char_idx": 1318, "end_char_idx": 2218, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "255b23a2-8409-40e0-a8d8-92d7af6ae648": {"__data__": {"id_": "255b23a2-8409-40e0-a8d8-92d7af6ae648", "embedding": null, "metadata": {"page_label": "1", "file_name": "Peer Tutoring info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Peer Tutoring info.pdf", "file_type": "application/pdf", "file_size": 17090, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "30a9c6cc-73d7-4486-ac5c-b40e3bb0fb27", "node_type": "4", "metadata": {"page_label": "1", "file_name": "Peer Tutoring info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Peer Tutoring info.pdf", "file_type": "application/pdf", "file_size": 17090, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e4c7f79b70a6f052ab4fc80840007440421d484f1034c48ff26648b7843a5e23", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f50705fa-7fd9-48f3-98b5-9922a51ea0a3", "node_type": "1", "metadata": {}, "hash": "c97d4a5e44b03cc7b5afaecd815b15effe081b733733061af15f4f8b4f3de889", "class_name": "RelatedNodeInfo"}}, "text": "P eer\nT ut oring\nGetting\nHelp\nW e\nh o l d\np e e r\nt u t o r i n g\ns e s s i o n s\ne i t h e r\ni n - p e r s o n\no r\nv i a\nZ o o m .\nY o u\nc a n\nj o i n\nb y\na d d i n g\ny o u r s e l f\no n t o\nt h e\nQ u e u e\n( t h e\ns c h e d u l e\nc a n\nb e\nf o u n d\nb e l o w ) .\nM o r e\nd e t a i l e d\ni n s t r u c t i o n s\na r e\no n\no u r\nQ u e u e\np a g e .\nP l e a s e\nn o t e\nt h a t\nt h i s\ni s\nn o t\nC S\n2 2 5 ,\ns o\nw e\nw i l l\nn o t\nd o\ny o u r\na s s i g n m e n t s .\nT h i s\ni s\no n e\no f\nt h e\nl a s t\nc l a s s e s\ny o u\nw i l l\nt a k e\nb e f o r e\nb e i n g\nt h r o w n\ni n t o\n4 0 0 - l e v e l\nc o u r s e s ,\nw h e r e\nt h e\na s s i g n m e n t s\na r e\nm u c h\nh a r d e r ,\nh e l p\ni s\nm u c h\nm o r e\nl i m i t e d ,\na n d\nh a n d\nh o l d i n g\ni s\nn e g a t i v e .\nG i v e\na\ns t u d e n t\nt h e\na n s w e r\na n d\ny o u\nf e e d\nt h e m\nf o r\na\nd a y ;\nt e a c h\na\ns t u d e n t\nt o\n\ufb01 n d\nt h e i r\no w n\na n s w e r s\na n d\ny o u\nf e e d\nt h e m\nf o r\na\nl i f e t i m e .\nT h e s e\np e e r\nt u t o r i n g\ns e s s i o n s\nw i l l\nf o c u s\no n\nd i a g n o s i n g\nm i s c o n c e p t i o n s\na n d\nh o l e s\ni n\ny o u r\nu n d e r s t a n d i n g\no f\nt h e\np r o b l e m .\nT h i s\ni s\na\nf a i r l y\nc o n c e p t u a l\nc l a s s\nw h e r e\ny o u r\nu n d e r s t a n d i n g\no f\nt h e\np r o b l e m\nw i l l\nd i r e c t l y\ni m p a c t\nh o w\ny o u\nc a n\ni m p l e m e n t\na\ns o l u t i o n .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1395, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f50705fa-7fd9-48f3-98b5-9922a51ea0a3": {"__data__": {"id_": "f50705fa-7fd9-48f3-98b5-9922a51ea0a3", "embedding": null, "metadata": {"page_label": "1", "file_name": "Peer Tutoring info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Peer Tutoring info.pdf", "file_type": "application/pdf", "file_size": 17090, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "30a9c6cc-73d7-4486-ac5c-b40e3bb0fb27", "node_type": "4", "metadata": {"page_label": "1", "file_name": "Peer Tutoring info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Peer Tutoring info.pdf", "file_type": "application/pdf", "file_size": 17090, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e4c7f79b70a6f052ab4fc80840007440421d484f1034c48ff26648b7843a5e23", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "255b23a2-8409-40e0-a8d8-92d7af6ae648", "node_type": "1", "metadata": {"page_label": "1", "file_name": "Peer Tutoring info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Peer Tutoring info.pdf", "file_type": "application/pdf", "file_size": 17090, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "83d64786c5e9d239b01c74c2fab33d9de3550101f47ebfba21bcf34a091c61df", "class_name": "RelatedNodeInfo"}}, "text": "T h i s\ni s\na\nf a i r l y\nc o n c e p t u a l\nc l a s s\nw h e r e\ny o u r\nu n d e r s t a n d i n g\no f\nt h e\np r o b l e m\nw i l l\nd i r e c t l y\ni m p a c t\nh o w\ny o u\nc a n\ni m p l e m e n t\na\ns o l u t i o n .\nI f\ny o u\nh a v e\nm a d e\ni t\nt h i s\nf a r\ni n t o\nt h e\nC S\nc u r r i c u l u m\ns i m p l y\nb e\nc o m p i l i n g\nl e c t u r e\nn o t e s\na n d\nd o c u m e n t a t i o n\nt o\nc o d e ,\nt h e n\ny o u\na r e\ng o i n g\nt o\nh a v e\nt o\nm a k e\ns o m e\ns e r i o u s\nc h a n g e s\ni n\ny o u r\nw o r k\ne t h i c s .\nB e\np r e p a r e d\nt o\nb e\na s k e d\nt o\ne x p l a i n\nw h a t\ny o u\nt h i n k\ny o u r\np r o g r a m\ni s\nd o i n g .\nO d d s\na r e\nt h a t\nw h a t\ny o u\nt h i n k\ny o u r\nc o d e\ni s\nd o i n g\ni s\nn o t\ne q u i v a l e n t\nt o\nw h a t\ni t\ni s\nd o i n g .\nT h i s\nd e p a r t m e n t\ni s\ns c a l i n g\nr a p i d l y ,\nw h i c h\ni s\ng r e a t ,\ns i n c e\nc o m p u t e r\ns c i e n c e\ni s\na n\ni n c r e d i b l e\n\ufb01 e l d\no f\nk n o w l e d g e\nt h a t\nw i l l\nt a k e\no u r\nc i v i l i z a t i o n\nt o\nn e w\nf r o n t i e r s .\nU n f o r t u n a t e l y ,\nt h e\nn u m b e r\no f\np e o p l e\no n\nc o u r s e\ns t a f f\nd o e s\nn o t\ns c a l e\na s\nf a s t .\nT h i s\nm e a n s\nt h a t\nw e\nc a n\nn o t\ns i t\nn e x t\nt o\ny o u\nf o r\n4 5\nm i n u t e s\nt o\nr e a d\n8 0 0\nl i n e s\no f\ny o u r\nc o d e ;\nt h i s\ni s\np e e r\nt u t o r i n g\na n d\nn o t\na\nd i n n e r\nd a t e .\nW e\nw i l l\nw e a r\ns t o p w a t c h e s\na n d\nr o u n d\nr o b i n\nb e t w e e n\nt h e\ns t u d e n t s\no n\nt h e\nq u e u e .", "mimetype": "text/plain", "start_char_idx": 1180, "end_char_idx": 2695, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "107517f8-a175-49df-ae13-599e0bb0042b": {"__data__": {"id_": "107517f8-a175-49df-ae13-599e0bb0042b", "embedding": null, "metadata": {"page_label": "1", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d1257edc-1b8b-4a4b-b71d-bebccabaf357", "node_type": "4", "metadata": {"page_label": "1", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "77ebcf08a689e22618416df0c905c99582dc0d3e72901e864c9f075b7864b06e", "class_name": "RelatedNodeInfo"}}, "text": "Syllabus\nF ormal\nCourse\nDescription\nThis\ncourse\nis\nan\nintroduction\nto\nSystem\nProgramming.\nSystem\nProgramming\nrefers\nto\nwriting\ncode\nthat\nprioritizes\noperating\nsystem\nsupport\nfor\nprogrammers.\nA\ncomputer\nneeds\nan\noperating\nsystem\nto\nmanage\nits\nresources\nand\nprovide\nsupport\nfor\ncommon\nfunctions,\nsuch\nas\naccessing\nperipherals.\nThere\nare\ntwo\ncategories\nof\n\u201ccustomers\u201d\nthat\nan\noperating\nsystem\nmust\nsupport.\nThe\n\ufb01rst\ncategory\nis\nthe\ncommunity\nof\nusers.\nWe\nhave\nall\nused\ncomputers,\nand\nyou\nmay\nrecognize\noperating\nsystems\u2019\nfunctions\nsuch\nas\ncreating\nfolders\n(directories)\nand\nmoving\n\ufb01les\naround.\nThese\nare\nexamples\nof\noperating\nsystem\nsupport\nfor\nusers.\nUser\nsupport\nis\nnot\nthe\nobjective\nof\nthis\ncourse.\nThe\nsecond\ncategory\nof\nusers\nis\nprogrammers.\nThis\ncourse\naddresses\nthis\ncategory.\nWhen\nyou\nwrite\na\nprogram,\nit\nmay\nhave\nto\ninteract\nwith\nphysical\nhardware\n(memory,\n\ufb02ash\nstorage,\nscreen,\nnetwork,\netc.).\nFor\nexample,\nyou\nmay\nwant\nto\nget\ninput\nfrom\na\nkeyboard\nor\nmouse;\nyou\nmay\nwant\nto\nread\nsome\ncon\ufb01guration\n\ufb01le\nstored\non\ndisk;\nyou\nmay\nwant\nto\noutput\ndata\nto\na\nscreen\nor\nprinter;\nor\nyou\nmay\nwant\nto\naccess\na\nremote\nserver\nacross\na\nnetwork.\nThe\noperating\nsystem\npresents\ncommon\ninterfaces\nfor\nprogrammers\nto\nperform\nthese\nfunctions.\nIt\nalso\nprovides\nuseful\nabstractions\nsuch\nas\n\u201ctasks\u201d\n(also\ncalled\nprocesses),\n\u201cthreads\u201d,\nand\n\u201csemaphores\u201d.\nYou\ncan\nmake\nthe\ncomputer\nmulti-task\nby\ncreating\nnew\ntasks\nor\nnew\nthreads.\nYou\ncan\nmake\nthese\ntasks\ncoordinate\nand\nsynchronize\nby\nusing\nsemaphores.\nYou\ncan\ntell\nthe\ncomputer\nthe\norder\nin\nwhich\nyou\nwant\ntasks\nto\nbe\nexecuted\nby\nusing\na\nscheduling\npolicy.\nFinally,\nyou\ncan\nmanage\ncomputer\nmemory\nby\ncalling\non\nthe\nfunction\nfor\nmemory\nmanagement.\nLearning\nGoals/Skills", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1700, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "67b0b59c-100a-401d-adde-5cea369ef8e9": {"__data__": {"id_": "67b0b59c-100a-401d-adde-5cea369ef8e9", "embedding": null, "metadata": {"page_label": "2", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7e02a3b6-4f11-44dd-a46b-65153f2a6615", "node_type": "4", "metadata": {"page_label": "2", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "db4645a23b052c7074043acfbcbd8ddf862e7ad09507527658125db5d1df6f25", "class_name": "RelatedNodeInfo"}}, "text": "\u25cf\nIdentify\nthe\nbasic\ncomponents\nof\nan\noperating\nsystem,\ndescribe\ntheir\npurpose,\nand\nexplain\nhow\nthey\nfunction.\n\u25cf\nWrite,\ncompile,\ndebug,\nand\nexecute\nC\nprograms\nthat\ncorrectly\nuse\nsystem\ninterfaces\nprovided\nby\nUNIX\nor\na\nUNIX-like\noperating\nsystem.\n\u25cf\nBe\nfamiliar\nwith\nimportant\nUNIX\nsystem\ncalls\nand\ninvoke\nthem\ncorrectly\nfrom\nwithin\nC\nprograms.\n\u25cf\nDescribe\nthe\ndifference\nbetween\nprograms,\nprocesses,\nand\nthreads.\n\u25cf\nWrite\na\nmemory\nallocator\nor\nmalloc\n.\n\u25cf\nExplain\nthe\nmeaning\nand\npurpose\nof\nprocess\ncontrol\nblocks\nand\nother\nmechanisms\nthat\nthe\noperating\nsystem\nuses\nto\nimplement\nthe\nprocess\nand\nthread\nabstractions.\n\u25cf\nWrite,\ncompile,\ndebug,\nand\nexecute\nC\nprograms\nthat\ncreate,\nmanage\nand\nterminate\nprocesses\nand\nthreads\non\nUNIX.\n\u25cf\nDe\ufb01ne\nconcurrency\nand\nexplain\nthe\nproblems\nthat\nmay\narise\nbecause\nof\nconcurrent\nexecution\nof\nmultiple\nprocesses\nor\nthreads.\nExplain\nhow\nthese\nproblems\ncan\nbe\navoided.\nWrite\ncode\nthat\navoids\nthese\nproblems.\n\u25cf\nDe\ufb01ne\nsemaphores,\nmutexes,\nand\nother\nsynchronization\nprimitives.\nAlso,\nexplain\ntheir\npurpose,\nand\ndescribe\ntheir\ninternal\nimplementation.\n\u25cf\nDescribe\npossible\nproblems\nthat\narise\nfrom\nimproper\nuse\nof\nsynchronization\nprimitives\n(such\nas\ndeadlocks)\nand\npresent\ntheir\nsolutions.\n\u25cf\nWrite,\ncompile,\ndebug,\nand\nexecute\nC\nprograms\nthat\nuse\nUNIX\nsynchronization\nprimitives.\n\u25cf\nDescribe\noperating\nsystem\nscheduling\nand\nuse\nUNIX\ninterfaces\nto\nset\nand\nmodify\nscheduling\npolicy\nparameters.\n\u25cf\nDe\ufb01ne\nUNIX\nsignals\nand\nsignal\nhandlers,\nand\ndescribe\ntheir\nuse.\n\u25cf\nWrite,\ncompile,\ndebug,\nand\nexecute\nC\nprograms\nwith\nprocesses\nand\nthreads\nthat\ninteract\nby\ninvoking\nand\ncatching\nsignals.\n\u25cf\nDescribe\nthe\nconcepts\nof\nI/O\ndevices,\n\ufb01les,\ndirectories.\n\u25cf\nExplain\nthe\ninternal\nimplementation\nof\n\ufb01les\nsystems\nand\noperating\nsystem\nI/O.\n\u25cf\nWrite,\ncompile,\ndebug,\nand\nexecute\nC\nprograms\nthat\nuse\n\ufb01les\nand\nI/O\non\nUNIX.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1817, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "36025681-6282-4404-986c-d44c342f6fd5": {"__data__": {"id_": "36025681-6282-4404-986c-d44c342f6fd5", "embedding": null, "metadata": {"page_label": "3", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "293289f5-cef4-443c-9aa6-90a0d2625f2f", "node_type": "4", "metadata": {"page_label": "3", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a0c6bc5517fe54c83d56b1a0dce6164c414b8c16d37e0390a90e1926b9b8cc0a", "class_name": "RelatedNodeInfo"}}, "text": "\u25cf\nDescribe\nthe\nmachine\nmemory\nhierarchy,\ndescribe\nits\ncomponents\nsuch\nas\ncaches\nand\nvirtual\nmemory,\nand\nexplain\nmemory\nmanagement\nmechanisms\npertaining\nto\nthese\ncomponents\nsuch\nas\npaging\nand\nsegmentation.\n\u25cf\nWrite,\ncompile,\ndebug,\nand\nexecute\nC\nprograms\nthat\nmake\nuse\nof\nmemory\nmanagement\nfunctions.\n\u25cf\nDescribe\nthe\nprotocols\n(such\nas\nTCP\nand\nIP)\nand\ninterfaces\n(such\nas\nsockets)\nused\nfor\ncommunication\namong\ndifferent\ncomputers.\n\u25cf\nWrite\ndistributed\napplications\nthat\ncommunicate\nacross\na\nnetwork.\n\u25cf\nUnderstands\nand\nuses\nsystem\nsecurity\nmechanisms\nto\nbuild\nsecure\nprograms.\n\u25cf\nBy\nthe\nend\nof\nthis\ncourse,\nyou\nshould\nbe\npro\ufb01cient\nat\nwriting\nprograms\nthat\ntake\nfull\nadvantage\nof\noperating\nsystem\nsupport.\n\u25cf\nCan\nanalyze\nhow\na\nspeci\ufb01c\nsecurity\nerror\n(e.g.\nbuffer\nover\ufb02ow,\n\ufb01le\naccess\ncontrol,\npage\naccess\ncontrol)\nimpacts\nthe\nCon\ufb01dentiality,\nIntegrity\nand/or\nAvailability\nof\ndata\nor\nservice.\n\u25cf\nCan\nidentify\nmultiple\ndevelopment\npractices\n(e.g.\ndesign\nreviews,\ncode\nreviews,\ntesting)\nas\nimportant\npractices\nto\nbuild\nsecure\nprograms.\n\u25cf\nCan\nbrie\ufb02y\ndescribe\nwell-known\nsecurity\ncase\nstudies\n(e.g.\nnetwork\nprotocol\nimplementation\nerrors,\nCPU\nside\nchannel\nattacks)\nand\nhow\nthey\ncomprise\nthe\nCon\ufb01dentiality,\nIntegrity\nand/or\nAvailability\nof\ndata\nor\nservice.\nGr ading\nThe\nfollowing\nis\nsubject\nto\nminor\nchanges:\nFinal\nExam\n:\n20\n-\n23%\n(see\nnotes)\nQuizzes:\n15%\nMP\nProgramming\nAssignments\n:\n45%\nLab\nProgramming\nAssignments:\n17%\nLab\nAttendance\n&\nother\nitems:\nsee\nbelow", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1446, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "20933971-29cf-4e40-9766-49e8887c5d1e": {"__data__": {"id_": "20933971-29cf-4e40-9766-49e8887c5d1e", "embedding": null, "metadata": {"page_label": "4", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6904ae89-36c0-4f9f-9605-365747dac5e7", "node_type": "4", "metadata": {"page_label": "4", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d6bd7fff2798bf98aff544aa2ed91a4b69fec849b4e1dccc98e35dce97cc7187", "class_name": "RelatedNodeInfo"}}, "text": "We\npublish\nthe\nfollowing\nthresholds:\nPoints\nMinimum\nGrade\n90\n-\n100]\nA-\n80\n-\n90)\nB-\n70\n-\n80)\nC-\nAll\nlab\nprogramming\nassignments\nare\nequally\nweighted.\nMP\nprogramming\nassignments\nare\nweighted\nby\nthe\ntime\ngiven\nto\ncomplete\nthem.\nThis\nmeans\nthat\nthree\nweek\nMPs\nare\nworth\ntriple\none\nweek.\nFor\ngrading,\nwe\nwill\ndrop\nyour\nlowest\nlab\nscore,\nand\ntwo\nlab\nattendance\ngrades.\nSome\nexamples:\nyou\nslept\nin\nlate;\nyour\ndog\nate\nyour\nhomework;\nyou\ndestroyed\nthe\ninternet.\nThe\n\ufb01nal\nis\ntake-home,\n3\nhours\nand\nwill\nbe\navailable\nonline.\nThe\nexam\ncan\nbe\ncompleted\nat\nany\ntime\nover\na\n3\nday\nperiod\nduring\nexam\nweek.\nMore\ndetails\nwill\nbe\npublished\nat\nthe\nend\nof\nthe\nsemester.\nEarly\nexams\nwill\nnot\nbe\noffered.\nThe\nexam\nwill\nbe\navailable\non\nthe\n\ufb01rst\nSunday\nafter\nreading\nday\nand\ncloses\n3\ndays\nlater,\nWednesday\n11\npm.\nOpportunities\nfor\na\nsmall\namount\nof\nextra\ncredit\nmay\nbe\noffered\nand\nwill\nbe\nannouced\nduring\nthe\nsemester.\nGrading\nissues\nshould\nbe\nraised\nwith\nyour\nTA\nduring\nsection\nor\nby\nemail.\nMissing\nscores\nneed\nto\nbe\nreported\nwithin\n3\ndays\nof\nbeing\npublished.\nRegr ades\nAt\nthe\nend\nof\nthe\nsemester\nthere\nwill\nbe\na\nlast\nchance\nregrade\noption\nfor\ntwo\nweeks\nof\nmachine\nproblem\nor\nlab\ngrades.\nTo\nbe\nable\nto\ntake\nadvantage\nof\nthis", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1200, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ba695c7f-4ddc-4985-9879-f9b95762ec03": {"__data__": {"id_": "ba695c7f-4ddc-4985-9879-f9b95762ec03", "embedding": null, "metadata": {"page_label": "5", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8bb66c66-9021-4ce4-9279-3dd0432ac1e8", "node_type": "4", "metadata": {"page_label": "5", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f46f147af020821256d7abe5536a3e720b91272c28d3b126eb09ccb7d31747c4", "class_name": "RelatedNodeInfo"}}, "text": "opportunity\nyou\nwill\nneed\nto\nhave\na\nperfect\nattendance\ngrade\nafter\nthe\ndrops.\nPlease\nnote\nthat\nthe\nscore\nfor\neach\nregrade\nwill\nbe\ncapped\nat\n90%.\nLab\nA ttendance\nChicago\nstudents\nwill\nhave\ntheir\nown\nonline\nlab\n(arranged\nwith\nthe\nTA).\nUrbana-Champaign\nstudents\nhave\nin-person\nlabs\nin\nSiebel.\nLabs\nare\nrequired\nand\nthere\nis\nalso\na\nsmall\nreward\nfor\nin-person\nattendance:\nYour\n\ufb01nal\nexam\ncontribution\n(23%)\ncan\nbe\nreduced\nto\n20%\nby\nattending\nall\nlabs.\nPartial\nattendance\nof\nin-person\nlabs\nwill\nbe\nprorated.\nFor\nexample,\nif\nafter\nallowing\nfor\n2\ndrops,\nyou\nattended\n6\nof\n9\nin-person\nlabs\nthen\nyour\n\ufb01nal\nexam\nwill\nbe\nworth\n21%,\nand\nyou\nwill\nhave\n2%\nof\nfull\ncourse\ncredit.\nWhat\nthis\nmeans:\nIf\nyou\nchoose\nto\ncomplete\nthis\ncourse\nvirtually,\nor\nare\nsick\nand\nunable\nto\nattend\nlabs,\nor\ndo\nnot\nwish\nto\nbe\nin\nclose\ncontact\nwith\nother\nstudents\nyou\ncan\nstill\nsucceed\nand\nearn\na\nhigh\ngrade.\nFor\nthose\nthat\nneed\nit:\nThere\nis\nstill\na\nsmall\ncarrot\nto\nencourage\nyou\nto\nleave\nyour\ndorm\nand\nmake\nit\nto\nSiebel!\nBut\ndon\u2019t\nget\nanxious\nabout\nloosing\npoints\nif\nyou\ncan\u2019t\nattend.\nQuizz es\nEach\nquiz\ncovers\napproximately\n2\nweeks\nof\ncontent.\nThey\ncan\nbe\ncompleted\nmultiple\ntimes\n(highest\nscore\nis\nused)\nat\nany\ntime.\nThey\nare\ndue\nby\nlast\nday\nof\ninstruction\n(i.e.\nbefore\nreading\nday).\nNo\nquizes\nare\ndropped;\nyou\nshould\ncomplete\nall\n7\nof\nthem.\nQuizzes\nwill\nbe\nonline\nusing\nPrairie\nLearn\n.\nPlease\nsee\nthe\nQuiz\ntopics\npage\nfor\nmore\ninformation.\nCoding\nAssignments\nThere\nare\ntwo\ndifferent\ntypes\nof\ncoding\nassignments\nin\nthis\ncourse\nlabs\nand\nmachine\nproblems.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1518, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ca46a54f-b287-40b1-a9a4-d6a97cf0c7b7": {"__data__": {"id_": "ca46a54f-b287-40b1-a9a4-d6a97cf0c7b7", "embedding": null, "metadata": {"page_label": "6", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f4218aa6-08f5-43d9-9655-9b58a33d2068", "node_type": "4", "metadata": {"page_label": "6", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e896acf5a5ffbf3aeef253e968593f521556633041f72f6777070a394ff4b809", "class_name": "RelatedNodeInfo"}}, "text": "Labs\nare\nprimarily\nteaching\nexercises\ndesigned\neither\nto\nprepare\nyou\nfor\nthe\nmachine\nproblems\nor\nto\nallow\nyou\nto\nexplore\na\ntopic\nof\nsystems\nin\na\nhands\non\nmanner.\nLabs\nmay\nbe\ndone\nin\na\ncollaborative\nmanner.\nYou\nare\nallowed\nto\nwork\nwith\neach\nother\nso\nas\nto\nlearn\nin\nthe\nbest\nmanner\nfor\nyou.\nThis\ncan\ninclude\nsharing\ncode,\ndebugging\neach\nother\u2019s\ncode,\nand\ndiscussing\nthe\nassignment\nat\nany\nlevel.\nYou\nstill\nmay\nnot\npublicly\npublish\neither\nyour\nsolutions\nor\nour\ncode.\nFinally\nyou\nshould\nhave\na\ncomment\nblock\nwith\nany\nstudents\nor\nother\nresources\nyou\nused\nin\nthe\ncompletion\nof\nyour\nlab\nassignments.\nThis\nblock\nwill\nnot\nbe\nused\nfor\ngrading\nbut\nis\nneeded\nthe\nsame\nway\nthat\nciting\nyour\nsources\nis\nrequired\nwhen\nwriting\na\npaper.\nMachine\nProblems\nare\ndifferent.\nWhile\nthey\nare\na\nkey\nlearning\nexperience\nMPs\nare\nalso\na\nkey\nassessment\nof\nyour\nskills.\nThese\nare\nsolo\nexercises\nand\nyou\nmust\nwork\nalone.\nFor\nMPs,\nyou\nmay\nnot\nshare\ncode\nin\nany\nway.\nThis\nincludes\nshow,\nshare,\nemail,\nor\ndebug\neach\nothers\ncode.\nYou\nmay\nhave\nhigh\nlevel\ndiscussions\nwith\neach\nother\non\nthe\nideas\nin\nthe\nassignments\nbut\nthat\nis\nit.\nYou\nare\nresponsible\nfor\nkeeping\nthe\ncode\nfor\nyou\nmachine\nproblems\nprivate\nthis\nincludes\nnot\nletting\npeople\nview\nyour\ncode.\nYou\nmay\nnot\npublish\nyour\ncode\non\nany\nopen\nwebsite.\nNo\nlate\nsubmissions\nwill\nbe\naccepted.\nA ut ogr ading\nP olicy\nYou\nwalk\ninto\nthe\ninvestor\nmeeting\nready\nto\nshow\nyour\ndemo.\nYou\nship\nyour\ncode\nready\nfor\na\nmillion\nInternet\nof\nthings.\nYou\ndeploy\nyour\ncode\nto\nthe\nInternet\nbackbone.\nIt\nhad\nbetter\ncompile\nand\nbe\nfunctional.\nForgot\nto\ncommit\nor\nyour\ncommitted\ncode\nthat\ndoes\nnot\ncompile?\nZero.\nThe\nbasic\nheadline\nis\nthat\nyou\u2019re\nnot\nin\nKansas\nanymore\n(to\nquote\nDorothy).\nDon\u2019t\nleave\nit\nuntil\nthe\nlast\nminute.\nThere\nare\ntwo\nkinds\nof\nautograder\nruns:\n\u25cf\nPre-deadline\nruns:\nYou\nare\nresponsible\nfor\nstarting\nthese.\nOur\nteam\nhas\nworked\nreally\nhard\nto\nimprove\nour\ngrading\nsystem\nand\nmake\nit\nmore", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1896, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "613bca0a-5ba4-4ea6-ad43-429dcba5b7fe": {"__data__": {"id_": "613bca0a-5ba4-4ea6-ad43-429dcba5b7fe", "embedding": null, "metadata": {"page_label": "7", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "20abee10-fba9-42c1-b65f-817e871648f4", "node_type": "4", "metadata": {"page_label": "7", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4176c23785da6f5aec3503127b704c199f3991cbce0608be081ce3395e23f49d", "class_name": "RelatedNodeInfo"}}, "text": "reliable\nand\n\ufb02exible.\nNow,\nyou\ncan\nschedule\nyour\npre-deadline\nautograder\nruns\nusing\nthe\non-demand\ngrading\nsystem,\nthat\nyou\ncan\n\ufb01nd\non\nthe\nAssignments\npage!\nYou\nhave\nto\nlog\nin\nwith\nyour\nGitHub\nEnterprise\naccount.\nAssignments\nwill\nbecome\nvisible\non\nthe\nweb\napp\nas\nwe\nrelease\nthem.\nYou\nwill\nget\none\nAG\nrun\na\nday\nwhich\nyou\ncan\ntrigger\nat\nyour\ndisposal.\nPlease\nbe\ncareful\nin\nusing\nthese.\nThese\npre-deadline\nruns\ndo\nnot\nroll\nover.\nWe\nrecommend\nthat\nyou\ndevelop\nand\nwork\non\nyour\nassignments\nevery\nday\nto\nmake\nthe\nbest\nof\nthis\nsystem.\nOnce\nyou\nclick\n\u201cGrade\nNow\u201d,\nyour\ncode\nwill\nstart\ngetting\ntested\non\nour\ngrading\nmachines.\nYou\ncan\nexpect\nto\nsee\nfeedback\nin\nyour\nCS\n341\nrepository\u2019s\n_feedback\nbranch\nin\na\nfew\nminutes.\nIn\nrare\ncircumstances,\nthe\ngrading\nprocess\nmight\nfail\n(if\nyour\ncode\nmade\nour\nDocker\ncontainers\ncrash).\nIn\nthis\nscenario,\nthere\nwill\nbe\nno\nvisible\nfeedback.\nYou\nshould\nmake\na\nprivate\npost\nin\nthe\ncourse\nforums\nand\nwe\nwill\ndeal\nwith\nthis\non\na\nper-student\nbasis.\nUse\nthese\nruns\nfor\nfeedback\nas\nyou\nwork\non\nthe\nassignment.\nThese\nhave\nno\neffect\non\nyour\ngrade\nfor\nthe\nassignment.\n\u25cf\nDeadline\nruns:\nThese\nwill\nbe\ntriggered\nby\nus\nand\nthe\ngrades\nyou\nget\non\nthese\nwill\nbe\ncounted\ntowards\nyour\n\ufb01nal\ngrades.\nThe\nresults\nwill\nshow\nup\nin\nthe\n_feedback\nbranch\nas\nusual.\nLabs:\n\u25cf\nReleased\nevery\nWednesday\n\u25cf\nPre-deadline\nruns:\nAvailable\nevery\nday\nfrom\nWednesday\nto\nWednesday\n(you\nwill\nget\nto\nstart\nthese!)\n\u25cf\nDeadline\nAG\nrun\non\nWednesday\nat\n11:59\npm\nMPs:\n\u25cf\nReleased\non\nMondays\n(for\nmulti-week\nMPs,\nthe\nentire\nassignment\nis\nreleased\nat\nonce)\n\u25cf\nPre-deadline\nruns:\nAvailable\nevery\nday\nfrom\nTuesday\nto\nMonday\n(you\nwill\nget\nto\nstart\nthese!)\n\u25cf\nDeadline\nrun\non\nMonday\nat\n11:59\npm", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1661, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "baf1e610-4526-47c7-af7c-7f7583751f68": {"__data__": {"id_": "baf1e610-4526-47c7-af7c-7f7583751f68", "embedding": null, "metadata": {"page_label": "8", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bf24c37a-3f3b-48c0-8447-dc2e38a19f71", "node_type": "4", "metadata": {"page_label": "8", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "2a85f4d42bb9990b4c973afdf9855e91718637b0503cd94a5cdf64721c13e778", "class_name": "RelatedNodeInfo"}}, "text": "We\nwill\ntest\nyour\ncode\non\na\nmulti-core\nmachine;\ntesting\non\nyour\nown\nlaptop\nis\ninsu\ufb03cient.\nDon\u2019t\nbe\nsurprised\nif\nrace\nconditions\nthat\ngo\nundetected\non\na\ndifferent\nmachine\ncause\nyour\ncode\nto\nfail.\nWe\nencourage\nyou\nto\ndevelop\nand\ntest\nyour\ncode\non\nyour\nCS\n341\nVM,\nwhich\nis\nnear-identical\nto\nthe\ngrading\nmachine.\nWe\nwill\nattempt\nto\ngive\nyou\nsome\npartial\ncredit\nif\nyour\ncode\npasses\nthe\ntests.\nIf\nyou\nhave\na\nquestion\nabout\nyour\npersonal\nautograder\nresults\nafter\nthe\n\ufb01nal\nautograde\nrun,\nthen\nfeel\nfree\nto\nmake\na\nprivate\npost\nin\nthe\ncourse\nforums\ntitled\n\u201c<assignment\nname>\nAutograde\nQuestion\u201d\nwith\nthe\nfolders/tags/labels\nautograder\nand\n<assignment\nname>\nselected.\n\u25cf\nIt\nwill\ntake\ntime\nto\ngo\nthrough\nautograder\nquestions,\nso\nplease\ndo\nnot\nexpect\nan\nimmediate\n(or\neven\nsame\nday\nor\nsame\nweek)\nresponse.\nWe\nwill\ntry\nto\nanswer\nyou\nas\nquickly\nas\npossible.\n\u25cf\nY o u\nm u s t\ns h o w\nu s\ny o u r\nt e s t\nc a s e s\n\ufb01 r s t .\nI f\nt h e y\na r e\nn o t\nc l o s e\nt o\ne x h a u s t i v e ,\nw e\nr e s e r v e\nt o\nr i g h t\nt o\nn o t\na n s w e r\ny o u r\nq u e s t i o n .\n\u25cf\nWe\nwill\nnot\ntell\nyou\nthe\ndetails\nof\nspeci\ufb01c\ntests,\nbeyond\nwhat\nthe\ntest\ndescription\nalready\nsays.\n\u25cf\nThese\nquestions\nshould\nbe\nfor\n\u201cI\nhave\nexhaustive\ntest\ncases\nfor\nX\n,\nso\nhow\nam\nI\nfailing\nY\n?\u201d\n\u25cf\nPlease\nmention\nyour\nNetID\nin\nthe\npost,\nso\nwe\ncan\nlook\nup\nyour\ncode\nif\nneeded.\nGetting\nHelp\n&\nExtensions\nIt\u2019s\nimportant\nto\nsay\nphysically\nand\nmentally\nhealthy.\nPlease\nsee\nthe\nlinks\nbelow\nfor\nmental\nhealth\nresources.\n\u25cf\nO\ufb03ce\nhours\nand\npeer\nmentoring\nfor\ncourse\nstaff\nwill\nbe\nposted\nin\nthe\nforums.\nO\ufb03ce\nhours\nwill\nstart\nthe\nsecond\nfull\nweek\nof\nthe\nsemester\n\u25cf\nFor\nunusual\nadministrative\nitems\n(e.g.\nsickness\npreventing\nyou\nfrom\nworking,\nDRES,\n1%\nissues,\nproblems\nwith\nyour\nTA)\nthen\nplease\nemail\n(cs341admin@cs.illinois.edu)\nand\nexplain\nyour\nscenario.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1788, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "701b5773-47a3-4803-997e-8ee5607583d6": {"__data__": {"id_": "701b5773-47a3-4803-997e-8ee5607583d6", "embedding": null, "metadata": {"page_label": "9", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c85c5020-e0f2-4b45-853b-87085be3569f", "node_type": "4", "metadata": {"page_label": "9", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "67b10cdf00c4c7c1862ff2060ff01b552c8c554bd4d884e4a5fa85ddc955abe2", "class_name": "RelatedNodeInfo"}}, "text": "Absences\nIf\nyou\nare\nin\nan\nexceptional\nsituation\n\u2013\ni.e.\nfamily\nemergency,\nsickness,\nplease\nemail\n(cs341admin@cs.illinois.edu)\nand\nwe\nwill\ndeal\nwith\nyour\nsituation\non\na\ncase-by-case\nbasis\nvia\nthe\ncourse\nadmin\n(cs341admin@cs.illinois.edu).\nFor\nillness-related\nexcuses,\nyou\nwill\nneed\na\ndoctor\u2019s\nnote\nof\nsome\nkind\nverifying\nyour\nillness.\nN o\nillness-related\nexcuses\nwill\nbe\naccepted\nwithout\na\ndated\nEmergency\nDean\u2019s\nnote\nstating\nthat\nyou\ncontacted\nthe\nEmergency\nDean.\nLab\nattendance\ncredit\nwill\nn o t\nbe\ngiven\nunless\nyou\nare\nphysically\npresent\nin\nlab\n(there\nis\nno\npoint\nasking\nthe\nadmin\nfor\nthis\nif\nyou\nare\nsick\nor\naway).\nLab\nattendance\nreduces\nthe\nfraction\ncontribution\nfrom\nyour\n\ufb01nal\nexam\nby\na\nsmall\namount.\nThis\nis\na\nsmall\nreward\nfor\nattending.\nUse\nof\nLar ge\nLanguage\nModels,\nCode\nAssistants,\nand\ngener ativ e\nAI\nModels\nYou\nmay\nuse\nLarge\nLanguage\nAI\nModels\n(e.g.\nGithub\nCopilot,\nChatGPT,\nand\nother\nmodels)\nin\nthis\nclass\nwith\nthe\nfollowing\nconditions-\n\u25cf\nYou\nmust\ndocument\ntheir\nuse\nin\nyour\ncode.\nClearly\ndescribe\nwhich\nparts\nof\nyour\nsubmitted\ncode\nwere\ngenerated\nautomatically.\n\u25cf\nDocument\nwhen\nyou\nused\nan\nAI\nmodel\nas\npart\nof\nyour\ndevelopment\nprocess\nand\nhow\nwell\nit\nworked.\nSpeci\ufb01cally,\nin\nyour\ncode\ncomments\ndescribe\nif\nyou\nused\nan\nAI\nmodel\nto\nassist\nin\nyour\ninitial\ndesign,\ninitial\nimplementation,\ndeveloping\ntest\ncode,\ndebugging\ncode\nor\nother\nsoftware\ndevelopment\nprocess.\nAcademic\nIntegrity\nCS\n341\nis\nconsidered\na\ncritical\nstep\nin\nyour\nability\nto\ncreate\nuseful\nprograms\nfor\nyour\nlater\nclasses\nand\nbeyond.\nUnfortunately\nfor\ngrading\npurposes,\na\nminority\nof\nstudents\nsubmit\ncode\nthat\nwas\ncreated\nby\nothers.\nCheating\nis\ntaken\nvery\nseriously,\nand\nall\ncases\nof\ncheating\nwill\nbe\nbrought\nto\nthe", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1688, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "904efe8a-f578-46df-b7b6-bcdd06262bd1": {"__data__": {"id_": "904efe8a-f578-46df-b7b6-bcdd06262bd1", "embedding": null, "metadata": {"page_label": "10", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "392b824c-3e31-457b-9b2d-33c0dae061e4", "node_type": "4", "metadata": {"page_label": "10", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a109fa6d169a28e71cf92a7ac6bcd736eb3a37461bc4b455d1d0d9e7396c791e", "class_name": "RelatedNodeInfo"}}, "text": "University,\nyour\ndepartment,\nand\nyour\ncollege.\nYou\nshould\nunderstand\nhow\nacademic\nintegrity\napplies\nto\nComputer\nScience\ncourses.\nRule\nof\nThumb:\nIf\nat\nany\npoint\nyou\nsubmit\nan\nassignment\nthat\ndoes\nnot\nre\ufb02ect\nyour\nunderstanding\nof\nthe\nmaterial,\nthen\nyou\nhave\nprobably\ncheated.\nIn\nthe\ncases\nof\nlabs,\nyou\nare\nallowed\nto\ncollaborate\nwith\nothers\nin\nthe\nclass,\nwhich\nincludes\ndetailed\ndebugging\nand\ncode\nsharing.\nAll\nyou\nneed\nto\ndo\nis\nput\nyour\npartners\u2019\nnetid\nat\nthe\ntop.\nThis\ndoes\nn o t\nmean\nthat\nwill\nyou\nshare\nthe\nsame\ngrade\nfor\nthe\nassignment,\nand\neach\ngroup\nmember\nmust\nsubmit\na\nsolution\nto\nreceive\ncredit.\nEVERY\nMACHINE\nPROBLEM\nIS\nA\nSOLO\nASSIGNMENT\nIN\nTHIS\nCLASS!\nThis\nmeans\nyou\nare\nnot\nallowed\nto\nsplit\nthe\nwork\nwith\na\npartner.\nYou\nare,\nhowever,\nallowed\nto\ndiscuss\nthe\nassignments\nat\na\nvery\nhigh\nlevel.\nYou\ncan\neven\nshare\ntesting\nscripts!\nIf\nyou\nare\nfound\nto\nhave\nshared\ncode\nwork\non\nany\nmachine\nproblem,\nyou\nwill\nreceive\na\nzero\non\nthat\nassignment\nand\na\n10%\nsanction\nin\nthe\ncourse\nfor\neach\ninfraction\nwhere\nyou\nare\nfound\nto\nhave\nused\nmaterial\nthat\nis\nnot\nyours.\nYou\nmay\nnot\npublish\nyour\nsolutions\nor\nleave\nthem\nin\n\u201cplain\nview\u201d,\nthereby\nleaving\nyour\nprograms\nopen\nto\ncopying,\nwhich\nconstitutes\ncheating.\nIf\nyour\ncode\n(or\na\nvariation\nof\nit)\nis\nfound\npublicly\naccessible,\nthen\nyou\nwill\nreceive\na\nletter\ngrade\nreduction\nin\nthe\nclass\nfor\neach\ninfraction.\nDo\nnot\nput\nyour\ncode\nanywhere\nbesides\nyour\nprivate\ncourse\nrepository\nand\ntake\nmeasures\nto\nensure\nthat\nnobody\ncan\ncopy\nyour\ncode,\nso\nthat\nyou\nare\nnot\ncharged\nwith\na\nviolation.\nIn\nthe\ncase\nof\nquizzes\nin\nthe\nCBTF,\nit\nis\na\nviolation\nof\nour\ncourse\npolicy\nto\naccess\nor\nprovide\naccess\nto\nthe\nquiz\nmaterial\noutside\nyour\nregistered\nwindow.\nCheating\nat\nCBTF\nmay\nalso\nresult\nin\nimmediate\nfailure\nof\nthe\ncourse\nand\nfurther\naction\nby\nthe\ncollege\nof\nengineering.\nIf\nyou\nare\nfound\nto\nhave\ndone\nso\nyou\nwill\nreceive\na\nzero\non\nthe\nquiz\nand\na\n10%\nsanction\nin\nthe\ncourse.\nThis\nincludes\nseeking\ndescriptions\nof\nthe\nquestions\nfrom\nstudents\nwho\nhave\ntaken\nthe\nquiz,\nas\nwell\nas\nany\nother\nmethod\nthat\nwould\ngive\nyou\naccess\nto\nthe\nquiz", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2058, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "133a796b-9c78-400f-8fd2-9f77f85a80b8": {"__data__": {"id_": "133a796b-9c78-400f-8fd2-9f77f85a80b8", "embedding": null, "metadata": {"page_label": "11", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e170daba-74a2-497a-bdd7-4da84ff21e8e", "node_type": "4", "metadata": {"page_label": "11", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "961d61e0d19057f87131f78e8fc23053844c2f5651bac76e75956a68cb30b9d8", "class_name": "RelatedNodeInfo"}}, "text": "outside\nyour\nscheduled\ntime.\nIf\nthere\nis\nprep\nmaterial\nprovided\nin\nlecture\nor\non\nthe\ncourse\nforums,\nyou\nare\nwelcome\nto\nshare\nthat\nmaterial\nfreely.\nWe\nwant\nyou\nto\nget\nthe\nmost\nout\nyour\neducation,\nand\ncheating\nnot\nonly\naffects\nyour\npeers,\nbut\nalso\nyour\nlevel\nof\nknowledge\nand\nability.\nYou\nmay\nuse\nAI\nand\nother\ncode-assist\ntools\n-\nsee\nAI\nstatement\nabove.\nLandAcknowledgementStatement\nLand\nAcknowledgment\nStatement\nPlease\nsee\nour\nimportant\nDiversity\nStatement\nhere\n.\nSexual\nMisconduct\nP olicy\nand\nRepor ting\nStatement\nPlease\nsee\nour\nimportant\nDiversity\nStatement\nhere\n.\nDiv ersity\nStatement\nPlease\nsee\nour\nimportant\nDiversity\nStatement\nhere\n.\nMental\nHealth\nStatement\nPlease\nsee\nour\nimportant\nMental\nHealth\nStatement\nhere\n.\nCS\nCar es\nStatement\nPlease\nsee\nour\nimportant\nCS\nCares\nStatement\nhere\n.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 789, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "94585289-8d07-470e-9b71-82e1b4024687": {"__data__": {"id_": "94585289-8d07-470e-9b71-82e1b4024687", "embedding": null, "metadata": {"page_label": "324", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "fc825bf2-ed57-4898-b758-79f8e272eaa2", "node_type": "4", "metadata": {"page_label": "324", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "0eda29c3ef70055e20ea63ddeb034ba994811c6fbc22fbe61b08cbc337e9933d", "class_name": "RelatedNodeInfo"}}, "text": "17\nAppendix\n17.1 Shell\nA shell is actually how you are going to be interacting with the system. Before user-friendly operating systems,\nwhen a computer started up all you had access to was a shell. This meant that all of your commands and editing\nhad to be done this way . Nowadays, our computers boot up in desktop mode, but one can still access a shell using\na terminal.\n(Stuff) $\nIt is ready for your next command! You can type in a lot of Unix utilities like ls,echo Hello and the shell\nwill execute them and give you the result. Some of these are what are known as shell-builtins meaning that\nthe code is in the shell program itself. Some of these are compiled programs that you run. The shell only looks\nthrough a special variable called path which contains a list of colon separated paths to search for an executable\nwith your name, here is an example path.\n$echo $PATH\n/usr/ local /sbin:/usr/ local /bin:/usr/sbin:\n/usr/bin:/sbin:/bin:/usr/games:/usr/ local /games\nSo when the shell executes ls, it looks through all of those directories, \ufb01nds /bin/ls and executes that.\n$ ls\n...\n$ /bin/ls\nYou can always call through the full path. That is always why in past classes if you want to run something on\n324", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1211, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5a30a69b-a419-4a73-8dfa-1e3d97ebc0c6": {"__data__": {"id_": "5a30a69b-a419-4a73-8dfa-1e3d97ebc0c6", "embedding": null, "metadata": {"page_label": "325", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e44e1708-fa1a-4e97-be98-7f43f4eb361a", "node_type": "4", "metadata": {"page_label": "325", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9766426f4f7e569a79fed855e09d05795bfce1c38fee33f3c50a304e46df5360", "class_name": "RelatedNodeInfo"}}, "text": "17.1. SHELL 325\nthe terminal you\u2019ve had to do ./exe because typically the directory that you are working in is not in the PATH\nvariable. The .expands to your current directory and your shell executes <current_dir>/exe which is a valid\ncommand.\n17.1.1 Shell tricks and tips\n\u2022The up arrow will get you your most recent command\n\u2022ctrl-r will search commands that you previously ran\n\u2022ctrl-c will interrupt your shell\u2019s process\n\u2022!!will execute the last command\n\u2022!<num> goes back that many commands and runs that\n\u2022!<prefix> runs the last command that has that pre\ufb01x\n\u2022!$is the last arg of the previous command\n\u2022!*is all args of the previous command\n\u2022\u02c6pat\u02c6subtakes the last command and substitutes the pattern pat for the substitution sub\n\u2022cd - goes to the previous directory\n\u2022pushd <dir> pushes the current directory on a stack and cds\n\u2022popd cds to the directory at the top of the stack\n17.1.2 What\u2019s a terminal?\nA terminal is an application that displays the output from the shell. You can have your default terminal, a quake\nbased terminal, terminator, the options are endless!\n17.1.3 Common Utilities\n1.catconcatenate multiple \ufb01les. It is regularly used to print out the contents of a \ufb01le to the terminal but the\noriginal use was concatenation.\n$cat file.txt\n...\n$cat shakespeare.txt shakespeare.txt >two_shakes.txt\n2.diff tells you the difference between the two \ufb01les. If nothing is printed, then zero is returned meaning the\n\ufb01les are the same byte for byte. Otherwise, the longest common subsequence difference is printed", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1518, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed70dfde-19d6-46a5-9891-a329c02f9af2": {"__data__": {"id_": "ed70dfde-19d6-46a5-9891-a329c02f9af2", "embedding": null, "metadata": {"page_label": "326", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8cccc794-d1e2-47e7-b770-1956fab8942a", "node_type": "4", "metadata": {"page_label": "326", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "0ba660c19815ca7663b6985ebb1b544b085e20f0a51dcb4b7210d811062fd6f3", "class_name": "RelatedNodeInfo"}}, "text": "326 CHAPTER 17. APPENDIX\n$cat prog.txt\nhello\nworld\n$cat adele.txt\nhello\nit\u2019sme\n$diff prog .txt prog .txt\n$diff shakespeare .txt shakespeare .txt\n2c2\n<world\n---\n>it\u2019s me\n3.grep tells you which lines in a \ufb01le or standard input match a POSIX pattern.\n$ grep it adele.txt\nit\u2019sme\n4.lstells you which \ufb01les are in the current directory .\n5.cdthis is a shell builtin but it changes to a relative or absolute directory\n$cd/usr\n$cdlib/\n$cd-\n$pwd\n/usr/\n6.manevery system programmers favorite command tells you more about all your favorite functions!\n7.make executes programs according to a make\ufb01le.\n17.1.4 Syntactic\nShells have many useful utilities like saving some output to a \ufb01le using redirection >. This overwrites the \ufb01le from\nthe beginning. If you only meant to append to the \ufb01le, you can use \u00bb. Unix also allows \ufb01le descriptor swapping.\nThis means that you can take the output going to one \ufb01le descriptor and make it seem like it\u2019s coming out of\nanother. The most common one is 2>1which means take the stderr and make it seem like it is coming out of\nstandard out. This is important because when you use >and\u00bbthey only write the standard output of the \ufb01le.\nThere are some examples below.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1184, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "98ebb1c2-1437-4045-a5ca-44740f952a03": {"__data__": {"id_": "98ebb1c2-1437-4045-a5ca-44740f952a03", "embedding": null, "metadata": {"page_label": "327", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d0d481c5-a8a6-40cd-bd59-ab47cb6de26d", "node_type": "4", "metadata": {"page_label": "327", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d0112c20de93b7b90d9d5bb627eacb129618ef2457da8405908012b2735d8b5f", "class_name": "RelatedNodeInfo"}}, "text": "17.1. SHELL 327\n$ ./program >output.txt #Tooverwrite\n$ ./program >>output.txt #Toappend\n$ ./program 2 >&1>output_all.txt #stderr &stdout\n$ ./program 2 >&1>/dev/null #don\u2019tcare about any output\nThe pipe operator has a fascinating history . The UNIX philosophy is writing small programs and chaining them\ntogether to do new and interesting things. Back in the early days, hard disk space was limited and write times\nwere slow. Brian Kernighan wanted to maintain the philosophy while omitting intermediate \ufb01les that take up\nhard drive space. So, the UNIX pipe was born. A pipe takes the stdout of the program on its left and feeds it\nto the stdin of the program on its write. Consider the command tee. It can be used as a replacement for the\nredirection operators because tee will both write to a \ufb01le and output to standard out. It also has the added bene\ufb01t\nthat it doesn\u2019t need to be the last command in the list. Meaning, that you can write an intermediate result and\ncontinue your piping.\n$ ./program | tee output.txt #Overwrite\n$ ./program | tee -a output.txt #Append\n$ head output.txt | wc | head -n 1 #Multi pipes\n$ ((head output.txt) | wc) | head -n 1 #Same asabove\n$ ./program | tee intermediate.txt | wc\nThe and ||operator are operators that execute a command sequentially . only executes a command if the\nprevious command succeeds, and ||always executes the next command.\n$false &&echo \"Hello !\"\n$true &&echo \"Hello !\"\n$false ||echo \"Hello !\"\n17.1.5 What are environment variables?\nEach process gets its own dictionary of environment variables that are copied over to the child. Meaning, if the\nparent changes their environment variables it won\u2019t be transferred to the child and vice versa. This is important in\nthe fork-exec-wait trilogy if you want to exec a program with different environment variables than your parent\n(or any other process).\nFor example, you can write a C program that loops through all of the time zones and executes the date\ncommand to print out the date and time in all locals. Environment variables are used for all sorts of programs so\nmodifying them is important.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2098, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "16cd6dd9-e80e-48c1-a0fd-6ff5ee351566": {"__data__": {"id_": "16cd6dd9-e80e-48c1-a0fd-6ff5ee351566", "embedding": null, "metadata": {"page_label": "328", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cea8dda1-dd4d-4a41-900a-409eb619daa0", "node_type": "4", "metadata": {"page_label": "328", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7777544f6d491969e34ce524e9ee84304863e99853a6617b97bdfa1783e12b3d", "class_name": "RelatedNodeInfo"}}, "text": "328 CHAPTER 17. APPENDIX\nStruct packing\nStructs may require something called padding (tutorial). We do not expect you to pack structs in this course,\nknow that compilers perform it . This is because in the early days (and even now) loading an address in memory\nhappens in 32-bit or 64-bit blocks. This also meant requested addresses had to be multiples of block sizes.\nstruct picture {\nint height ;\npixel** data ;\nint width ;\nchar * encoding ;\n}\nYou think the picture looks like this. One box is four bytes.\nh wdata encoding\nFigure 17.1: Six box struct\nHowever, with struct packing, it would conceptually look like this:\nstruct picture {\nint height ;\nchar slop1[4] ;\npixel** data ;\nint width ;\nchar slop2[4] ;\nchar * encoding ;\n}\nVisually , we\u2019d add two extra boxes to our diagram", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 780, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8e25f32d-7f79-4ea7-8201-cb13362f4a16": {"__data__": {"id_": "8e25f32d-7f79-4ea7-8201-cb13362f4a16", "embedding": null, "metadata": {"page_label": "329", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "90e4869f-66ca-400a-9179-f09ca6b1ed8f", "node_type": "4", "metadata": {"page_label": "329", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "56b56803564246495603f7774fdc96fc168dbfd48986bf57534373251000f83c", "class_name": "RelatedNodeInfo"}}, "text": "17.2. STACK SMASHING 329\nh? w? data encoding\nFigure 17.2: Eight box struct, two boxes of slop\nThis padding is common on a 64-bit system. Other time, a processor supports unaligned access, leaving the\ncompiler able to pack structs. What does this mean? We can have a variable start at a non-64-bit boundary . The\nprocessor will \ufb01gure out the rest. To enable this, set an attribute.\nstruct __attribute__((packed, aligned(4))) picture {\nint height ;\npixel** data ;\nint width ;\nchar * encoding ;\n}\nNow our \ufb01gure will look like the clean struct as in \ufb01gure 17.1 But now, every time the processor needs to\naccess data orencoding , two memory accesses are required. A possible alternative is to reorder the struct.\nstruct picture {\nint height ;\nint width ;\npixel** data ;\nchar * encoding ;\n}\n17.2 Stack Smashing\nEach thread uses a stack memory . The stack \u2018grows downwards\u2019 - if a function calls another function, then the stack\nis extended to smaller memory addresses. Stack memory includes non-static automatic (temporary) variables,\nparameter values, and the return address. If a buffer is too small some data (e.g. input values from the user),\nthen there is a real possibility that other stack variables and even the return address will be overwritten. The\nprecise layout of the stack\u2019s contents and order of the automatic variables is architecture and compiler dependent.\nWith a little investigative work, we can learn how to deliberately smash the stack for a particular architecture.\nThe example below demonstrates how the return address is stored on the stack. For a particular 32 bit", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1585, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1d70d226-442c-4872-a50f-ac778cf1e0b5": {"__data__": {"id_": "1d70d226-442c-4872-a50f-ac778cf1e0b5", "embedding": null, "metadata": {"page_label": "330", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "051b9327-424d-4380-8850-65707eab7580", "node_type": "4", "metadata": {"page_label": "330", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a93955047bf663703a420fd4ec9ebfd8c3618e921433d99be3bee6fbaa4e0870", "class_name": "RelatedNodeInfo"}}, "text": "330 CHAPTER 17. APPENDIX\narchitecture Live Linux Machine, we determine that the return address is stored at an address two pointers (8\nbytes) above the address of the automatic variable. The code deliberately changes the stack value so that when the\ninput function returns, rather than continuing on inside the main method, it jumps to the exploit function instead.\n//Overwrites the return address onthe following machine :\n//http ://cs-education .github .io/sys/\n#include <stdio.h >\n#include <stdlib.h >\n#include <unistd.h >\nvoid breakout() {\nputs( \"Welcome .Have ashell ...\");\nsystem( \"/bin/sh\");\n}\nvoid input() {\nvoid *p;\nprintf( \"Address ofstack variable :%p\\n\", &p) ;\nprintf( \"Something that looks like areturn address onstack :%p\\n\",\n*((&p)+2)) ;\n//Let\u2019schange ittopoint tothe start ofour sneaky function .\n*((&p)+2) = breakout ;\n}\nint main() {\nprintf( \"main ()code starts at%p\\n\",main) ;\ninput() ;\nwhile (1) {\nputs( \"Hello \");\nsleep(1) ;\n}\nreturn 0;\n}\nThere are a lot of ways that computers tend to get around this.\n17.3 Compiling and Linking\nThis is a high-level overview from the time you compile your program to the time you run your program. We often\nknow that compiling your program is easy . You run the program through an IDE or a terminal, and it just works.\n$cat main.c\n#include <stdio.h >", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1305, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aab0b21c-710d-4cda-99d3-b3b6a11b4909": {"__data__": {"id_": "aab0b21c-710d-4cda-99d3-b3b6a11b4909", "embedding": null, "metadata": {"page_label": "331", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "56da1b7e-55cd-4559-9cfc-a341588f3709", "node_type": "4", "metadata": {"page_label": "331", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "fc076b7415bd678c3841e53d9db4cd8f1cbe46c9fa0ec721c7b130fa90a61375", "class_name": "RelatedNodeInfo"}}, "text": "17.3. COMPILING AND LINKING 331\nint main() {\nprintf (\"Hello World !\\n\");\nreturn 0;\n}\n$ gcc main.c -o main\n$ ./main\nHello World!\n$\nHere are the rough stages of compiling for gcc.\n1.Preprocessing: The preprocessor expands all preprocesor directives.\n2.Parsing: The compiler parses the text \ufb01le for function declarations, variable declarations, etc.\n3.Assembly Generation: The compiler then generates assembly code for all the functions after some optimiza-\ntions if enabled.\n4.Assembling: The assembler turns the assembly into 0s and 1s and creates an object \ufb01le. This object \ufb01le\nmaps names to pieces of code.\n5.Static Linking: The linker then takes a series of objects and static libraries and resolves references of variables\nand functions from one object \ufb01le to another. The linker then \ufb01nds the main method and makes that the\nentry point for the function. The linker also notices when a function is meant to be dynamically linked. The\ncompiler also creates a section in the executable that tells the operating system that these functions need\naddresses right before running.\n6.Dynamic Linking: As the program is getting ready to be executed, the operating system looks at what\nlibraries that the program needs and links those functions to the dynamic library .\n7.The program is run.\nFurther classes will teach you about parsing and assembly \u2013 preprocessing is an extension of parsing. Most\nclasses won\u2019t teach you about the two different types of linking though. Static linking a library is similar to\ncombining object \ufb01les. To create a static library , a compiler combines different object \ufb01les to create one executable.\nA static library is literally is an archive of object \ufb01les. These libraries are useful when you want your executable to\nbe secure, you know all the code that is being included into your executable, and portable, all the code is bundled\nwith your executable meaning no additional installs.\nThe other type is a dynamic library . Typically , dynamic libraries are installed user-wide or system-wide and\nare accessible by most programs. Dynamic libraries\u2019 functions are \ufb01lled in right before they are run. There are a\nnumber of bene\ufb01ts to this.\n\u2022Lower code footprint for common libraries like the C standard library\n\u2022Late binding means more generalized code and less reliance on speci\ufb01c behavior.\n\u2022Differentiation means that the shared library can be updated while keeping the executable the same.\nThere are a number of drawbacks as well.\n\u2022All the code is no longer bundled into your program. This means that users have to install something else.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2566, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c9ce1c2-f8b0-4fa6-b153-6e513510d2c3": {"__data__": {"id_": "0c9ce1c2-f8b0-4fa6-b153-6e513510d2c3", "embedding": null, "metadata": {"page_label": "332", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "41aae94c-6c33-4f89-bfdc-17bef1b1b595", "node_type": "4", "metadata": {"page_label": "332", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "981da02b1cfe075891042092731a0216f9b078ee04f85c978c535632b46743b0", "class_name": "RelatedNodeInfo"}}, "text": "332 CHAPTER 17. APPENDIX\n\u2022There could be security \ufb02aws in the other code leading to security exploits in your program.\n\u2022Standard Linux allows you to \"replace\" dynamic libraries, leading to possible social engineering attacks.\n\u2022This adds additional complexity to your application. Two identical binaries with different shared libraries\ncould lead to different results.\nExplanation of the Fork-FILE Problem\nTo parse the POSIX documentation, we\u2019ll have to go deep into the terminology . The sentence that sets the\nexpectation is the following\nThe result of function calls involving any one handle (the \"active handle\") is de\ufb01ned elsewhere in this\nvolume of POSIX.1-2008, but if two or more handles are used, and any one of them is a stream, the\napplication shall ensure that their actions are coordinated as described below. If this is not done, the\nresult is unde\ufb01ned.\nWhat this means is that if we don\u2019t follow POSIX to the letter when using two \ufb01le descriptors that refer to\nthe same description across processes, we get unde\ufb01ned behavior. To be technical, the \ufb01le descriptor must have\na \u201cposition\u201d meaning that it needs to have a beginning and an end like a \ufb01le, not like an arbitrary stream of\nbytes. POSIX then goes on to introduce the idea of an active handle, where a handle may be a \ufb01le descriptor or a\nFILE* pointer. File handles don\u2019t have a \ufb02ag called \u201cactive\u201d. An active \ufb01le descriptor is one that is currently being\nused for reading and writing and other operations (such as exit ). The standard says that before a fork that the\napplication or your code must execute a series of steps to prepare the state of the \ufb01le. In simpli\ufb01ed terms, the\ndescriptor needs to be closed, \ufb02ushed, or read to its entirety \u2013 the gory details are explained later.\nFor a handle to become the active handle, the application shall ensure that the actions below are\nperformed between the last use of the handle (the current active handle) and the \ufb01rst use of the\nsecond handle (the future active handle). The second handle then becomes the active handle. All\nactivity by the application affecting the \ufb01le offset on the \ufb01rst handle shall be suspended until it again\nbecomes the active \ufb01le handle. (If a stream function has as an underlying function one that affects\nthe \ufb01le offset, the stream function shall be considered to affect the \ufb01le offset.)\nSummarizing as if two \ufb01le descriptors are actively being used, the behavior is unde\ufb01ned. The other note is\nthat after a fork, the library code must prepare the \ufb01le descriptor as if the other process were to make the \ufb01le\nactive at any time. The last bullet point concerns itself with how a process prepares a \ufb01le descriptor in our case.\nIf the stream is open with a mode that allows reading and the underlying open \ufb01le description refers\nto a device that is capable of seeking, the application shall either perform an f\ufb02ush(), or the stream\nshall be closed.\nThe documentation says that the child needs to perform an f\ufb02ush or close the stream because the \ufb01le descriptor\nneeds to be prepared in case the parent process needs to make it active. glibc is in a no-win situation if it closes\na \ufb01le descriptor that the parent may expect to be open, so it\u2019ll opt for the f\ufb02ush on exit because exit in POSIX\nterminology counts as accessing a \ufb01le. That means that for our parent process, this clause gets triggered.\nIf any previous active handle has been used by a function that explicitly changed the \ufb01le offset,\nexcept as required above for the \ufb01rst handle, the application shall perform an lseek() or fseek() (as\nappropriate to the type of handle) to an appropriate location.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3603, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5495b377-23fa-4910-81ed-50fa61522076": {"__data__": {"id_": "5495b377-23fa-4910-81ed-50fa61522076", "embedding": null, "metadata": {"page_label": "333", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9dc87bfc-33c2-4cc5-971c-132f9941654e", "node_type": "4", "metadata": {"page_label": "333", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3aec107663c240860dc9fa8d1cb0ec09dd6698a2c0091851d545fab9c4294e8e", "class_name": "RelatedNodeInfo"}}, "text": "17.4. BANKER\u2019S ALGORITHM 333\nSince the child calls f\ufb02ush and the parent didn\u2019t prepare, the operating system chooses to where the \ufb01le gets\nreset. Different \ufb01le systems will do different things which are supported by the standard. The OS may look at\nmodi\ufb01cation times and conclude that the \ufb01le hasn\u2019t changed so no resets are needed or may conclude that exit\ndenotes a change and needs to rewind the \ufb01le back to the beginning.\n17.4 Banker\u2019s Algorithm\nWe can start with a single resource Banker\u2019s Algorithm. Consider a banker, who has a \ufb01nite amount of money .\nWith a \ufb01nite amount of money , she wants to make loans and eventually get her money back. Let\u2019s say that we\nhave a set of npeople where each of them has a set amount or a limit ai(ibeing the ith process) that they need\nto obtain before they can do any work. The banker keeps track of how much she has given to each person li.\nShe maintains an amount of money pwith her, at all times. For people to request money , they do the following:\nConsider the state of the system (A={a1,a2, ...},Lt={lt,1,lt,2, ...},p)at time t. A precondition is that we have\np\u2265min(A), or we have enough money to suit at least one person. Also, each person will work for a \ufb01nite period\nand give back our money .\n\u2022A person jrequests mfrom me\n\u2013ifm\u2265p, they are denied.\n\u2013ifm+lj>aithey are denied\n\u2013Pretend we are in a new state (A,Lt+1={..,lt+1,j=lt,j+m, ...},p\u2212m)where the process is granted\nthe resource.\n\u2022if now person jis either satis\ufb01ed ( lt+1,j==aj) or min(ai\u2212lt+1,i)\u2264p. In other words, we have enough\nmoney to suit one other person. If either, consider the transaction safe and give them the money .\nWhy does this work? Well at the start we are in a safe state \u2013 de\ufb01ned by we have enough money to suit at\nleast one person. Each of these \"loans\" results in a safe state. If we have exhausted our reserve, one person is\nworking and will give us money greater than or equal to our previous \"loan\", thus putting us in a safe state again.\nSince we can always make one additional move, the system can never deadlock. Now, there is no guarantee that\nthe system won\u2019t livelock. If the process we hope to request something never does, no work will be done \u2013 but\nnot due to deadlock. This analogy expands to higher orders of magnitude but requires that either a process can\ndo its work entirely or there exists a process whose combination of resources can be satis\ufb01ed, which makes the\nalgorithm a little more tricky (an additional for loop) but nothing too bad. There are some notable downsides.\n\u2022The program \ufb01rst needs to know how much of each resource a process needs. A lot of times that is impossible\nor the process requests the wrong amount because the programmer didn\u2019t foresee it.\n\u2022The system could livelock.\n\u2022We know in most systems that resources vary , pipes and sockets for example. This could mean that the\nruntime of the algorithm could be slow for systems with millions of resources.\n\u2022Also, this can\u2019t keep track of the resources that come and go. A process may delete a resource as a side\neffect or create a resource. The algorithm assumes a static allocation and that each process performs a\nnon-destructive operation.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3159, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "159c69a2-b9fc-476c-a5d3-059981abd0af": {"__data__": {"id_": "159c69a2-b9fc-476c-a5d3-059981abd0af", "embedding": null, "metadata": {"page_label": "334", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "fb61839b-72af-415e-9157-612f7318e55c", "node_type": "4", "metadata": {"page_label": "334", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "0a61b89d7403c60cff4274ee9df0a1b252002d550aaceed4295d114d2256d813", "class_name": "RelatedNodeInfo"}}, "text": "334 CHAPTER 17. APPENDIX\n17.5 Clean /Dirty Forks (Chandy /Misra Solution)\nThere are many more advanced solutions. One such solution is by Chandy and Misra [?]. This is not a true\nsolution to the dining philosophers problem because it has the requirement that philosophers can speak to each\nother. It is a solution that ensures fairness for some notion of fairness. In essence, it de\ufb01nes a series of rounds that\na philosopher must eat in a given round before going to the next one.\nWe won\u2019t detail the proof here because it is a little more involved, but feel free to read more.\n17.6 Actor Model\nThe actor model is another form of synchronization that doesn\u2019t have to do anything with negotiating locks or\nwaiting. The idea is simple. Each actor can either perform work, create more actors, send messages, or respond to\nmessages. Any time an actor needs something from another actor, it sends a message. Most importantly , an actor\nis only responsible for one thing. If we were implementing a real-world application, we may have an actor that\nhandles the database, one that handles the incoming connections, one that services the connections, etc. These\nactors would pass messages to each other like \u201cthere is a new connection\u201d from the incoming connection actor\nto the servicing actor. The servicing actor may send a data request message to the database actor and a data\nresponse message comes back.\nWhile this seems like the perfect solution there are drawbacks. The \ufb01rst is the actual library of communication\nneeds to be synchronized. If you don\u2019t have a framework that does this already \u2013 like the Message Passing Interface\nor MPI for High-Performance Computing \u2013 then the framework will have to be built and would most likely be as\nmuch work to build ef\ufb01ciently compared to direct synchronization. Also, the messages now encounter additional\noverhead for serializing and deserializing or at the least. And a \ufb01nal drawback is that an actor could take an\narbitrarily long time to respond to a message, spurring the need for shadow actors who service the same job.\nAs mentioned, there are frameworks like Message passing interface that is somewhat based on the actor model\nand allows distributed systems in high-performance computing to work effectively , but your mileage may vary If\nyou want to read further on the model, feel free to glance over the Wikipedia page listed below. Further reading\non the actor model\n17.7 Includes and conditionals\nThe other preprocessor include is the #include directive and conditionals. The include directive is explained by\nexample.\n//foo.h\nint bar() ;\nThis is our \ufb01le bar.c unpreprocessed.\n#include \"foo.h\"", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2646, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7646e76e-84f5-4902-afab-a184a50ae987": {"__data__": {"id_": "7646e76e-84f5-4902-afab-a184a50ae987", "embedding": null, "metadata": {"page_label": "335", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "89ee9942-c3b9-4bf0-aab6-bd9db6ca16f1", "node_type": "4", "metadata": {"page_label": "335", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e7fcbd93aa44b028478bca9c4c208bf95159e5ccc01de99d0082ef8503c0cab4", "class_name": "RelatedNodeInfo"}}, "text": "17.7. INCLUDES AND CONDITIONALS 335\nint bar() {\n}\nAfter preprocessing, the compiler sees this\n//foo.cunpreprocessed\nint bar() ;\nint bar() {\n}\nThe other tool is preprocessor conditionals. If a macro is de\ufb01ned or truthy , that branch is taken.\nint main() {\n#ifdef __GNUC__\nreturn 1;\n#else\nreturn 0;\n#endif\n}\nUsing gccyour compiler would preprocess the source to the following.\nint main() {\nreturn 1;\n}\nUsing clang your compiler would preprocess to this.\nint main() {\nreturn 0;\n}\n17.7.1 Thread Scheduling\nThere are a few ways to split up the work. These are common to the OpenMP framework [?].", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 590, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "159936ab-de8f-4392-b3ed-fafd84c95604": {"__data__": {"id_": "159936ab-de8f-4392-b3ed-fafd84c95604", "embedding": null, "metadata": {"page_label": "336", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bdb69170-6db0-4358-a368-82df7cef9c8d", "node_type": "4", "metadata": {"page_label": "336", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "86993d18bcf5d28921a8a67aa5f05399f7899668a5d92b533f1bd5c5b24f08b0", "class_name": "RelatedNodeInfo"}}, "text": "336 CHAPTER 17. APPENDIX\n\u2022static scheduling breaks up the problems into \ufb01xed-size chunks (predetermined) and have each thread\nwork on each of the chunks. This works well when each of the subproblems takes roughly the same time\nbecause there is no additional overhead. All you need to do is write a loop and give the map function to\neach sub-array .\n\u2022dynamic scheduling as a new problem becomes available to have a thread serve it. This is useful when\nyou don\u2019t know how long the scheduling will take\n\u2022guided scheduling This is a mix of the above with a mix of the bene\ufb01ts and tradeoffs. You start with\nstatic scheduling and move slowly to dynamic if needed\n\u2022runtime scheduling You have absolutely no idea how long the problems are going to take. Instead of\ndeciding it yourself, let the program decide what to do!\nNo need to memorize any of the scheduling routines though. Openmp is a standard that is an alternative to\npthreads. For example, here is how to parallelize a for loop\n#pragma omp parallel for\nfor (int i = 0 ;i<n;i++){\n//Dostuff\n}\n//Specify the scheduling asfollows\n//#pragma omp parallel for scheduling (static )\nStatic scheduling will divide the problem into \ufb01xed-size chunks Dynamic scheduling will give a job once the\nloop is over Guided scheduling is Dynamic with chunks Runtime is a whole bag of worms.\n17.8 threads.h\nWe have a lot of threading libraries discussed in the extra section. We have the standard POSIX threads, OpenMP\nthreads, we also have a new C11 threading library that is built into the standard. This library provides restricted\nfunctionality .\nWhy use restricted functionality? The key is in the name. Since this is the C standard library , it has to be\nimplemented in all operating systems that are compliant which are pretty much all of them. This means there is\n\ufb01rst-class portability when using threads.\nWe won\u2019t drone on about the functions. Most of them are renaming of pthread functions anyway . If you ask\nwhy we don\u2019t teach these, there are a few reasons\n1.They are pretty new. Even though the standard came out in roughly 2011, POSIX threads have been around\nforever. A lot of their quirks have been ironed out.\n2.You lose expressivity . This is a concept that we\u2019ll talk about in later chapters, but when you make something\nportable, you lose some expressivity with the host hardware. That means that the threads.h library is pretty\nbare bones. It is hard to set CPU af\ufb01nities. Schedule threads together. Ef\ufb01ciently look at the internals for\nperformance reasons.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2510, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "58a26b75-12a1-4b2a-b489-851d81976092": {"__data__": {"id_": "58a26b75-12a1-4b2a-b489-851d81976092", "embedding": null, "metadata": {"page_label": "337", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b5eaaec0-c9a6-452a-908d-46dc7e67609c", "node_type": "4", "metadata": {"page_label": "337", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "1ade28ce3d8b83d229e546dfc7113081e71ad70801844979834f25e14b771d7d", "class_name": "RelatedNodeInfo"}}, "text": "17.9. MODERN FILESYSTEMS 337\n3.A lot of legacy code is already written with POSIX threads in mind. Other libraries like OpenMP , CUDA, MPI\nwill either use POSIX processes or POSIX threads with a begrudging port to Windows.\n17.9 Modern Filesystems\nWhile the API for most \ufb01lesystems have stayed the same on POSIX over the years, the actual \ufb01lesystems themselves\nprovide lots of important aspects.\n\u2022Data Integrity . File systems use journaling and sometimes checksums to ensure that the data written to\nis valid. Journalling is a simple invention where the \ufb01le system writes an operation in a journal. If the\n\ufb01lesystem crashes before the operation is complete, it can resume the operation when booted up again\nusing the partial journal.\n\u2022Caching. Linux does a good job of caching \ufb01le system operations like \ufb01nding inodes. This makes disk\noperations seem nearly instant. If you want to see a slow system, look at Windows with FAT /NTFS. Disk\noperations need to be cached by the application, or it will burn through the CPU.\n\u2022Speed. On spinning disk machines, data that is toward the end of a metallic platter will spin faster (angular\nvelocity is farther from the center). Programs used this to reduce time loading large \ufb01les like movies in a\nvideo editing piece of software. SSDs don\u2019t have this problem because there is no spinning disk, but they\nwill portion off a section of their space to be used as \"swap space\" for \ufb01els.\n\u2022Parallelism. Filesystems with multiple heads (for physical hard disks) or multiple controllers (for SSDs)\ncan utilize parallelism by multiplexing the PCIe slot with data, always serving some data to the application\nwhenever possible.\n\u2022Encryption. Data can be encrypted with one or more keys. A good example of this is Apple\u2019s APFS \ufb01le\nsystems.\n\u2022Redundancy . Sometimes data can be replicated to blocks to ensure that the data is always available.\n\u2022Ef\ufb01cient Backups. Many of us have data that we can\u2019t store on the cloud for one reason or another. It is\nuseful that when a \ufb01lesystems is either being used as a backup medium or is the source to the backup that it\nis able to calculate what has changed ef\ufb01ciently , compress \ufb01les, and sync between the external drive.\n\u2022Integriy and Bootability . File systems need to be resillient to bit \ufb02ipping. Most readers have their operating\nsystem installed on the same paritition as the \ufb01le system that they used to do different operations. The \ufb01le\nsystem needs to make sure a stray read or write doesn\u2019t destroy the boot sector \u2013 meaning your computer\ncan\u2019t start up again.\n\u2022Fragmentation. Just like a memory allocator, allocating space for a \ufb01le leads to both internal and external\nfragmentation. The same caching bene\ufb01t occurs when disk blocks for a single \ufb01le are located next to each\nother. File systems need to perform well under low, high, and possible fragmentation usage.\n\u2022Distributed. Sometimes, the \ufb01lesystem should be single machine fault tolerant. Hadoop and other distributed\n\ufb01le system allow you to do that.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2984, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cce19518-909c-4615-86ed-9ad1fafb3b38": {"__data__": {"id_": "cce19518-909c-4615-86ed-9ad1fafb3b38", "embedding": null, "metadata": {"page_label": "338", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "74b3311b-bd41-4da3-914f-f741221735f1", "node_type": "4", "metadata": {"page_label": "338", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ad286c837e051d1139466c5e9e51e14f069472f5a71da36ae731205af3f852fb", "class_name": "RelatedNodeInfo"}}, "text": "338 CHAPTER 17. APPENDIX\n17.9.1 Cutting Edge File systems\nThere are a few \ufb01lesystem hardware nowadays that are truly cutting edge. The one we\u2019d brie\ufb02y like to touch on is\nAMD\u2019s StoreMI. We aren\u2019t trying to sell AMD chipsets, but the featureset of StoreMI warrants a mention.\nStoreMI is a hardware microcontroller that analyzes how the operating system accesses \ufb01les and moves\n\ufb01les/blocks around to speed up the load time. A common usage can be imagined as having a fast, but small\ncapacity SSD and a slower, large capcity HDD. To make it seem like all the \ufb01les are on an SSD, the StoreMI matches\nthe pattern of \ufb01le access. If you are starting up Windows, Windows will often access many \ufb01les in the same order.\nStoreMI takes note of that and when the microcontroller notices it is starting the boot, it will move \ufb01les from the\nHDD drive to the SSD before they are requested by the operating system. By the time the operating system needs\nthen, they are already on the SSD. StoreMI also does this with other applications as well. The technology still has\na lot to be desired for, but it is an interesting intersection of data and pattern matching with \ufb01lesystems.\n17.10 Linux Scheduling\nAs of February 2016, Linux by default uses the Completely Fair Scheduler for CPU scheduling and the Budget Fair\nScheduling \u201cBFQ\u201d for I /O scheduling. Appropriate scheduling can have a signi\ufb01cant impact on throughput and\nlatency . Latency is important for interactive and soft-real time applications such as audio and video streaming.\nSee the discussion and comparative benchmarks here for more information.\nHere is how the CFS schedules\n\u2022The CPU creates a Red-Black tree with the processes virtual runtime (runtime /nice_value) and sleeper\nfairness \ufb02ag \u2013 if the process is waiting on something, give it the CPU when it is done waiting.\n\u2022Nice values are the kernel\u2019s way of giving priority to certain processes, the lower nice value the higher\npriority .\n\u2022The kernel chooses the lowest one based on this metric and schedules that process to run next, taking it off\nthe queue. Since the red-black tree is self-balancing this operation is guaranteed O(log(n))(selecting the\nmin process is the same runtime)\nAlthough it is called the Fair Scheduler there are a fair bit of problems.\n\u2022Groups of processes that are scheduled may have imbalanced loads so the scheduler roughly distributes\nthe load. When another CPU gets free it can only look at the average load of a group schedule, not the\nindividual cores. So the free CPU may not take the work from a CPU that is burning so long as the average\nis \ufb01ne.\n\u2022If a group of processes is running on non-adjacent cores then there is a bug. If the two cores are more than\na hop away , the load balancing algorithm won\u2019t even consider that core. Meaning if a CPU is free and a CPU\nthat is doing more work is more than a hop away , it won\u2019t take the work (may have been patched).\n\u2022After a thread goes to sleep on a subset of cores, when it wakes up it can only be scheduled on the cores that\nit was sleeping on. If those cores are now busy , the thread will have to wait on them, wasting opportunities\nto use other idle cores.\n\u2022To read more on the problems of the Fair Scheduler, read here.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3210, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bb65157b-db10-4def-9b5d-20e3ccf9ab8b": {"__data__": {"id_": "bb65157b-db10-4def-9b5d-20e3ccf9ab8b", "embedding": null, "metadata": {"page_label": "339", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d50d414c-102e-4555-8c3c-def649484c91", "node_type": "4", "metadata": {"page_label": "339", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c2cf3bf136272ad3e734f730046c98a12e59c9ba13123beff53cf87e21cc45e7", "class_name": "RelatedNodeInfo"}}, "text": "17.11. THE CURIOUS CASE OF SPURIOUS WAKEUPS 339\n17.10.1 Implementing Software Mutex\nYes With a bit of searching, it is possible to \ufb01nd it in production for speci\ufb01c simple mobile processors today .\nPeterson\u2019s algorithm is used to implement low-level Linux Kernel locks for the Tegra mobile processor (a system-\non-chip ARM process and GPU core by Nvidia) Link to Lock Source\nIn general now, CPUs and C compilers can re-order CPU instructions or use CPU-core-speci\ufb01c local cache\nvalues that are stale if another core updates the shared variables. Thus a simple pseudo-code to C implementation\nis too naive for most platforms. Warning, here be dragons! Consider this advanced and gnarly topic but (spoiler\nalert) a happy ending. Consider the following code,\nwhile (flag2) {/*busy loop -goaround again */\nAn ef\ufb01cient compiler would infer that flag2 variable is never changed inside the loop, so that test can be\noptimized to while(true) Using volatile goes some way to prevent compiler optimizations of this kind.\nLet\u2019s say that we solved this by telling the compiler not to optimize. Independent instructions can be re-ordered\nby an optimizing compiler or at runtime by an out-of-order execution optimization by the CPU.\nA related challenge is that CPU cores include a data cache to store recently read or modi\ufb01ed main memory\nvalues. Modi\ufb01ed values may not be written back to main memory or re-read from memory immediately . Thus\ndata changes, such as the state of a \ufb02ag and turn variable in the above example, may not be shared between two\nCPU codes.\nBut there is a happy ending. Modern hardware addresses these issues using \u2018memory fences\u2019 also known as a\nmemory barrier. This prevents instructions from getting ordered before or after the barrier. There is a performance\nloss, but it is needed for correct programs!\nAlso, there are CPU instructions to ensure that main memory and the CPU\u2019s cache is in a reasonable and\ncoherent state. Higher-level synchronization primitives, such as pthread_mutex_lock are will call these CPU\ninstructions as part of their implementation. Thus, in practice, surrounding critical sections with a mutex lock and\nunlock calls is suf\ufb01cient to ignore these lower-level problems.\nFor further reading, we suggest the following web post that discusses implementing Peterson\u2019s algorithm on\nan x86 process and the Linux documentation on memory barriers.\n1.Memory Fences\n2.Memory Barriers\n17.11 The Curious Case of Spurious Wakeups\nCondition variables need a mutex for a few reasons. One is simply that a mutex is needed to synchronize the\nchanges of the condition variable across threads. Imagine a condition variable needing to provide its own internal\nsynchronization to ensure its data structures work correctly . Often, we use a mutex to synchronize other parts of\nour code, so why double the cost of using a condition variable. Another example relates to high priority systems.\nLet\u2019s examine a code snippet.\n//Thread 1\nwhile (answer <42) pthread_cond_wait(cv) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2990, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7d93967a-a2cb-497b-a84a-2ebe92ac5c92": {"__data__": {"id_": "7d93967a-a2cb-497b-a84a-2ebe92ac5c92", "embedding": null, "metadata": {"page_label": "340", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "700879ea-fa69-47f0-a484-f59e5a33222a", "node_type": "4", "metadata": {"page_label": "340", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7c449da9d0cedbecbdb787b93ade6b574a94a5722be467a37cbe1c13927ab1c3", "class_name": "RelatedNodeInfo"}}, "text": "340 CHAPTER 17. APPENDIX\n//Thread 2\nanswer = 42\npthread_cond_signal(cv) ;\nTable 17.1: Signaling without Mutex\nThread 1 Thread 2\nwhile(answer <42)\nanswer ++\npthread_cond_signal(cv)\npthread_cond_wait(cv)\nThe problem here is that a programmer expects the signal to wake up the waiting thread. Since instructions are\nallowed to be interleaved without a mutex, this causes an interleaving that is confusing to application designers.\nNote that technically the API of the condition variable is satis\ufb01ed. The wait call happens-after the call to signal,\nand signal is only required to release at most a single thread whose call to wait happened-before .\nAnother problem is the need to satisfy real-time scheduling concerns which we only outline here. In a time-\ncritical application, the waiting thread with the highest priority should be allowed to continue \ufb01rst. To satisfy this\nrequirement the mutex must also be locked before calling pthread_cond_signal orpthread_cond_broadcast .\nFor the curious, here is a longer, historical discussion.\n17.12 Condition Wait Example\nThe call pthread_cond_wait performs three actions:\n1.Unlock the mutex. The mutex must be locked.\n2.Sleeps until pthread_cond_signal is called on the same condition variable.\n3.Before returning, locks the mutex.\nCondition variables are always used with a mutex lock. Before calling wait, the mutex lock must be locked\nandwait must be wrapped with a loop.\npthread_cond_t cv ;\npthread_mutex_t m ;\nint count ;\n//Initialize\npthread_cond_init(&cv, NULL) ;\npthread_mutex_init(&m, NULL) ;\ncount = 0 ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1555, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ab81c9ac-97ca-4608-9176-b482eb3485a1": {"__data__": {"id_": "ab81c9ac-97ca-4608-9176-b482eb3485a1", "embedding": null, "metadata": {"page_label": "341", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6419b92c-682e-456d-8f81-e870e89e41d1", "node_type": "4", "metadata": {"page_label": "341", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4b3e9d46dc3546232dfcb86f91c1af199e4ea6a8888f2ca384ef11b6f437e30c", "class_name": "RelatedNodeInfo"}}, "text": "17.13. IMPLEMENTING CVS WITH MUTEXES ALONE 341\n//Thread 1\npthread_mutex_lock(&m) ;\nwhile (count <10) {\npthread_cond_wait(&cv, &m) ;\n/*Remember that cond_wait unlocks the mutex before blocking\n(waiting )!*/\n/*After unlocking ,other threads can claim the mutex .*/\n/*When this thread islater woken itwill */\n/*re-lock the mutex before returning */\n}\npthread_mutex_unlock(&m) ;\n//later clean upwith pthread_cond_destroy (&cv);and mutex_destroy\n//Thread 2:\nwhile (1) {\npthread_mutex_lock(&m) ;\ncount ++;\npthread_cond_signal(&cv) ;\n/*Even though the other thread iswoken upitcannot not return */\n/*from pthread_cond_wait until wehave unlocked the mutex .This is*/\n/*agood thing !Infact ,itisusually the best practice tocall */\n/*cond_signal orcond_broadcast before unlocking the mutex */\npthread_mutex_unlock(&m) ;\n}\nThis is a pretty naive example, but it shows that we can tell threads to wake up in a standardized manner. In\nthe next section, we will use these to implement ef\ufb01cient blocking data structures.\n17.13 Implementing CVs with Mutexes Alone\nImplementing a condition variable using only a mutex isn\u2019t trivial. Here is a sketch of how we could do it.\ntypedef struct cv_node_ {\npthread_mutex_t *dynamic ;\nint is_awoken ;\nstruct cv_node_ *next ;\n}cv_node ;\ntypedef struct {\ncv_node_ *head\n}cond_t", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1299, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "85c8f08f-1796-408c-9fc5-a42cd02b5677": {"__data__": {"id_": "85c8f08f-1796-408c-9fc5-a42cd02b5677", "embedding": null, "metadata": {"page_label": "342", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "74543c26-6735-4e29-8b30-0c83c37e4eb2", "node_type": "4", "metadata": {"page_label": "342", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "520f856b80a709b7374c2aede302b57fb276fd5eff01ed9924ebd9d59cf04cb3", "class_name": "RelatedNodeInfo"}}, "text": "342 CHAPTER 17. APPENDIX\nvoid cond_init(cond_t *cv) {\ncv->head = NULL ;\ncv->dynamic = NULL ;\n}\nvoid cond_destroy(cond_t *cv) {\n//Nothing tosee here\n//Though may beuseful for the future toput pieces\n}\nstatic int remove_from_list(cond_t *cv, cv_node *ptr) {\n//Function assumes mutex islocked\n//Some sanity checking\nif(ptr == NULL) {\nreturn\n}\n//Special case head\nif(ptr == cv- >head) {\ncv->head = cv- >head- >next ;\nreturn ;\n}\n//Otherwise find the node previous\nfor (cv_node *prev = cv- >head ;prev- >next ;prev = prev- >next) {\n//Ifwe\u2019vefound it,patch itthrough\nif(prev- >next == ptr) {\nprev- >next = prev- >next- >next ;\nreturn ;\n}\n//Otherwise keep walking\nprev = prev- >next ;\n}\n//Wecouldn \u2019tfind the node ,invalid call\n}\nThis is all the boring de\ufb01nitional stuff. The interesting stuff is below.\nvoid cond_wait(cond_t *cv, pthread_mutex_t *m) {\n//See note (dynamic )below\nif(cv- >dynamic == NULL) {\ncv->dynamic = m\n}else if(cv- >dynamic != m) {\n//Error can\u2019twait with adifferent mutex !", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 986, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e7f6602a-36f9-4d3c-b3a3-214944fb8b47": {"__data__": {"id_": "e7f6602a-36f9-4d3c-b3a3-214944fb8b47", "embedding": null, "metadata": {"page_label": "343", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9accf485-e076-4427-b5dd-3e83b1de851d", "node_type": "4", "metadata": {"page_label": "343", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ffe10ca3770f1cd67ced46be2cb865cbee879bd8fb2f0d94c11a4130867657e3", "class_name": "RelatedNodeInfo"}}, "text": "17.13. IMPLEMENTING CVS WITH MUTEXES ALONE 343\nabort() ;\n}\n//mutex islocked sowehave the critical section right now\n//Create linked list node _on the stack_\ncv_node my_node ;\nmy_node.is_awoken = 0 ;\nmy_node.next = cv- >head ;\ncv->head = my_node.next ;\npthread_mutex_unlock(m) ;\n//May dosome cache busting here\nwhile (my_node == 0) {\npthread_yield() ;\n}\npthread_mutex_lock(m) ;\nremove_from_list(cv, &my_node) ;\n//The dynamic binding isover\nif(cv- >head == NULL) {\ncv->dynamic = NULL ;\n}\n}\nvoid cond_signal(cond_t *cv) {\nfor (cv_node *iter = cv- >head ;iter ;iter = iter- >next) {\n//Signal makes sure one thread that has not woken up\n//iswoken up\nif(iter- >is_awoken == 0) {\n//DON\u2019Tremove from the linked list here\n//There isnomutual exclusion ,sowecould\n//have arace condition\niter- >is_awoken = 1 ;\nreturn ;\n}\n}\n//Nomore threads tofree !No-op\n}\nvoid cond_broadcast(cond_t *cv) {\nfor (cv_node *iter = cv- >head ;iter ;iter = iter- >next) {\n//Wake everyone up!\niter- >is_awoken = 1 ;\n}\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 985, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f134613a-31f9-4792-bc53-f43f8ababd02": {"__data__": {"id_": "f134613a-31f9-4792-bc53-f43f8ababd02", "embedding": null, "metadata": {"page_label": "344", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5e041b9d-da2b-4ae4-8f23-df603251e755", "node_type": "4", "metadata": {"page_label": "344", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b2725fd27c85acfc1278e6278026296016dd5ed8cdf2a6270620f70e33139ae8", "class_name": "RelatedNodeInfo"}}, "text": "344 CHAPTER 17. APPENDIX\nSo how does this work? Instead of allocating space which could lead to deadlock. We keep the data structures\nor the linked list nodes on each thread\u2019s stack. The linked list in the wait function is created while the thread has\nthe mutex lock. This is important because we may have a race condition on the insert and removal. A more\nrobust implementation would have a mutex per condition variable.\nWhat is the note about (dynamic)? In the pthread man pages, wait creates a runtime binding to a mutex. This\nmeans that after the \ufb01rst call is called, a mutex is associated with a condition variable while there is still a thread\nwaiting on that condition variable. Each new thread coming in must have the same mutex, and it must be locked.\nHence, the beginning and end of wait (everything besides the while loop) are mutually exclusive. After the last\nthread leaves, meaning when head is NULL, then the binding is lost.\nThe signal and broadcast functions merely tell either one thread or all threads respectively that they should be\nwoken up. It doesn\u2019t modify the linked lists because there is no mutex to prevent corruption if two threads\ncall signal or broadcast.\nNow an advanced point. Do you see how a broadcast could cause a spurious wakeup in this case? Consider\nthis series of events.\n1.Some number more than 2 threads start waiting\n2.Another thread calls broadcast.\n3.That thread calling broadcast is stopped before it wake any threads.\n4.Another thread calls wait on the condition variable and adds itself to the queue.\n5.Broadcast iterates through and frees all of the threads.\nThere is no assurance as to when the broadcast was called and when threads were added in a high-performance\nmutex. The ways to prevent this behavior are to include Lamport timestamps or require that broadcast be called\nwith the mutex in question. That way something that happens-before the broadcast call doesn\u2019t get signaled after.\nThe same argument is put forward for signal too.\nDid you also notice something else? This is why we ask you to signal or broadcast before you unlock . If\nyou broadcast after you unlock, the time that broadcast takes could be in\ufb01nite!\n1.Broadcast is called on a waiting queue of threads\n2.First thread is freed, broadcast thread is frozen. Since the mutex is unlocked, it locks and continues.\n3.It continues for such a long time that it calls broadcast again.\n4.With our implementation of a condition variable, this would be terminated. If you had an implementation\nthat appended to the tail of the list and iterated form the head to the tail, this could go on in\ufb01nitely many\ntimes.\nIn high-performance systems, we want to make sure that each thread that calls wait isn\u2019t passed by another\nthread that calls wait. With the current API that we have, we can\u2019t assure that. We\u2019d have to ask users to pass in a\nmutex or use a global mutex. Instead, we tell programmers to always signal or broadcast before unlocking.\n17.14 Higher Order Models of Synchronization\nWhen using atomics, you need to specify the right model of synchronization to ensure a program behaves correctly .\nYou can read more about them On the gcc wiki These examples are adapted from those.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3198, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3a0fd6f6-592c-478b-8aee-05e83cb5a9a1": {"__data__": {"id_": "3a0fd6f6-592c-478b-8aee-05e83cb5a9a1", "embedding": null, "metadata": {"page_label": "345", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ce5260da-9638-4b8f-bac7-54c602e4fca5", "node_type": "4", "metadata": {"page_label": "345", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8ec21525f854c9f15eb3f76eed5d60c9d66849f8c4a5cb3f95d929d0ddc52a7e", "class_name": "RelatedNodeInfo"}}, "text": "17.15. ACTOR MODEL AND GOROUTINES 345\n17.14.1 Sequentially Consistent\nSequentially consistent is the simplest, least error-prone and most expensive model. This model says that any\nchange that happens, all changes before it will be synchronized between all threads.\nThread 1 Thread 2\n1.0 atomic_store(x, 1)\n1.1 y = 10 2.1 if (atomic_load(x) == 0)\n1.2 atomic_store(x, 0); 2.2 y != 10 && abort();\nWill never quit. This is because either the store happens before the if statement in thread 2 and y ==1 or the\nstore happens after and x does not equal 2.\n17.14.2 Relaxed\nRelaxed is a simple memory order providing for more optimizations. This means that only a particular operation\nneeds to be atomic. One can have stale reads and writes, but after reading the new value, it won\u2019t become old.\n-Thread 1- -Thread 2-\natomic_store(x, 1); printf(\"%d\\n\", x) // 1\natomic_store(x, 0); printf(\"%d\\n\", x) // could be 1 or 0\nprintf(\"%d\\n\", x) // could be 1 or 0\nBut that means that previous loads and stores don\u2019t need to affect other threads. In the previous example, the\ncode can now fail.\n17.14.3 Acquire /Release\nThe order of atomic variables don\u2019t need to be consistent \u2013 meaning if atomic var y is assigned to 10 then atomic\nvar x to be 0 those don\u2019t need to propagate, and a threa could get stale reads. Non-atomic variables have to get\nupdated in all threads though.\n17.14.4 Consume\nImagine the same as above except non-atomic variables don\u2019t need to get updated in all threads. This model was\nintroduced so that there can be an Acquire /Release /Consume model without mixing in Relaxed because Consume\nis similar to relax.\n17.15 Actor Model and Goroutines\nThere are a lotof other methods of concurrency than described in this book. Posix threads are the \ufb01nest grained\nthread construct, allowing for tight control of the threads and the CPU. Other languages have their abstractions.\nWe\u2019ll talk about a language go that is similar to C in terms of simplicity and design, go or golang To get the 5\nminute introduction, feel free to read the learn x in y guide for go. Here is how we create a \"thread\" in go.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2097, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8aabe95a-727c-476b-b1d9-11b453d6aebf": {"__data__": {"id_": "8aabe95a-727c-476b-b1d9-11b453d6aebf", "embedding": null, "metadata": {"page_label": "346", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "80178348-8193-4427-95fd-ca2042100e79", "node_type": "4", "metadata": {"page_label": "346", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b35b83337ba93ddaca3106be4300344406df202ff8ff1a38512fa5c7e43bc165", "class_name": "RelatedNodeInfo"}}, "text": "346 CHAPTER 17. APPENDIX\nfunc hello(out) {\nfmt.Println(out) ;\n}\nfunc main() {\nto_print := \"Hello World !\"\ngo hello(to_print)\n}\nThis actually creates what is known as a goroutine. A goroutine can be thought of as a lightweight thread.\nInternally , it is a worker pool of threads that executes instructions of all the running goroutines. When a goroutine\nneeds to be stopped, it is frozen and \"context switched\" to another thread. Context switch is in quotes because\nthis is done at the run time level versus real context switching which is done at the operating system level.\nThe advantage to gofuncs is pretty self explanatory . There is no boilerplate code, or joining, or odd casting\nvoid * .\nWe can still use mutexes in go to perform our end result. Consider the counting example as before.\nvar counter = 0 ;\nvar mut sync.Mutex ;\nvar wg sync.WaitGroup ;\nfunc plus() {\nmut.Lock()\ncounter += 1\nmut.Unlock()\nwg.Done()\n}\nfunc main() {\nnum := 10\nwg.Add(num) ;\nfor i := 0 ;i<num;i++{\ngo plus()\n}\nwg.Wait()\nfmt.Printf( \"%d\\n\", counter) ;\n}\nBut that\u2019s boring and error prone. Instead, let\u2019s use the actor model. Let\u2019s designate two actors. One is the", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1145, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "86cba470-f618-4f30-a537-5863665cef42": {"__data__": {"id_": "86cba470-f618-4f30-a537-5863665cef42", "embedding": null, "metadata": {"page_label": "347", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3d5517b7-faaa-4fbe-a09a-34657858603b", "node_type": "4", "metadata": {"page_label": "347", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9ad4fafc92e98a8884e8225253a9ca8050b2b494ae947bcf47d02a117dc4e14b", "class_name": "RelatedNodeInfo"}}, "text": "17.15. ACTOR MODEL AND GOROUTINES 347\nmain actor that will be performing the main instruction set. The other actor will be the counter. The counter is\nresponsible for adding numbers to an internal variable. We\u2019ll send messages between the threads when we want\nto add and see the value.\nconst (\naddRequest = iota ;\noutputRequest = iota ;\n)\nfunc counterActor(requestChannel chan int, outputChannel chan int){\ncounter := 0\nfor {\nreq := <- requestChannel ;\nifreq == addRequest {\ncounter += 1\n}else ifreq == outputRequest {\noutputChannel <- counter\n}\n}\n}\nfunc main() {\n//Set upthe actor\nrequestChannel := make(chan int)\noutputChannel := make(chan int)\ngo counterActor(requestChannel, outputChannel)\nnum := 10\nfor i := 0 ;i<num;i++{\nrequestChannel <- addRequest\n}\nrequestChannel <- outputRequest\nnew_count := <- outputChannel\nfmt.Printf( \"%d\\n\", new_count) ;\n}\nAlthough there is a bit more boilerplate code, we don\u2019t have mutexes anymore! If we wanted to scale this\noperation and do other things like increment by a number, or write to a \ufb01le, we can have that particular actor\ntake care of it. This differentiation of responsibilities is important to make sure your design scales well. There are\neven libraries that handle all of the boilerplate code as well.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1253, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f13ecdb8-eb87-4115-ad66-1bfe6e1773cc": {"__data__": {"id_": "f13ecdb8-eb87-4115-ad66-1bfe6e1773cc", "embedding": null, "metadata": {"page_label": "348", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3a491e0e-6d33-4494-ad06-2bfff5d0225c", "node_type": "4", "metadata": {"page_label": "348", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3b7be1a289f5e8d64e8d3b7ce937c4016cb41065955d3a0ad4d17951b172686a", "class_name": "RelatedNodeInfo"}}, "text": "348 CHAPTER 17. APPENDIX\n17.16 Scheduling Conceptually\nThis section could be useful for those that like to analyze these algorithms mathematically\nIf your co-worker asked you what scheduling algorithm to use, you may not have the tools to analyze each\nalgorithm. So, let\u2019s think about scheduling algorithms at a high level and break them down by their times. We\nwill be evaluating this in the context of a random process timing, meaning that each process takes a random but\n\ufb01nite amount of time to \ufb01nish.\nJust a refresher, here are the terms.\nTable 17.2: Scheduling Variables\nConcept Meaning\nStart time The time the scheduler \ufb01rst started work\nEnd time When the scheduler \ufb01nished the process\nArrival time When the job \ufb01rst arrived at the scheduler\nRun time How long does the process take to run if there is no preemption\nAnd here are the measures we are trying to optimize.\nTable 17.3: Scheduling Measures of Ef\ufb01ciency\nMeasure Formula\nResponse Time Start time minus Arrival time\nTurnaround time End time minus Arrival time\nWait time End time minus Arrival time minus Run time\nDifferent use cases will be discussed after. Let the maximum amount of time that a process run be equal to\nS. We will also assume that there are a \ufb01nite number of processes running at any given time c. Here are some\nconcepts from queueing theory that you\u2019ll need to know that will help simplify the theories.\n1.Queueing theory involves a random variable controlling the interarrival time \u2013 or the time between two\ndifferent processes arriving. We won\u2019t name this random variable, but we will assume that (1) it has a mean\nof\u03bband (2) it is distributed as a Poisson random variable. This means the probability of getting a process\ntunits after getting another process is \u03bbt\u2217exp(\u2212\u03bb)\nt!where t! can be approximated by the gamma function\nwhen dealing with real values.\n2.We will be denoting the service time S, and deriving the waiting time W, and the response time R; more\nspeci\ufb01cally the expected values of all of those variables E[S]deriving turnaround time is simply S+W. For\nclarity , we will introduce another variable Nthat is the number of people currently in the queue. A famous\nresult in queueing theory is Little\u2019s Law which states E[N] =\u03bbE[W]meaning that the number of people\nwaiting is the arrival rate times the expected waiting time (assuming the queue is in a steady state).\n3.We won\u2019t make many assumptions about how much time it takes to run each process except that it will take\na \ufb01nite amount of time \u2013 otherwise this gets almost impossible to evaluate. We will denote two variables\nthat1\n\u00b5is the mean of the waiting time and that the coef\ufb01cient of variation Cis de\ufb01ned as C2=var(S)\nE[S]2to\nhelp us control for processes that take a while to \ufb01nish. An important note is that when C>1 we say that\nthe running times of the process are variadic. We will note below that this rockets up the wait and response\ntimes for FCFS quadratically .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2926, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "22a32777-ac96-431e-89f3-091b1719ad3f": {"__data__": {"id_": "22a32777-ac96-431e-89f3-091b1719ad3f", "embedding": null, "metadata": {"page_label": "349", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "557a1ac1-ce42-4e6a-8ad2-ecaaa091f7e2", "node_type": "4", "metadata": {"page_label": "349", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d09c8d2d6cb148cc30e2961a1efba91a8272596c9b3f34fc5811125cae7a1610", "class_name": "RelatedNodeInfo"}}, "text": "17.16. SCHEDULING CONCEPTUALLY 349\n4.\u03c1=\u03bb\n\u00b5<1 Otherwise, our queue would become in\ufb01nitely long\n5.We will assume that there is one processor. This is known as an M /G/1 queue in queueing theory .\n6.We\u2019ll leave the service time as an expectation Sotherwise we may run into over-simpli\ufb01cations with the\nalgebra. Plus it is easier to compare different queueing disciplines with a common factor of service time.\n17.16.1 First Come First Served\nAll results are from Jorma Virtamo\u2019s lectures on the matter [?].\n1.The \ufb01rst is expected waiting time.\nE[W] =(1+C2)\n2\u03c1\n(1\u2212\u03c1)\u2217E[S]\nWhat does this say? When given as \u03c1\u21921 or the mean job arrival rate equals the mean job processing rate,\nthen the wait times get long. Also, as the variance of the job increases, the wait times go up.\n2.Next is the expected response time\nE[R] =E[N]\u2217E[S] =\u03bb\u2217E[W]\u2217E[S]\nThe response time is simple to calculate, it is the expected number of people ahead of the process in the\nqueue times the expected time to service each of those processes. From Little\u2019s Law above, we can substitute\nthat for this. Since we already know the value of the waiting time, we can reason about the response time\nas well.\n3.A discussion of the results is shows something cool discovered by Conway and Al [?]. Any scheduling\ndiscipline that isn\u2019t preemptive and doesn\u2019t take into account the run time of the process or a priority will\nhave the same wait, response, and turnaround time. We will often use this as a baseline.\n17.16.2 Round Robin or Processor Sharing\nIt is hard to analyze Round Robin from a probabilistic sense because it is so state based. The next job that\nthe scheduler schedules requires it to remember the previous jobs. Queueing theory developers have made an\nassumption that the time quanta is roughly zero \u2013 ignoring context switching and the like. This leads way into\nprocessor sharing. Many different tasks can get worked on at the same time but experience a slowdown. All of\nthese proofs will be adapted from Harchol-Balter\u2019s book [?]. We highly recommend checking out the books if you\nare interested. The proofs are intuitive for people who don\u2019t have a background in queueing theory .\n1.Before we jump to the answer let\u2019s reason about this. With our new-found abstraction, we essentially have\nan FCFS queue where we are going to be working on each job a little slower than before. Since we are\nalways working on a job\nE[W] =0\nUnder a non-strict analysis of processor sharing though, the number of time that the scheduler waits is best\napproximated by the number of times the scheduler need to wait. You\u2019ll needE[S]\nQservice periods where Q", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2607, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d49455ae-54e6-47ed-9c98-e9bfcc4c7ac3": {"__data__": {"id_": "d49455ae-54e6-47ed-9c98-e9bfcc4c7ac3", "embedding": null, "metadata": {"page_label": "350", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6826ac6f-6e81-4ec2-bd50-887e6c471ed1", "node_type": "4", "metadata": {"page_label": "350", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c9b15419e92efbfc7ef03af1f239aeb807ec06912963ff1b2003971f15cd5f2e", "class_name": "RelatedNodeInfo"}}, "text": "350 CHAPTER 17. APPENDIX\nis the quanta, and you\u2019ll need about E[N]\u2217Qtime in between those periods. Leading to an average time of\nE[W] =E[S]\u2217E[N]\nThe reason this proof is non-rigorous is that we can\u2019t assume that there will always be E[N]\u2217Qtime on\naverage in between cycles because it depends on the state of the system. This means we need to factor in\nvarious variations in processing delay . We also can\u2019t use Little\u2019s Law in this case because there is no real\nsteady state of the system. Otherwise, we\u2019d be able to prove some weird things.\nInterestingly , we don\u2019t have to worry about the convoy effect or any new processes coming in. The total wait\ntime remains bounded by the number of people in the queue. For those of you familiar with tail inequalities\nsince processes arrive according to a Poisson distribution, the probability that we\u2019ll get many processes\ndrops off exponentially due to Chernoff bounds (all arrivals are independent of other arrivals). Meaning\nroughly we can assume low variance on the number of processes. As long as the service time is reasonable\non average, the wait time will be too.\n2.The expected response time is\nE[R] =0\nUnder strict processor sharing, it is 0 because all jobs are worked on. In practice, the response time is.\nE[R] =E[N]\u2217Q\nWhere Qis the quanta. Using Little\u2019s Law again, we can \ufb01nd out that\nE[R] =\u03bbE[W]\u2217Q\n3.A different variable is the amount of service time let the service time for processor sharing be de\ufb01ned as\nSPS. The slowdown is E[SPS] =E[S]\n1\u2212\u03c1Which means as the mean arrival rate equals the mean processing time,\nthen the jobs will take asymptotically as long to \ufb01nish. In the non-strict analysis of processor sharing, we\nassume that\nE[SRR] =E[S] +Q\u2217\u03b5,\u03b5 >0\n\u03b5is the amount of time a context switch takes.\n4.That naturally leads to the comparison, what is better? The response time is roughly the same comparing\nthe non-strict versions, the wait time is roughly the same, but notice that nothing about the variation of the\njobs is put in. That\u2019s because RR doesn\u2019t have to deal with the convoy effect and any variances associated,\notherwise FCFS is faster in a strict sense. It also takes more time for the jobs to \ufb01nish, but the overall\nturnaround time is lower under high variance loads.\n17.16.3 Non Preemptive Priority\nWe will introduce the notation that there are kdifferent priorities and \u03c1i>0 is the average load contribution for\npriority iWe are constrained byk\u2211\ni=0\u03c1i=\u03c1. We will also denote \u03c1(x) =x\u2211\ni=0\u03c1iwhich is the load contribution for\nall higher and similar priority processes to x. The last bit of notation is that we will assume that the probability of\ngetting a process of priority iispiand naturallyk\u2211\nj=0pj=1", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2684, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "198938e6-a1d5-4518-97d0-04d279484e7c": {"__data__": {"id_": "198938e6-a1d5-4518-97d0-04d279484e7c", "embedding": null, "metadata": {"page_label": "351", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2dfb7df0-30d9-4b21-8bb7-1583c22c6b07", "node_type": "4", "metadata": {"page_label": "351", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "1ffd7b37b2d77f3d2dd79229f8c71500b7f471de87f5a0cb9bfa16c1ab818d23", "class_name": "RelatedNodeInfo"}}, "text": "17.16. SCHEDULING CONCEPTUALLY 351\n1.IfE[Wi]is the wait time for priority i,\nE[Wx] =(1+C)\n2\u03c1\n(1\u2212\u03c1(x))\u2217(1\u2212\u03c1(x\u22121))\u2217E[Si]\nThe full derivation is as always in the book. A more useful inequality is that.\nE[Wx]\u22641+C\n2\u2217\u03c1\n(1\u2212\u03c1(x))2\u2217E[Si]\nbecause the addition of \u03c1xcan only increase the sum, decrease the denominator or increase the overall\nfunction. This means that if one is priority 0, then a process only need to wait for the other P0 processes\nwhich there should be \u03c1C/(1\u2212\u03c10)P0 processes arrived before to process in FCFS order. Then the next\npriority has to wait for all the others and so on and so forth.\nThe expected overall wait time is now\nE[W] =k\u2211\ni=0E[Wi]\u2217pi\nNow that we have notational soup, let\u2019s factor out the important terms.\nk\u2211\ni=0pi\n(1\u2212\u03c1(i))2\nWhich we compare with FCFS\u2019 model of\n1\n1\u2212\u03c1\nIn words \u2013 you can work this out with experimenting distributions \u2013 if the system has a lot of low priority\nprocesses who don\u2019t contribute a lot to the average load, your average wait time becomes much lower.\n2.The average per process response time is\nE[Ri] =i\u2211\nj=0E[Nj]\u2217E[Sj]\nWhich says that the scheduler needs to wait for all jobs with a higher priority and the same to go before a\nprocess can go. Imagine a series of FCFS queues that a process needs to wait your turn. Using Little\u2019s Law\nfor different colored jobs and the formula above we can simplify this\nE[Ri] =i\u2211\nj=0\u03bbjE[Wj]\u2217E[Sj]\nAnd we can \ufb01nd the average response time by looking at the distribution of jobs\nE[R] =k\u2211\ni=0pi[k\u2211\nj=0\u03bbjE[Wj]\u2217E[Sj]]\nMeaning that we are tied to wait times and service times of all other processes. If we break down this", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1602, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "70166911-5fb1-4a1a-8485-1994a475961d": {"__data__": {"id_": "70166911-5fb1-4a1a-8485-1994a475961d", "embedding": null, "metadata": {"page_label": "352", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6d7bc0af-6401-4680-abe9-1f944917c234", "node_type": "4", "metadata": {"page_label": "352", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "eda086356ffaf40e8d86813bfc192d6e1d807ef9f1de71b62f1640c0c36bb90c", "class_name": "RelatedNodeInfo"}}, "text": "352 CHAPTER 17. APPENDIX\nequation, we see again if we have a lot of high priority jobs that don\u2019t contribute a lot to the load then our\nentire sum goes down. We won\u2019t make too many assumptions about the service time for a job because that\nwould interfere with our analysis from FCFS where we left it as an expression.\n3.As for a comparison with FCFS in the average case, it usually does better assuming that we have a smooth\nprobability distribution \u2013 i.e. the probability of getting any particular priority is zero. In all of our formulas,\nwe still have some probability mass to put on lower priority processes, bringing the expectation down. This\nstatement doesn\u2019t hold for all smooth distributions but for most real-world smoothed distributions (which\ntend to be smooth) they do.\n4.This isn\u2019t even to mention the idea of utility . Utility means that if we gain an amount of happiness by having\ncertain jobs \ufb01nish, priority and preemptive priority maximize that while balancing out other measures of\nef\ufb01ciency .\n17.16.4 Shortest Job First\nThis is a wonderful reduction to priority . Instead of having discrete priorities, we\u2019ll introduce a process that takes\nSttime to get serviced. Tis the maximum amount of time a process can run for, our processes cannot run in\ufb01nitely\nlong. That means the following de\ufb01nitions hold, overriding the previous de\ufb01nitions in priority\n1.Let\n\u03c1(x) =\u222bx\n0\u03c1udu\nBe the average load contribution up to this point.\n2.\u222bk\n0pudu=1\nProbability constraint.\n3.Etc, replace all the summations above with integrals\n4.The only notational difference is we don\u2019t have to make any assumptions about the service times of the jobs\nbecause they are denoted by service times subscript, all other analyses are the same.\n5.This means if you want low wait times on average compared to FCFS, your distribution needs to be\nright-skewed.\n17.16.5 Preemptive Priority\nWe will describe priority and SJF\u2019s preemptive version in the same section because it is essentially the same as\nwe\u2019ve shown above. We\u2019ll use the same notation as before. We will also introduce an additional term Ciwhich\ndenotes the variation among a particular class\nCi=var(Si)\nE[Si]", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2154, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aa059345-ec07-4762-a581-5d4022738b80": {"__data__": {"id_": "aa059345-ec07-4762-a581-5d4022738b80", "embedding": null, "metadata": {"page_label": "353", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7eb43954-0af3-4d23-8ced-7f4543102e31", "node_type": "4", "metadata": {"page_label": "353", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9ca3adfa57b10ebbf26190358c241fd4e8be9482acd9dcf1fab8b6fd5e06ad11", "class_name": "RelatedNodeInfo"}}, "text": "17.16. SCHEDULING CONCEPTUALLY 353\n1.Response Time. Just a head\u2019s up, this isn\u2019t going to be pretty .\nE[Ri] =i\u2211\nj=0(1+Cj)\n2\n(1\u2212\u03c1(x))\u2217(1\u2212\u03c1(x\u22121))\u2217E[Si]\nIf this looks familiar it should. This is the average wait time in the nonpreemptive case with a small change.\nInstead of using the variance of the entire distribution, we are looking at the variance of each job coming in.\nThe whole response times are\nE[R] =k\u2211\ni=0pi\u2217E[Ri]\nIf lower priorities jobs come in at a higher service time variance, that means our average response times\ncould go down, unless they make up most of the jobs that come in. Think of the extreme cases. If 99% of\nthe jobs are high priority and the rest make up the other percent, then the other jobs will get frequently\ninterrupted, but high priority jobs will make up most of the jobs, so the expectation is still low. The other\nextreme is if one percent of jobs are high priority and they come in a low variance. That means the chances\nthe system getting a high priority jobs that will take a long time is low, thus making our response times\nlower on average. We only run into trouble if high priority jobs make up a non-negligible amount, and they\nhave a high variance in service times. This brings down response times as well as wait times.\n2.Waiting Time\nE[Wi] =E[Ri] +E[Si]\n1\u2212\u03c1(i)\nTaking the expectation among all processes we get\nE[W] =k\u2211\ni=0pi(E[Ri] +E[Si]\n1\u2212\u03c1(i))\nWe can simplify to\nE[W] =E[R] +k\u2211\ni=0E[Si]pi\n(1\u2212\u03c1(i))\nWe incur the same cost on response time and then we have to suffer an additional cost based on what the\nprobabilities are of lower priority jobs coming in and taking this job out. That is what we call the average\ninterruption time. This follows the same laws as before. Since we have a variadic, pyramid summation if\nwe have a lot of jobs with small service times then the wait time goes down for both additive pieces. It\ncan be analytically shown that this is better given certain probability distributions. For example, try with\nthe uniform versus FCFS or the non preemptive version. What happens? As always the proof is left to the\nreader.\n3.Turnaround Time is the same formula E[T] =E[S] +E[W]. This means that given a distribution of jobs\nthat has either low waiting time as described above, we will get low turnaround time \u2013 we can\u2019t control the\ndistribution of service times.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2329, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec73a79f-fc30-4c41-86a1-4cf887ba31e7": {"__data__": {"id_": "ec73a79f-fc30-4c41-86a1-4cf887ba31e7", "embedding": null, "metadata": {"page_label": "354", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6c94dc17-010b-497e-894d-4758e39d23ab", "node_type": "4", "metadata": {"page_label": "354", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e6215f2b5de39b979ccaaddb9bcd5fcce12504daed69dc0d345d56b44851f7de", "class_name": "RelatedNodeInfo"}}, "text": "354 CHAPTER 17. APPENDIX\n17.16.6 Preemptive Shortest Job First\nUnfortunately , we can\u2019t use the same trick as before because an in\ufb01nitesimal point doesn\u2019t have a controlled\nvariance. Imagine the comparisons though as the same as the previous section.\n17.17 Networking Extra\n17.17.1 In-depth IPv4 Speci\ufb01cation\nThe Internet Protocol deals with routing, fragmentation, and reassembly of fragments. Datagrams are formatted\nas such\n0 16 32\nSource Address\nDestination AddressVersionHeader\nLengthService Type T otal Length\nIdenti cation Flags Oset\nTTL Protocol Header Checksum\nOptions Padding\nFigure 17.3: IP Datagram divisibility\n1.The \ufb01rst octet is the version number, either 4 or 6\n2.The next octet is how long the header is. Although it may seem that the header is a constant size, you can\ninclude optional parameters to augment the path that is taken or other instructions.\n3.The next two octets specify the total length of the datagram. This means this is the header, the data, the\nfooter, and the padding. This is given in multiple of octets, meaning that a value of 20 means 20 octets.\n4.The next two are Identi\ufb01cation number. IP handles taking packets that are too big to be sent over the\nphysical wire and chunks them up. As such, this number identi\ufb01es what datagram this originally belonged\nto.\n5.The next octet is various bit \ufb02ags that can be set.\n6.The next octet and half is fragment number. If this packet was fragmented, this is the number this fragment\nrepresents", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1473, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eec79c67-3ef0-48b1-a83e-192d1d91e2a1": {"__data__": {"id_": "eec79c67-3ef0-48b1-a83e-192d1d91e2a1", "embedding": null, "metadata": {"page_label": "355", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c9a5f1d4-7d47-4b7f-a050-d0384b21fe31", "node_type": "4", "metadata": {"page_label": "355", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e097c9f72e584bcd3ff9584c76d7a72a4df76c9f25c31453bd15a7972946eadd", "class_name": "RelatedNodeInfo"}}, "text": "17.17. NETWORKING EXTRA 355\n7.The next octet is time to live. So this is the number of \"hops\" (travels over a wire) a packet is allowed to\ngo. This is set because different routing protocols could cause packets to go in circles, the packets must be\ndropped at some point.\n8.The next octet is the protocol number. Although protocols between different layers of the OCI model\nare supposed to be black boxes, this is included, so that hardware can peer into the underlying protocol\nef\ufb01ciently . Take for example IP over IP (yes you can do that!). Your ISP wraps IPv4 packets sent from your\ncomputer to the ISP in another IP layer and sends the packet off to be delivered to the website. On the\nreverse trip, the packet is \"unwrapped\" and the original IP datagram is sent to your computer. This was\ndone because we ran out of IP addresses, and this adds additional overhead but it is a necessary \ufb01x. Other\ncommon protocols are TCP , UDP , etc.\n9.The next two octets is an internet checksum. This is a CRC that is calculated to make sure that a wide\nvariety of bit errors are detected.\n10.The source address is what people generally refer to as the IP address. There is no veri\ufb01cation of this, so\none host can pretend to be any IP address possible\n11.The destination address is where you want the packet to be sent to. Destinations are crucial to the routing\nprocess.\n12.Additional options: Hosts of additional options, this is variadic in size.\n13.Footer: A bit of padding to make sure your data is a multiple of 4 octets.\n14.After: Your data! All data of higher-order protocols are put following the header.\n17.17.2 Routing\nThe Internet Protocol routing is an amazing intersection of theory and application. We can imagine the entire\nInternet as a set of graphs. Most peers are connected to what we call \"peering points\" \u2013 these are the WiFi routers\nand Ethernet ports that one \ufb01nds at home, at work, and in public. These peering points are then connected to a\nwired network of routers, switches, and servers that all route themselves. At a high level there are two types of\nrouting\n1.Internal Routing Protocols. Internal protocols are routing designed for within an ISP\u2019s network. These\nprotocols are meant to be fast and more trusting because all computers, switches, and routers are part of an\nISP . communication between two routers.\n2.External Routing Protocols. These typically happen to be ISP to ISP protocol. Certain routers are designated\nas border routers. These routers talk to routers from ISPs who have different policies from accepting or\nreceiving packets. If an evil ISP is trying to dump all network traf\ufb01c onto your ISP , these routers would deal\nwith that. These protocols also deal with gathering information about the outside world to each router. In\nmost routing protocols using link state or OSPF , a router must necessarily calculate the shortest path to the\ndestination. This means it needs information about the \"foreign\" routers which is disseminated according to\nthese protocols.\nThese two protocols have to interplay with each other nicely to make sure that packets are mostly delivered.\nAlso, ISPs need to be nice to each other. Theoretically , an ISP can handle a smaller load by forwarding all packets\nto another ISP . If everyone does that then, no packets get delivered at all which won\u2019t make customers happy at\nall. These two protocols need to be fair so the result works\nIf you want to read more about this, look at the Wikipedia page for routing here Routing.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3495, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b9eb5cb3-d221-4222-8259-c4541015fa82": {"__data__": {"id_": "b9eb5cb3-d221-4222-8259-c4541015fa82", "embedding": null, "metadata": {"page_label": "356", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "af70ebff-f208-4650-b5c8-eaead32a44a0", "node_type": "4", "metadata": {"page_label": "356", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "cac4ece328ff56ec3be0db9e6ff095715261b17cd7bc514ec5ed99a9c4ec9aed", "class_name": "RelatedNodeInfo"}}, "text": "356 CHAPTER 17. APPENDIX\n17.17.3 Fragmentation /Reassembly\nLower layers like WiFi and Ethernet have maximum transmission sizes. The reason being is\n1.One host shouldn\u2019t crowd the medium for too long\n2.If an error occurs, we want some sort of \"progress bar\" on how far the communication has gone instead of\nretransmitting the entire stream.\n3.There are physical limitations, keeping a laser beam in optics working continuously may cause bit errors.\nIf the Internet Protocol receives a packet that is too big for the maximum size, it must chunk it up. TCP\ncalculates how many datagrams that it needs to construct a packet and ensures that they are all transmitted and\nreconstructed at the end receiver. The reason that we barely use this feature is that if any fragment is lost, the\nentire packet is lost. Meaning that, assuming the probability of receiving a packet assuming each fragment is lost\nwith an independent percentage, the probability of successfully sending a packet drops off exponentially as packet\nsize increases.\nAs such, TCP slices its packets so that it \ufb01ts inside on IP datagram. The only time that this applies is when\nsending UDP packets that are too big, but most people who are using UDP optimize and set the same packet size\nas well.\n17.17.4 IP Multicast\nA little known feature is that using the IP protocol one can send a datagram to all devices connected to a router\nin what is called a multicast. Multicasts can also be con\ufb01gured with groups, so one can ef\ufb01ciently slice up all\nconnected routers and send a piece of information to all of them ef\ufb01ciently . To access this in a higher protocol,\nyou need to use UDP and specify a few more options. Note that this will cause undue stress on the network, so a\nseries of multicasts could \ufb02ood the network fast.\n17.17.5 kqueue\nWhen it comes to Event-Driven IO, the name of the game is to be fast. One extra system call is considered slow.\nOpenBSD and FreeBSD have an arguably better model of asynchronous IO from the kqueue model. Kqueue is\na system call that is exclusive the BSDs and MacOs. It allows you to modify \ufb01le descriptor events and read \ufb01le\ndescriptors all in a single call under a uni\ufb01ed interface. So what are the bene\ufb01ts?\n1.No more differentiation between \ufb01le descriptors and kernel objects. In the epoll section, we had to discuss\nthis distinction otherwise you may wonder why closed \ufb01le descriptors are getting returned on epoll. No\nproblem here.\n2.How often do you call epoll to read \ufb01le descriptors, get a server socket, and need to add another \ufb01le\ndescriptor? In a high-performance server, this can easily happen 1000s of times a second. As such, having\none system call to register and grab events saves the overhead of having a system call.\n3.The uni\ufb01ed system call for all types. kqueue is the truest sense of underlying descriptor agnostic. One can\nadd \ufb01les, sockets, pipes to it and get full or near full performance. You can add the same to epoll, but Linux\u2019s\nwhole ecosystem with async \ufb01le input-output has been messed up with aio, meaning that since there is no\nuni\ufb01ed interface, you run into weird edge cases.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3104, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9bcc5764-5a2f-4c6f-84e0-02c9190072d4": {"__data__": {"id_": "9bcc5764-5a2f-4c6f-84e0-02c9190072d4", "embedding": null, "metadata": {"page_label": "357", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2571ee34-738c-43d4-a92e-f6d7b66148ec", "node_type": "4", "metadata": {"page_label": "357", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9deff96df7d3fa71e51d51b91a38de51c4e3570df7eaf030dfcafa2b2c343bb7", "class_name": "RelatedNodeInfo"}}, "text": "17.18. ASSORTED MAN PAGES 357\n17.18 Assorted Man Pages\n17.18.1 Malloc\nCopyright (c) 1993 by Thomas Koenig (ig25@rz.uni-karlsruhe.de)\n%%%LICENSE_START(VERBATIM)\nPermission is granted to make and distribute verbatim copies of this\nmanual provided the copyright notice and this permission notice are\npreserved on all copies.\nPermission is granted to copy and distribute modified versions of this\nmanual under the conditions for verbatim copying, provided that the\nentire resulting derived work is distributed under the terms of a.\npermission notice identical to this one.\nSince the Linux kernel and libraries are constantly changing, this\nmanual page may be incorrect or out-of-date. The author(s) assume no\nresponsibility for errors or omissions, or for damages resulting from\nthe use of the information contained herein. The author(s) may not\nhave taken the same level of care in the production of this manual,\nwhich is licensed free of charge, as they might when working\nprofessionally.\nFormatted or processed versions of this manual, if unaccompanied by\nthe source, must acknowledge the copyright and authors of this work.\n%%%LICENSE_END\nMALLOC(3) Linux Programmer\u2019s Manual MALLOC(3)\nNAME\nmalloc, free, calloc, realloc - allocate and free dynamic memory\nSYNOPSIS\n#include <stdlib.h>\nvoid *malloc(size_t size);\nvoid free(void *ptr);\nvoid *calloc(size_t nmemb, size_t size);\nvoid *realloc(void *ptr, size_t size);\nvoid *reallocarray(void *ptr, size_t nmemb, size_t size);\nFeature Test Macro Requirements for glibc (see feature_test_macros(7)):\nreallocarray():\n_GNU_SOURCE\nDESCRIPTION\nThe malloc() function allocates size bytes and returns a\npointer to the allocated memory. The memory is not initialized.\nIf size is 0, then malloc() returns either NULL, or\na unique pointer value that can later be successfully passed\nto free().\nThe free() function frees the memory space pointed to by ptr,\nwhich must have been returned by a previous call to malloc(),", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1951, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "051e0217-b9b0-4bef-a2a6-c69d32ccb9b8": {"__data__": {"id_": "051e0217-b9b0-4bef-a2a6-c69d32ccb9b8", "embedding": null, "metadata": {"page_label": "358", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "236806b3-e949-4f50-8f30-10ace87c0a7c", "node_type": "4", "metadata": {"page_label": "358", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8e92d101a5472ea21884f1ad6a8aed7b74188d1e174e71380254c93f95115e7f", "class_name": "RelatedNodeInfo"}}, "text": "358 CHAPTER 17. APPENDIX\ncalloc(), or realloc(). Otherwise, or if free(ptr)\nhas already been called before, undefined behavior occurs.\nIf ptr is NULL, no operation is performed.\nThe calloc() function allocates memory for an array of nmemb\nelements of size bytes each and returns a pointer to the\nallocated memory. The memory is set to zero. If nmemb or size\nis 0, then calloc() returns either NULL, or a unique pointer\nvalue that can later be successfully passed to free().\nThe realloc() function changes the size of the memory block\npointed to by ptr to size bytes. The contents will be unchanged\nin the range from the start of the region up to the minimum of\nthe old and new sizes. If the new size is larger than the old\nsize, the added memory will not be initialized. If ptr is NULL,\nthen the call is equivalent to malloc(size), for all values of\nsize; if size is equal to zero, and ptr is not NULL, then the\ncall is equivalent to free(ptr). Unless ptr is NULL, it must\nhave been returned by an earlier call to malloc(), calloc(), or\nrealloc(). If the area pointed to was moved, a free(ptr) is done.\nThe reallocarray() function changes the size of the memory block\npointed to by ptr to be large enough for an array of nmemb\nelements, each of which is size bytes. It is equivalent to\nthe call\nrealloc(ptr, nmemb * size);\nHowever, unlike that realloc() call, reallocarray() fails\nsafely in the case where the multiplication would overflow.\nIf such an overflow occurs, reallocarray() returns NULL,\nsets errno to ENOMEM, and leaves the original block of memory\nunchanged.\nRETURN VALUE\nThe malloc() and calloc() functions return a pointer to the\nallocated memory, which is suitably aligned for any built-in\ntype. On error, these functions return NULL. NULL may also be\nreturned by a successful call to malloc() with a size of zero,\nor by a successful call to calloc() with nmemb or size equal\nto zero.\nThe free() function returns no value.\nThe realloc() function returns a pointer to the newly allocated\nmemory, which is suitably aligned for any built-in type and may\nbe different from ptr, or NULL if the request fails. If size\nwas equal to 0, either NULL or a pointer suitable to be passed\nto free() is returned. If realloc() fails, the original block is\nleft untouched; it is not freed or moved.\nOn success, the reallocarray() function returns a pointer to the\nnewly allocated memory. On failure, it returns NULL and the\noriginal block of memory is left untouched.\nERRORS\ncalloc(), malloc(), realloc(), and reallocarray() can fail with", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2536, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b79dabd0-8a1a-40e6-b12e-53bcd781eabe": {"__data__": {"id_": "b79dabd0-8a1a-40e6-b12e-53bcd781eabe", "embedding": null, "metadata": {"page_label": "359", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e02d000e-5d4f-4162-9018-dc239e5a201a", "node_type": "4", "metadata": {"page_label": "359", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ed182396a27460ea6389e9d78f830b238358311e0ba5d3a9ac5763070a562e58", "class_name": "RelatedNodeInfo"}}, "text": "17.18. ASSORTED MAN PAGES 359\nthe following error:\nENOMEM Out of memory. Possibly, the application hit the\nRLIMIT_AS or RLIMIT_DATA limit described in getrlimit(2).\nATTRIBUTES\nFor an explanation of the terms used in this section, see\nattributes(7).\n+---------------------+---------------+---------+\n|Interface | Attribute | Value |\n|-----------------------------------------------|\n|malloc(), free(), | Thread safety | MT-Safe |\n|calloc(), realloc() | | |\n+---------------------+---------------+---------+\nCONFORMING TO\nmalloc(), free(), calloc(), realloc(): POSIX.1-2001,\nPOSIX.1-2008, C89, C99.\nreallocarray() is a nonstandard extension that first appeared in\nOpenBSD 5.6 and FreeBSD 11.0.\nNOTES\nBy default, Linux follows an optimistic memory allocation\nstrategy. This means that when malloc() returns non-NULL there\nis no guarantee that the memory is available. In case it\nturns out that the system is out of memory, one or more\nprocesses will be killed by the OOM killer. For more\ninformation, see the description of /proc/sys/vm/over-\ncommit_memory and /proc/sys/vm/oom_adj in proc(5), and the\nLinux kernel source file Documentation/vm/overcommit-accounting.\nNormally, malloc() allocates memory from the heap, and adjusts\nthe size of the heap as required, using sbrk(2). When\nallocating blocks of memory larger than MMAP_THRESHOLD bytes,\nthe glibc malloc() implementation allocates the memory as a\nprivate anonymous mapping using mmap(2). MMAP_THRESHOLD is 128\nkB by default, but is adjustable using mallopt(3). Prior to\nLinux 4.7 allocations performed using mmap(2) were unaffected\nby the RLIMIT_DATA resource limit; since Linux 4.7, this limit\nis also enforced for allocations performed using mmap(2).\nTo avoid corruption in multithreaded applications, mutexes are\nused internally to protect the memory-management data structures\nemployed by these functions. In a multithreaded application in\nwhich threads simultaneously allocate and free memory, there\ncould be contention for these mutexes. To scalably handle\nmemory allocation in multithreaded applications, glibc creates\nadditional memory allocation arenas if mutex contention is\ndetected. Each arena is a large region of memory that is\ninternally allocated by the system (using brk(2) or mmap(2)),\nand managed with its own mutexes.\nSUSv2 requires malloc(), calloc(), and realloc() to set errno to\nENOMEM upon failure. Glibc assumes that this is done (and the\nglibc versions of these routines do this); if you use a private", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2484, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "78307ee3-ffae-40db-a952-c140c264a4bf": {"__data__": {"id_": "78307ee3-ffae-40db-a952-c140c264a4bf", "embedding": null, "metadata": {"page_label": "360", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5022be93-401a-42ea-9d11-5c29572f28e4", "node_type": "4", "metadata": {"page_label": "360", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4b49b987280f678e3511c874c9ab1a5e3dc58790d1d6de3bf9c41437dfe76f1e", "class_name": "RelatedNodeInfo"}}, "text": "360 CHAPTER 17. APPENDIX\nmalloc implementation that does not set errno, then certain\nlibrary routines may fail without having a reason in errno.\nCrashes in malloc(), calloc(), realloc(), or free() are almost\nalways related to heap corruption, such as overflowing an\nallocated chunk or freeing the same pointer twice.\nThe malloc() implementation is tunable via environment\nvariables; see mallopt(3) for details.\nSEE ALSO\nvalgrind(1), brk(2), mmap(2), alloca(3), malloc_get_state(3),\nmalloc_info(3), malloc_trim(3), malloc_usable_size(3),\nmallopt(3), mcheck(3), mtrace(3), posix_memalign(3)\n17.19 System Programming Jokes\n0x43 0x61 0x74 0xe0 0xf9 0xbf 0x5f 0xff 0x7f 0x00\nWarning: Authors are not responsible for any neuro-apoptosis caused by these \u201cjokes.\u201d - Groaners are allowed.\n17.19.1 Light bulb jokes\nQ. How many system programmers does it take to change a lightbulb?\nA. Just one but they keep changing it until it returns zero.\nA. None they prefer an empty socket.\nA. Well you start with one but actually it waits for a child to do all of the work.\n17.19.2 Groaners\nWhy did the baby system programmer like their new colorful blankie? It was multithreaded.\nWhy are your programs so \ufb01ne and soft? I only use 400-thread-count or higher programs.\nWhere do bad student shell processes go when they die? Forking Hell.\nWhy are C programmers so messy? They store everything in one big heap.\n17.19.3 System Programmer (De\ufb01nition)\nA system programmer is. . .\nSomeone who knows sleepsort is a bad idea but still dreams of an excuse to use it.\nSomeone who never lets their code deadlock. . . but when it does, it causes more problems than everyone else\ncombined.\nSomeone who believes zombies are real.\nSomeone who doesn\u2019t trust their process to run correctly without testing with the same data, kernel, compiler,\nRAM, \ufb01lesystem size,\ufb01le system format, disk brand, core count, CPU load, weather, magnetic \ufb02ux, orientation,\npixie dust, horoscope sign, wall color, wall gloss and re\ufb02ectance, motherboard, vibration, illumination, backup\nbattery , time of day , temperature, humidity , lunar position, sun-moon, co-position. . .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2117, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "17b96e04-09d3-48c3-b94a-680085856207": {"__data__": {"id_": "17b96e04-09d3-48c3-b94a-680085856207", "embedding": null, "metadata": {"page_label": "361", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ef37abf2-926d-4796-803a-3155467dd223", "node_type": "4", "metadata": {"page_label": "361", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "39fd510b1f4d8811e71f9f16ebdce41bf9e02b6311b0d3955f1877ec70ddb360", "class_name": "RelatedNodeInfo"}}, "text": "17.19. SYSTEM PROGRAMMING JOKES 361\nA system program . . .\nEvolves until it can send email.\nEvolves until it has the potential to create, connect and kill other programs and consume all possible CPU,\nmemory , network, . . . resources on all possible devices but chooses not to. Today .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 285, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a9be4e21-a963-44bc-bf13-07bf8d8cbe82": {"__data__": {"id_": "a9be4e21-a963-44bc-bf13-07bf8d8cbe82", "embedding": null, "metadata": {"page_label": "7", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9917ef51-320a-4cd9-898b-94b7f904bac8", "node_type": "4", "metadata": {"page_label": "7", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8a87c475619750360f11c567c76e828fa0f07e2f3f6a54cf87790afbd1a7397f", "class_name": "RelatedNodeInfo"}}, "text": "2\nBackground\nSometimes the journey of a thousand steps begins by learning to\nwalk\n2.1 Systems Architecture\nThis section is a short review of System Architecture topics that you\u2019ll need for System Programming.\n2.1.1 Assembly\nWhat is assembly? Assembly is the lowest that you\u2019ll get to machine language without writing 1\u2019s and 0\u2019s. Each\ncomputer has an architecture, and that architecture has an associated assembly language. Each assembly command\nhas a 1:1 mapping to a set of 1\u2019s and 0\u2019s that tell the computer exactly what to do. For example, the following\nin the widely used x86 Assembly language add one to the memory address 20 [13]\u2013 you can also look in [8]\nSection 2A under the add instruction though it is more verbose.\nadd BYTE PTR [0x20], 1\nWhy do we mention this? Because it is important that although you are going to be doing most of this class in\nC, that this is what the code is translated into. Serious implications arise for race conditions and atomic operations.\n2.1.2 Atomic Operations\nAn operation is atomic if no other processor should interrupt it. Take for example the above assembly code to\nadd one to a register. In the architecture, it may actually have a few different steps on the circuit. The operation\nmay start by fetching the value of the memory from the stick of ram, then storing it in the cache or a register,\nand then \ufb01nally writing back [12]\u2013 under the description for fetch-and-add though your micro-architecture may\n7", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1455, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e5ba8d10-6a04-4fcb-91b6-5435cd292e1c": {"__data__": {"id_": "e5ba8d10-6a04-4fcb-91b6-5435cd292e1c", "embedding": null, "metadata": {"page_label": "8", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1cd9b5f2-c02d-476a-bbec-b7eaac8b2cf7", "node_type": "4", "metadata": {"page_label": "8", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "5a76c27cc63544b89ab04cfa80b9029453ec4ab64ada052d72f9a8f6cc78a6d1", "class_name": "RelatedNodeInfo"}}, "text": "8 CHAPTER 2. BACKGROUND\nvary . Or depending on performance operations, it may keep that value in cache or in a register which is local to\nthat process \u2013 try dumping the -O2optimized assembly of incrementing a variable. The problem comes in if two\nprocessors try to do it at the same time. The two processors could at the same time copy the value of the memory\naddress, add one, and store the same result back, resulting in the value only being incremented once. That is why\nwe have a special set of instructions on modern systems called atomic operations. If an instruction is atomic, it\nmakes sure that only one processor or thread performs any intermediate step at a time. With x86 this is done by\nthelock pre\ufb01x [8, p. 1120 ].\nlock add BYTE PTR [0x20], 1\nWhy don\u2019t we do this for everything? It makes commands slower! If every time a computer does something it\nhas to make sure that the other cores or processors aren\u2019t doing anything, it\u2019ll be much slower. Most of the time\nwe differentiate these with special consideration. Meaning, we will tell you when we use something like this.\nMost of the time you can assume the instructions are unlocked.\n2.1.3 Caching\nAh yes, Caching. One of computer science\u2019s greatest problems. The caching that we are referring to is processor\ncaching. If a particular address is already in the cache when reading or writing, the processor will perform the\noperation on the cache, such as adding and update the actual memory , later because updating memory is slow [9,\nSection 3.4 ]. If it isn\u2019t, the processor requests a chunk of memory from the memory chip and stores it in the cache,\nkicking out the least recently used page \u2013 this depends on caching policy , but Intel\u2019s does use this. This is done\nbecause the l3 processor cache is roughly three times faster to reach than the memory in terms of time [11, p. 22 ]\nthough exact speeds will vary based on the clock speed and architecture. Naturally , this leads to problems because\nthere are two different copies of the same value, in the cited paper this refers to an unshared line. This isn\u2019t a class\nabout caching, but you should know how this could impact your code. A short but non-complete list could be\n1.Race Conditions! If a value is stored in two different processor caches, then that value should be accessed\nby a single thread.\n2.Speed. With a cache, your program may look faster mysteriously . Just assume that reads and writes that\neither happened recently or are next to each other in memory are fast.\n3.Side effects. Every read or write affects the cache state. While most of the time this doesn\u2019t help or hurt, it\nis important to know. Check the Intel programmer guide on the lock pre\ufb01x for more information.\n2.1.4 Interrupts\nInterrupts are an important part of system programming. An interrupt is internally an electrical signal that is\ndelivered to the processor when something happens \u2013 this is a hardware interrupt [3]. Then the hardware decides\nif this is something that it should handle (e.g., handling keyboard or mouse input for older keyboard and mouses)\nor it should pass to the operating system. The operating system then decides if this is something that it should\nhandle (e.g., paging a memory table from disk) or something the application should handle (e.g., a SEGFAULT). If\nthe operating system decides that this is something that the process or program should take care of, it sends a\nsoftware fault and that software fault is then propagated. The application then decides if it is an error (SEGFAULT)", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3520, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fa29066c-8cca-4828-896e-313c50e4d4d0": {"__data__": {"id_": "fa29066c-8cca-4828-896e-313c50e4d4d0", "embedding": null, "metadata": {"page_label": "9", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "090ddc9c-e65e-406e-9e27-792be73779ce", "node_type": "4", "metadata": {"page_label": "9", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "df05123c73d662eba617e07b99f5bd634ec2c7769c10f5ddaac8ccfe89dfc6a9", "class_name": "RelatedNodeInfo"}}, "text": "2.2. DEBUGGING AND ENVIRONMENTS 9\nor not (SIGPIPE for example) and reports to the user. Applications can also send signals to the kernel and to the\nhardware as well. This is an oversimpli\ufb01cation because there are certain hardware faults that can\u2019t be ignored or\nmasked away , but this class isn\u2019t about teaching you to build an operating system.\nAn important application of this is how system calls are served! There is a well-established set of registers that\nthe arguments go in according to the kernel as well as a system call \u201cnumber\u201d again de\ufb01ned by the kernel. Then\nthe operating system triggers an interrupt which the kernel catches and serves the system call [7].\nOperating system developers and instruction set developers alike didn\u2019t like the overhead of causing an\ninterrupt on a system call. Now, systems use SYSENTER andSYSEXIT which has a cleaner way of transferring\ncontrol safely to the kernel and safely back. What safely means is obvious out of the scope for this class, but it\npersists.\n2.1.5 Optional: Hyperthreading\nHyperthreading is a new technology and is in no way shape or form multithreading. Hyperthreading allows\none physical core to appear as many virtual cores to the operating system [8, P .51]. The operating system can\nthen schedule processes on these virtual cores and one core will execute them. Each core interleaves processes\nor threads. While the core is waiting for one memory access to complete, it may perform a few instructions of\nanother process thread. The overall result is more instructions executed in a shorter time. This potentially means\nthat you can divide the number of cores you need to power smaller devices.\nThere be dragons here, though. With hyperthreading, you must be wary of optimizations. A famous hyper-\nthreading bug caused programs to crash if at least two processes were scheduled on a physical core, using speci\ufb01c\nregisters, in a tight loop. The actual problem is better explained through an architecture lens. But, the actual\napplication was found through systems programmers working on OCaml\u2019s mainline [10].\n2.2 Debugging and Environments\nI\u2019m going to tell you a secret about this course: it is about working smarter notharder. The course can be\ntime-consuming but the reason that so many people see it as such (and why so many students don\u2019t see it as such)\nis the relative familiarity of people with their tools. Let\u2019s go through some of the common tools that you\u2019ll be\nworking on and need to be familiar with.\n2.2.1 ssh\nsshis short for the Secure Shell [2]. It is a network protocol that allows you to spawn a shell on a remote machine.\nMost of the times in this class you will need to ssh into your VM like this\n$ ssh netid@sem-cs341-VM.cs.illinois.edu\nIf you don\u2019t want to type your password out every time, you can generate an ssh key that uniquely identi\ufb01es\nyour machine. If you already have a key pair, you can skip to the copy id stage.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2914, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "11fe3572-3869-4e39-bc45-5af527a859c7": {"__data__": {"id_": "11fe3572-3869-4e39-bc45-5af527a859c7", "embedding": null, "metadata": {"page_label": "10", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c7893d4a-0f97-46ab-9641-3d0473554ff1", "node_type": "4", "metadata": {"page_label": "10", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9e3c27fc9b63052339538b83b4c9419ccb8de621faed650cb93b0a6c15d2f734", "class_name": "RelatedNodeInfo"}}, "text": "10 CHAPTER 2. BACKGROUND\n>ssh-keygen -t rsa -b 4096\n#Dowhatever keygen tells you\n#Don\u2019tfeel like you need apasscode ifyour login password issecure\n>ssh-copy-id netid@sem-cs341-VM.cs.illinois.edu\n#Enter your password for maybe the final time\n>ssh netid@sem-cs341-VM.cs.illinois.edu\nIf you still think that that is too much typing, you can always alias hosts. You may need to restart your VM or\nreload sshd for this to take effect. The con\ufb01g \ufb01le is available on Linux and Mac distros. For Windows, you\u2019ll have\nto use the Windows Linux Subsystem or con\ufb01gure any aliases in PuTTY\n>cat ~/.ssh/config\nHost vm\nUser netid\nHostName sem-cs341-VM.cs.illinois.edu\n>ssh vm\n2.2.2 git\nWhat is \u2018git\u2018? Git is a version control system. What that means is git stores the entire history of a directory . We\nrefer to the directory as a repository . So what do you need to know is a few things. First, create your repository\nwith the repo creator. If you haven\u2019t already signed into enterprise GitHub, make sure to do so otherwise your\nrepository won\u2019t be created for you. After that, your repository is created on the server. Git is a decentralized\nversion control system, meaning that you\u2019ll need to get a repository onto your VM. We can do this with a clone.\nWhatever you do, do not go through the README.md tutorial .\n$ git clone https://github.com/illinois-cs-coursework/fa23_cs341_ <netid >\nThis will create a local repository . The work\ufb02ow is you make a change on your local repository , add the\nchanges to a current commit, actually commit, and push the changes to the server.\n$#edit the file ,maybe using vim\n$ git add <file >\n$ git commit -m \"Committing myfile \"\n$ git push origin master\nNow to explain git well, you need to understand that git for our purposes will look like a linked list. You will", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1788, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8da9ddc3-b1d6-467f-8822-f60301ea3cfc": {"__data__": {"id_": "8da9ddc3-b1d6-467f-8822-f60301ea3cfc", "embedding": null, "metadata": {"page_label": "11", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ddd96ceb-6a08-43ac-a3d6-5569bbb8dde6", "node_type": "4", "metadata": {"page_label": "11", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d07cd859526e7c5ae81dc3d0d1d6b94cc66623aaaf067c48022d75dda2e324d5", "class_name": "RelatedNodeInfo"}}, "text": "2.2. DEBUGGING AND ENVIRONMENTS 11\nalways be at the head of master, and you will do the edit-add-commit-push loop. We have a separate branch on\nGithub that we push feedback to under a speci\ufb01c branch which you can view on Github website. The markdown\n\ufb01le will have information on the test cases and results (like standard out).\nEvery so often git can break. Here is a list of commands you probably won\u2019t need to \ufb01x your repo\n1.git-cherry-pick\n2.git-pack\n3.git-gc\n4.git-clean\n5.git-rebase\n6.git-stash /git-apply /git-pop\n7.git-branch\nIf you are currently on a branch, and you don\u2019t see either\n$ git status\nOn branch master\nYour branch is up-to-date with \u2019origin /master \u2019.\nnothing to commit, working directory clean\nor\n$ git status\nOn branch master\nYour branch is up-to-date with \u2019origin /master \u2019.\nChanges not staged for commit:\n(use \"git add <file >...\"to update what will be committed)\n(use \"git checkout --<file >...\"to discard changes inworking\ndirectory)\nmodified: <FILE >\n...\nno changes added to commit (use \"git add\"and/or \"git commit -a\")\nAnd something like\n$ git status\nHEAD detached at 4bc4426\nnothing to commit, working directory clean", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1145, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d31821ef-d476-4626-a7d1-d616530d5049": {"__data__": {"id_": "d31821ef-d476-4626-a7d1-d616530d5049", "embedding": null, "metadata": {"page_label": "12", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f3399d71-ee43-4a02-b705-e9b6e70b5627", "node_type": "4", "metadata": {"page_label": "12", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "95c4261a5054b303d257d59cb7e6e3e96d9182eee3667489eacedc182557abd7", "class_name": "RelatedNodeInfo"}}, "text": "12 CHAPTER 2. BACKGROUND\nDon\u2019t panic, but your repository may be in an unworkable state. If you aren\u2019t nearing a deadline, come\nto of\ufb01ce hours or ask your question on Edstem, and we\u2019d be happy to help. In an emergency scenario, delete\nyour repository and re-clone (you\u2019ll have to add the release as above). This will lose any local uncommitted\nchanges. Make sure to copy any \ufb01les you were working on outside the directory, remove and copy them\nback in\nIf you want to learn more about git, there are all but an endless number of tutorials and resources online that\ncan help you. Here are some links that can help you out\n1.https://git-scm.com/docs/gittutorial\n2.https://www.atlassian.com/git/tutorials/what-is-version-control\n3.https://thenewstack.io/tutorial-git-for-absolutely-everyone/\n2.2.3 Editors\nSome people take this as an opportunity to learn a new editor, others not so much. The \ufb01rst part is those of you\nwho want to learn a new editor. In the editor war that spans decades, we have come to the battle of vim vs emacs.\nVim is a text editor and a Unix-like utility . You enter vim by typing vim [file] , which takes you into the\neditor. There are three most commonly used modes: normal mode, insert mode, and command mode. You start\noff in normal mode. In this mode, you can move around with many keys with the most common ones being hjkl\n(corresponding to left, down, up, and right, respectively). To run commands in vim, you can \ufb01rst type :and then\na command after it. For instance, to quit vim, simply type :q(q stands for quit). If you have any unsaved edits,\nyou must either save them :w, save and quit :wq, or quit and discard changes :q!. To make edits you can either\ntype ito change you into insert mode or ato change to insert mode after the cursor. This is the basics when it\ncomes to vim. In addition to the countless great resources out there on the internet, vim also has its own built-in\ntutorials set up for beginners. To access the interactive tutorial, enter vimtutor in the command line (not inside\nof vim), and you are all set!\nEmacs is more of a way of life, and I don\u2019t mean that \ufb01guratively . A lot of people say that emacs is a powerful\noperating system lacking a decent text editor. This means emacs can house a terminal, gdb session, ssh session,\ncode and a whole lot more. It would not be \ufb01tting any other way to introduce you to the gnu-emacs any\nother way than the gnu-docs https://www.gnu.org/software/emacs/tour/ . Just note that emacs is insanely\npowerful. You can do almost anything with it. There are a fair number of students who like the IDE-aspect of\nother programming languages. Know that you can set up emacs to be an IDE, but you have to learn a bit of Lisp\nhttp://martinsosic.com/development/emacs/2017/12/09/emacs-cpp-ide.html .\nThen there are those of you who like to use your own editors. That is completely \ufb01ne. For this, we require\nsshfs which has ports on many different machines.\n1.Windows https://github.com/billziss-gh/sshfs-win\n2.Mac https://github.com/osxfuse/osxfuse/wiki/SSHFS\n3.Linux https://help.ubuntu.com/community/SSHFS\nAt that point, the \ufb01les on your VM are synced with the \ufb01les on your machine and edits can be made and will\nbe synced.\nAt the time of writing, an author likes to use spacemacs http://spacemacs.org/ which marries both vim\nand emacs and both of their dif\ufb01culties. I\u2019ll give my soapbox for why I like it, but be warned that if you are starting\nfrom absolutely no vim or emacs experience the learning curve along with this course may be too much.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3528, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4320f7dd-1184-4e8e-8a31-446eacc8d6ec": {"__data__": {"id_": "4320f7dd-1184-4e8e-8a31-446eacc8d6ec", "embedding": null, "metadata": {"page_label": "13", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1fedf418-8bae-4881-a258-779292d1fa46", "node_type": "4", "metadata": {"page_label": "13", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a1a86a75782d39052e3eb3a041db33e4c4391688a0f4e9fcdabbabf3c2c27d3e", "class_name": "RelatedNodeInfo"}}, "text": "2.2. DEBUGGING AND ENVIRONMENTS 13\n1.Extensible. Spacemacs has a clean design written in lisp. There are 100s of packages ready to be installed\nby editing your spacemacs con\ufb01g and reloading that do everything from syntax checking, automatic static\nanalyzing, etc.\n2.Most of the good parts from vim and emacs. Emacs is good at doing everything by being a fast editor.\nVim is good at making fast edits and moving around. Spacemacs is the best of both worlds allowing vim\nkeybindings to all the emacs goodness underneath.\n3.Lots of precon\ufb01guration done. As opposed with a fresh emacs install, a lot of the con\ufb01gurations with\nlanguage and projects are done for you like neotree, helm, various language layers. All that you have to\ndo is navigate neotree to the base of your project and emacs will turn into an IDE for that programming\nlanguage.\nBut obviously to each his or her own. Many people will argue that editor gurus spend more time editing their\neditors and actually editing.\n2.2.4 Clean Code\nMake your code modular using helper functions. If there is a repeated task (getting the pointers to contiguous\nblocks in the malloc MP , for example), make them helper functions. And make sure each function does one thing\nwell so that you don\u2019t have to debug twice. Let\u2019s say that we are doing selection sort by \ufb01nding the minimum\nelement each iteration like so,\nvoid selection_sort( int *a, long len) {\nfor(long i = len-1 ;i>0;--i) {\nlong max_index = i ;\nfor(long j = len-1 ;j>= 0;--j) {\nif(a[max_index] <a[j]) {\nmax_index = j ;\n}\n}\nint temp = a[i] ;\na[i] = a[max_index] ;\na[max_index] = temp ;\n}\n}\nMany can see the bug in the code, but it can help to refactor the above method into\nlong max_index( int *a, long start, long end) ;\nvoid swap( int *a, long idx1, long idx2) ;\nvoid selection_sort( int *a, long len) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1812, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c018814-41ae-4a24-9559-c80116b6ff84": {"__data__": {"id_": "7c018814-41ae-4a24-9559-c80116b6ff84", "embedding": null, "metadata": {"page_label": "14", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a197d6ef-9836-4481-9a8d-ebf806025f07", "node_type": "4", "metadata": {"page_label": "14", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8bdf2b959a168b1857f37eecc010487ab4699860775162c00ed068159623b404", "class_name": "RelatedNodeInfo"}}, "text": "14 CHAPTER 2. BACKGROUND\nAnd the error is speci\ufb01cally in one function. In the end, this class is about writing system programs, not a class\nabout refactoring /debugging your code. In fact, most kernel code is so atrocious that you don\u2019t want to read it \u2013\nthe defense there is that it needs to be. But for the sake of debugging, it may bene\ufb01t you in the long run to adopt\nsome of these practices.\n2.2.5 Asserts\nUse assertions to make sure your code works up to a certain point \u2013 and importantly , to make sure you\ndon\u2019t break it later. For example, if your data structure is a doubly-linked list, you can do something like\nassert(node == node->next->prev) to assert that the next node has a pointer to the current node. You can\nalso check the pointer is pointing to an expected range of memory address, non-null, - >size is reasonable, etc.\nTheDEBUG macro will disable all assertions, so don\u2019t forget to set that once you \ufb01nish debugging [1].\nHere is a quick example with an assert. Let\u2019s say that we are writing code using memcpy . We would want to\nput an assert before that checks whether my two memory regions overlap. If they do overlap, memcpy runs into\nunde\ufb01ned behavior, so we want to discover that problem sooner rather than later.\nassert( src+n <dest || src >= dest + n) ;//source should finish\nbefore the destination orthe source starts after the end of\ndestination\nmemcpy(dest, src, n) ;\nThis check can be turned off at compile-time, but will save you tons of trouble debugging!\n2.3 Valgrind\nValgrind is a suite of tools designed to provide debugging and pro\ufb01ling tools to make your programs more\ncorrect and detect some runtime issues [4]. The most used of these tools is Memcheck, which can detect many\nmemory-related errors that are common in C and C ++programs and that can lead to crashes and unpredictable\nbehavior (for example, unfreed memory buffers). To run Valgrind on your program:\nvalgrind --leak-check=full --show-leak-kinds=all myprogram arg1 arg2\nArguments are optional and the default tool that will run is Memcheck. The output will be presented in the\nform: the number of allocations, frees, and errors. Suppose we have a simple program like this:\n#include <stdlib.h >\nvoid dummy_function() {\nint* x = malloc(10 * sizeof (int));", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2255, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b706542c-36ab-43f3-812a-09f1d5a835b9": {"__data__": {"id_": "b706542c-36ab-43f3-812a-09f1d5a835b9", "embedding": null, "metadata": {"page_label": "15", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ee128075-15b9-4494-95e8-69f842e66b19", "node_type": "4", "metadata": {"page_label": "15", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "dcb4b1f2c6bacb6b4f2beb5db7d2b8fb9b220ebed3857af5fbba1cf1b1ba5161", "class_name": "RelatedNodeInfo"}}, "text": "2.3. VALGRIND 15\nx[10] = 0 ; //error 1:Out ofbounds write ,asyou can see\nhere wewrite toanout ofbound memory address .\n} //error 2:Memory Leak ,xisallocated atfunction\nexit .\nint main( void ){\ndummy_function() ;\nreturn 0;\n}\nThis program compiles and runs with no errors. Let\u2019s see what Valgrind will output.\n==29515== Memcheck, a memory error detector\n==29515== Copyright (C) 2002-2015, and GNU GPL \u2019d,byJulian Seward et\nal.\n==29515== Using Valgrind -3.11.0 and LibVEX ;rerun with -hfor copyright\ninfo\n==29515== Command :./a\n==29515==\n==29515== Invalid write ofsize 4\n==29515== at0x400544 :dummy_function (in/home /rafi /projects /exocpp /a)\n==29515== by0x40055A :main (in/home /rafi /projects /exocpp /a)\n==29515== Address 0x5203068 is0bytes after ablock ofsize 40alloc \u2019d\n==29515== at 0x4C2DB8F: malloc (in\n/usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==29515== by 0x400537: dummy_function (in /home/rafi/projects/exocpp/a)\n==29515== by 0x40055A: main (in /home/rafi/projects/exocpp/a)\n==29515==\n==29515==\n==29515== HEAP SUMMARY:\n==29515== in use at exit: 40 bytes in 1 blocks\n==29515== total heap usage: 1 allocs, 0 frees, 40 bytes allocated\n==29515==\n==29515== LEAK SUMMARY:\n==29515== definitely lost: 40 bytes in 1 blocks\n==29515== indirectly lost: 0 bytes in 0 blocks\n==29515== possibly lost: 0 bytes in 0 blocks\n==29515== still reachable: 0 bytes in 0 blocks\n==29515== suppressed: 0 bytes in 0 blocks\n==29515== Rerun with --leak-check=full to see details of leaked memory\n==29515==\n==29515== For counts of detected and suppressed errors, rerun with: -v\n==29515== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\nInvalid write : It detected our heap block overrun, writing outside of an allocated block.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1731, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "37a5ee0a-30ae-4d0a-b0c1-5a93c879697b": {"__data__": {"id_": "37a5ee0a-30ae-4d0a-b0c1-5a93c879697b", "embedding": null, "metadata": {"page_label": "16", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4647b4cd-37af-4431-a3ae-504c2dcf74d2", "node_type": "4", "metadata": {"page_label": "16", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f5a26f585ab7559d3b5ee75fd212f6c5248e885c6d3db6c616643448ac67bf5a", "class_name": "RelatedNodeInfo"}}, "text": "16 CHAPTER 2. BACKGROUND\nDe\ufb01nitely lost : Memory leak \u2014 you probably forgot to free a memory block.\nValgrind is a effective tool to check for errors at runtime. C is special when it comes to such behavior, so after\ncompiling your program you can use Valgrind to \ufb01x errors that your compiler may miss and that usually happens\nwhen your program is running.\nFor more information, you can refer to the manual [4]\n2.3.1 TSAN\nThreadSanitizer is a tool from Google, built into clang and gcc, to help you detect race conditions in your code\n[5]. Note, that running with tsan will slow your code down a bit. Consider the following code.\n#include <pthread.h >\n#include <stdio.h >\nint global ;\nvoid *Thread1( void *x) {\nglobal ++;\nreturn NULL ;\n}\nint main() {\npthread_t t[2] ;\npthread_create(&t[0], NULL, Thread1, NULL) ;\nglobal = 100 ;\npthread_join(t[0], NULL) ;\n}\n//compile with gcc -fsanitize =thread -pie -fPIC -ltsan -gsimple_race .c\nWe can see that there is a race condition on the variable global . Both the main thread and created thread\nwill try to change the value at the same time. But, does ThreadSantizer catch it?\n$ ./a.out\n==================\nWARNING: ThreadSanitizer: data race (pid=28888)\nRead of size 4 at 0x7f73ed91c078 by thread T1:\n#0Thread1 /home /zmick2 /simple_race .c:7(exe+0x000000000a50 )\n#1:0(libtsan .so.0+0 x00000001b459 )\nPrevious write of size 4 at 0x7f73ed91c078 by main thread:\n#0main /home /zmick2 /simple_race .c:14 (exe+0x000000000ac8 )\nThread T1 (tid=28889, running) created by main thread at:\n#0:0(libtsan .so.0+0 x00000001f6ab )", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1556, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6272fc67-9183-4bdd-885f-bf81d36db1dd": {"__data__": {"id_": "6272fc67-9183-4bdd-885f-bf81d36db1dd", "embedding": null, "metadata": {"page_label": "17", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6a0ca485-6c93-417d-9da3-b62a23fe1ccc", "node_type": "4", "metadata": {"page_label": "17", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "467c21505f76d2cdff4cef25d09cf92f3ce92ec5800fd32a7c3fa23a32a0582e", "class_name": "RelatedNodeInfo"}}, "text": "2.4. GDB 17\n#1main /home /zmick2 /simple_race .c:13 (exe+0x000000000ab8 )\nSUMMARY: ThreadSanitizer: data race /home/zmick2/simple_race.c:7 Thread1\n==================\nThreadSanitizer: reported 1 warnings\nIf we compiled with the debug \ufb02ag, then it would give us the variable name as well.\n2.4 GDB\nGDB is short for the GNU Debugger. GDB is a program that helps you track down errors by interactively debugging\nthem [6]. It can start and stop your program, look around, and put in ad hoc constraints and checks. Here are a\nfew examples.\nSetting breakpoints programmatically A breakpoint is a line of code where you want the execution\nto stop and give control back to the debugger. A useful trick when debugging complex C programs with GDB is\nsetting breakpoints in the source code.\nint main() {\nint val = 1 ;\nval = 42 ;\nasm( \"int $3\");//set abreakpoint here\nval = 7 ;\n}\n$ gcc main.c -g -o main\n$ gdb --args ./main\n(gdb) r\n[...]\nProgram received signal SIGTRAP, Trace/breakpoint trap .\nmain () at main.c:6\n6 val = 7 ;\n(gdb) p val\n$1 = 42\nYou can also set breakpoints programmatically . Assume that we have no optimization and the line numbers\nare as follows\n1. int main() {\n2. int val = 1 ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1185, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "32c494f2-1d06-443a-b591-1e00106114ed": {"__data__": {"id_": "32c494f2-1d06-443a-b591-1e00106114ed", "embedding": null, "metadata": {"page_label": "18", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0e23cc10-5021-46b0-801a-841b98e1733f", "node_type": "4", "metadata": {"page_label": "18", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3d82998afb325348af74d421c4873578675802a1c48115cb5fb942f002b5283f", "class_name": "RelatedNodeInfo"}}, "text": "18 CHAPTER 2. BACKGROUND\n3. val = 42 ;\n4. val = 7 ;\n5.}\nWe can now set the breakpoint before the program starts.\n$ gcc main.c -g -o main\n$ gdb --args ./main\n(gdb) break main.c:4\n[...]\n(gdb) p val\n$1 = 42\nChecking memory content We can also use gdb to check the content of different pieces of memory . For\nexample,\nint main() {\nchar bad_string[3] = {\u2019C\u2019,\u2019a\u2019,\u2019t\u2019};\nprintf( \"%s\", bad_string) ;\n}\nCompiled we get\n$ gcc main.c -g -o main && ./main\n$ Cat ZVQ- $\nWe can now use gdb to look at speci\ufb01c bytes of the string and reason about when the program should\u2019ve\nstopped running\n(gdb) l\n1#include <stdio.h >\n2 int main() {\n3 char bad_string[3] = {\u2019C\u2019,\u2019a\u2019,\u2019t\u2019};\n4 printf (\"%s\", bad_string) ;\n5}\n(gdb) b 4\nBreakpoint 1 at 0x100000f57: file main.c, line 4.\n(gdb) r\n[...]\nBreakpoint 1, main () at main.c:4", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 796, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0785ae11-f7f6-42b8-b245-498d3b95ba5c": {"__data__": {"id_": "0785ae11-f7f6-42b8-b245-498d3b95ba5c", "embedding": null, "metadata": {"page_label": "19", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "aa7beeae-4f91-4376-8787-d80a21562319", "node_type": "4", "metadata": {"page_label": "19", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "fca844f0f9f92bf72f3112ab8d277d523f0c70c9a4736fbe4ff9cc433a50ded9", "class_name": "RelatedNodeInfo"}}, "text": "2.4. GDB 19\n4 printf (\"%s\", bad_string) ;\n(gdb) x/16xb bad_string\n0x7fff5fbff9cd: 0x63 0x61 0x74 0xe0 0xf9 0xbf 0x5f 0xff\n0x7fff5fbff9d5: 0x7f 0x00 0x00 0xfd 0xb5 0x23 0x89 0xff\n(gdb)\nHere, by using the xcommand with parameters 16xb , we can see that starting at memory address 0x7fff5fbff9c\n(value of bad_string ),printf would actually see the following sequence of bytes as a string because we provided\na malformed string without a null terminator.\n2.4.1 Involved gdb example\nHere is how one of your TAs would go through and debug a simple program that is going wrong. First, the source\ncode of the program. If you can see the error immediately , please bear with us.\n#include <stdio.h >\ndouble convert_to_radians( int deg) ;\nint main() {\nfor (int deg = 0 ;deg >360;++deg) {\ndouble radians = convert_to_radians(deg) ;\nprintf( \"%d.%f\\n\", deg, radians) ;\n}\nreturn 0;\n}\ndouble convert_to_radians( int deg) {\nreturn ( 31415 / 1000 ) * deg / 180 ;\n}\nHow can we use gdb to debug? First we ought to load GDB.\n$ gdb --args ./main\n(gdb) layout src ;#Ifyou want aGUI type\n(gdb) run\n(gdb)\nWant to take a look at the source?\n(gdb) l", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1122, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ee7efc66-d099-4091-900c-e2da76cfb457": {"__data__": {"id_": "ee7efc66-d099-4091-900c-e2da76cfb457", "embedding": null, "metadata": {"page_label": "20", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e563227a-515b-4e2f-b835-c1c6954d38ee", "node_type": "4", "metadata": {"page_label": "20", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d1480030ca7b6b6312ecd5b66ce6e13385640f4e6289024a10c1d23c95eb860f", "class_name": "RelatedNodeInfo"}}, "text": "20 CHAPTER 2. BACKGROUND\n1#include <stdio.h >\n2\n3 double convert_to_radians(int deg) ;\n4\n5 int main() {\n6 for (int deg = 0 ;deg >360;++deg) {\n7 double radians = convert_to_radians(deg) ;\n8 printf (\"%d.%f\\n\", deg, radians) ;\n9 }\n10 return 0;\n(gdb) break 7#break <file >:line orbreak <file >:function\n(gdb) run\n(gdb)\nFrom running the code, the breakpoint didn\u2019t even trigger, meaning the code never got to that point. Thats\nbecause of the comparison! Okay , \ufb02ip the sign it should work now right?\n(gdb) run\n350. 60.000000\n351. 60.000000\n352. 60.000000\n353. 60.000000\n354. 60.000000\n355. 61.000000\n356. 61.000000\n357. 61.000000\n358. 61.000000\n359. 61.000000\n(gdb) break 14ifdeg == 359 #Let\u2019scheck the last iteration only\n(gdb) run\n...\n(gdb) print/x deg #print the hex value ofdegree\n$1 = 0x167\n(gdb) print (31415/1000)\n$2 = 0x31\n(gdb) print (31415/1000.0)\n$3 = 201.749\n(gdb) print (31415.0/10000.0)\n$4 = 3.1414999999999999", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 919, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "439b4c0b-582d-41e6-b379-c1af78a8c972": {"__data__": {"id_": "439b4c0b-582d-41e6-b379-c1af78a8c972", "embedding": null, "metadata": {"page_label": "21", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "dcfc93af-a56b-4019-b44f-4272b9291044", "node_type": "4", "metadata": {"page_label": "21", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "610b681db6f9eb90f9f52728eb893bca331aa8f46a57a7e68994d315ab8062fb", "class_name": "RelatedNodeInfo"}}, "text": "2.4. GDB 21\nThat was only the bare minimum, though most of you will get by with that. There are a whole load more\nresources on the web, here are a few speci\ufb01c ones that can help you get started.\n1.Introduction to gdb\n2.GDB Manual\n3.CppCon 2015: Greg Law Give me 15 minutes I\u2019ll change your view of GDB\n2.4.2 Shell\nWhat do you actually use to run your program? A shell! A shell is a programming language that is running inside\nyour terminal. A terminal is merely a window to input commands. Now, on POSIX we usually have one shell\ncalled shthat is linked to a POSIX compliant shell called dash . Most of the time, you use a shell called bash that\nis somewhat POSIX compliant but has some nifty built-in features. If you want to be even more advanced, zsh\nhas some more powerful features like tab complete on programs and fuzzy patterns.\n2.4.3 Unde\ufb01ned Behavior Sanitizer\nThe unde\ufb01ned behavior sanitizer is a wonderful tool provided by the llvm project. It allows you to compile code\nwith a runtime checker to make sure that you don\u2019t do unde\ufb01ned behavior for various categories. We will try to\ninclude it into our projects, but requires support form all the external libraries that we use so we may not get\naround to all of them. https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html\nUnde\ufb01ned behavior - why we can\u2019t solve it in general\nAlso please please read Chris Lattner\u2019s 3 Part blog post on unde\ufb01ned behavior. It can shed light on debug builds\nand the mystery of compiler optimization.\nhttp://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\n2.4.4 Clang Static Build Tools\nClang provides a great drop-in replacement tools for compiling programs. If you want to see if there is an error\nthat may cause a race condition, casting error, etc, all you need to do is the following.\n$ scan-build make\nAnd in addition to the make output, you will get static build warnings.\n2.4.5 strace and ltrace\nstrace and ltrace are two programs that trace the system calls and library calls, respectively , of a running program\nor command. These may be missing on your system, so to install, run the following:", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2115, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "abdd009c-0e6c-461f-ae95-d339a599785e": {"__data__": {"id_": "abdd009c-0e6c-461f-ae95-d339a599785e", "embedding": null, "metadata": {"page_label": "22", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f509fb39-5993-4e40-9a4b-bdf976e45be8", "node_type": "4", "metadata": {"page_label": "22", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "adf5cf466cccb1fd13db83a8d47b587e44d4d741ba2acac8975caf70d0e6d35d", "class_name": "RelatedNodeInfo"}}, "text": "22 CHAPTER 2. BACKGROUND\n$ sudo apt install strace ltrace\nDebugging with ltrace can be as simple as \ufb01guring out what was the return call of the last library call that\nfailed.\nint main() {\nFILE *fp = fopen( \"Idon\u2019texist \",\"r\");\nfprintf(fp, \"a\");\nfclose(fp) ;\nreturn 0;\n}\n>ltrace ./a.out\n__libc_start_main(0x8048454, 1, 0xbfc19db4, 0x80484c0, 0x8048530\n<unfinished ... >\nfopen( \"Idon\u2019texist \",\"r\") = 0x0\nfwrite( \"Invalid Write \\n\", 1, 14, 0x0 <unfinished ... >\n--- SIGSEGV (Segmentation fault) ---\n+++ killed by SIGSEGV +++\nltrace output can clue you in to weird things your program is doing live. Unfortunately , ltrace cant be used\nto inject faults, meaning that ltrace can tell you what is happening, but it can\u2019t tamper with what is already\nhappening.\nstrace on the other hand could modify your program. Debugging with strace is amazing. The basic usage is\nrunning strace with a program, and itll get you a complete list of system call parameters.\n$ strace head README.md\nexecve( \"/usr/bin/head \", [\"head \",\"README .md\"], 0x7ffff28c8fa8 /* 60\nvars */) = 0\nbrk(NULL) = 0x7ffff5719000\naccess( \"/etc/ld.so.nohwcap \", F_OK) = -1 ENOENT (No such file or\ndirectory)\naccess( \"/etc/ld.so.preload \", R_OK) = -1 ENOENT (No such file or\ndirectory)\nopenat(AT_FDCWD, \"/etc/ld.so.cache \", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=32804, ... }) = 0\n...", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1362, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "92eb5feb-8e27-44e0-a601-01afa9af26c2": {"__data__": {"id_": "92eb5feb-8e27-44e0-a601-01afa9af26c2", "embedding": null, "metadata": {"page_label": "23", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c5c69c69-713b-4a2b-a855-e620b2469bf2", "node_type": "4", "metadata": {"page_label": "23", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "be2987ca2faa2e9a39c71f31a992b365387937e9055ff2eb28f6b5172d1e47e8", "class_name": "RelatedNodeInfo"}}, "text": "2.4. GDB 23\nIf the output is too verbose, you can use trace =with a command delimited list of syscalls to \ufb01lter all but those\ncalls.\n$ strace -e trace= read ,write head README.md\nread (3,\n\"\\177 ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0 >\\0\\1\\0\\0\\0\\260\\34\\2\\0\\0\\0\\0\\0 \"...,\n832) = 832\nread (3, \"#Locale name alias data base .\\n#\"..., 4096) = 2995\nread (3, \"\", 4096) = 0\nread (3, \"#CDatastructures \\n\\n[![Build Sta\"..., 8192) = 1250\nwrite(1, \"#CDatastructures \\n\", 19 #CDatastructures\nYou can also trace \ufb01les or targets.\n$ strace -e trace= read ,write -P README.md head README.md\nstrace: Requested path \u2019README .md\u2019resolved into\n\u2019/mnt/c/Users /user /personal /libds /README .md\u2019\nread (3, \"#CDatastructures \\n\\n[![Build Sta\"..., 8192) = 1250\nNewer versions of strace can actually inject faults into your program. This is useful when you want to\noccasionally make reads and writes fail for example in a networking application, which your program should\nhandle. The problem is as of early 2019, that version is missing from Ubuntu repositories. Meaning that you\u2019ll\nhave to install it from the source.\n2.4.6 printfs\nWhen all else fails, print! Each of your functions should have an idea of what it is going to do. You want to test\nthat each of your functions is doing what it set out to do and see exactly where your code breaks. In the case with\nrace conditions, tsan may be able to help, but having each thread print out data at certain times could help you\nidentify the race condition.\nTo make printfs useful, try to have a macro that \ufb01lls in the context by which the printf was called \u2013 a log\nstatement if you will. A simple useful but untested log statement could be as follows. Try to make a test and\n\ufb01gure out something that is going wrong, then log the state of your variables.\n#include <execinfo.h >\n#include <stdio.h >\n#include <stdlib.h >\n#include <stdarg.h >\n#include <unistd.h >\n//btisprint backtrace\nconst int num_stack = 10 ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1924, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fe12dcef-2f2d-4e5e-9c9c-a01a8640374a": {"__data__": {"id_": "fe12dcef-2f2d-4e5e-9c9c-a01a8640374a", "embedding": null, "metadata": {"page_label": "24", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "21b93e6b-daab-4c30-83ea-d7c09466d58d", "node_type": "4", "metadata": {"page_label": "24", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a5e821691aded1cd4443971050725dbc9b0237d3c8159450be16db11c0cc7951", "class_name": "RelatedNodeInfo"}}, "text": "24 CHAPTER 2. BACKGROUND\nint __log( int line, const char *file, int bt, const char *fmt, ...) {\nif(bt) {\nvoid *raw_trace[num_stack] ;\nsize_t size = backtrace(raw_trace, sizeof (raw_trace) /\nsizeof (raw_trace[0])) ;\nchar **syms = backtrace_symbols(raw_trace, size) ;\nfor(ssize_t i = 0 ;i<size ;i++){\nfprintf(stderr, \"|%s:%d|%s\\n\", file, line, syms[i]) ;\n}\nfree(syms) ;\n}\nint ret = fprintf(stderr, \"|%s:%d|\", file, line) ;\nva_list args ;\nva_start(args, fmt) ;\nret += vfprintf(stderr, fmt, args) ;\nva_end(args) ;\nret += fprintf(stderr, \"\\n\");\nreturn ret;\n}\n#ifdef DEBUG\n#define log(...) __log(__LINE__, __FILE__, 0, __VA_ARGS__)\n#define bt(...) __log(__LINE__, __FILE__, 1, __VA_ARGS__)\n#else\n#define log(...)\n#define bt(...)\n#endif\n//Use aslog(args like printf )orbt(args like printf )toeither log\norget backtrace\nint main() {\nlog( \"Hello Log\");\nbt(\"Hello Backtrace \");\n}\nAnd then use as appropriately . Check out the compiling and linking section in the appendix if you have any\nquestions on how a C program gets translated to machine code.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1039, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2483e054-85d1-4f30-8b1e-7f1b7e8800f0": {"__data__": {"id_": "2483e054-85d1-4f30-8b1e-7f1b7e8800f0", "embedding": null, "metadata": {"page_label": "25", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "44bc7c3b-6672-4636-954d-d24b9d933841", "node_type": "4", "metadata": {"page_label": "25", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d4b0fccc049418fceb3d3334a886a9e9554acb352847d1cc24d4783fe6fceb8f", "class_name": "RelatedNodeInfo"}}, "text": "2.5. HOMEWORK 0 25\n2.5 Homework 0\n//First ,can you guess which lyrics have been transformed into this\nC-like system code ?\nchar q[] = \"Doyou wanna build aC99 program ?\";\n#define or\"godebugging with gdb?\"\nstatic unsigned int i = sizeof (or) != strlen(or) ;\nchar * ptr = \"lathe \";\nsize_t come = fprintf(stdout, \"%sdoor \", ptr+2) ;\nint away = ! ( int) * \"\";\nint* shared = mmap(NULL, sizeof (int*), PROT_READ | PROT_WRITE,\nMAP_SHARED | MAP_ANONYMOUS, -1, 0) ;\nmunmap(shared, sizeof (int*));\nif(!fork()) {\nexeclp( \"man\",\"man\",\"-3\",\"ftell \", (char *)0) ;perror( \"failed \");\n}\nif(!fork()) {\nexeclp( \"make \",\"make \",\"snowman \", (char *)0) ;execlp( \"make \",\"make \",\n(char *)0)) ;\n}\nexit(0) ;\n2.5.1 So you want to master System Programming? And get a better\ngrade than B?\nm\nint main( int argc, char ** argv) {\nputs( \"Great !Wehave plenty ofuseful resources for you,but it\u2019sup\ntoyou to\");\nputs( \"beanactive learner and learn how tosolve problems and\ndebug code .\");\nputs( \"Bring your near -completed answers the problems below \");\nputs( \"tothe first lab toshow that you\u2019vebeen working onthis .\");\nprintf( \"Afew \\\"don\u2019tknows \\\"or\\\"unsure \\\"isfine for lab 1.\\n\");\nputs( \"Warning :you and your peers will work hard inthis class .\");\nputs( \"This isnot CS225 ;you will bepushed much harder to\");", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1279, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b2791746-967c-4734-9013-5c6e7de5489a": {"__data__": {"id_": "b2791746-967c-4734-9013-5c6e7de5489a", "embedding": null, "metadata": {"page_label": "26", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "56f9e0ba-4f3e-4fdc-8829-7ab05a87e493", "node_type": "4", "metadata": {"page_label": "26", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "17b05bdffc8b57f87d38b12dc6c527ee8a75410f8c2b9cc6056d559b96284ec4", "class_name": "RelatedNodeInfo"}}, "text": "26 CHAPTER 2. BACKGROUND\nputs( \"work things out onyour own.\");\nfprintf(stdout, \"This homework isastepping stone toall future\nassignments .\\n\");\nchar p[] = \"So,you will want toclear upany confusions or\nmisconceptions .\\n\";\nwrite(1, p, strlen(p) ) ;\nchar buffer[1024] ;\nsprintf(buffer, \"For grading purposes ,this homework 0will begraded\naspart ofyour lab %dwork .\\n\", 1) ;\nwrite(1, buffer, strlen(buffer)) ;\nprintf( \"Press Return tocontinue \\n\");\nread(0, buffer, sizeof (buffer)) ;\nreturn 0;\n}\n2.5.2 Watch the videos and write up your answers to the following ques-\ntions\nImportant!\nThe virtual machine-in-your-browser and the videos you need for HW0 are here:\nhttp://cs-education.github.io/sys/\nQuestions? Comments? Use the current semester\u2019s CS341 Edstem: https://edstem.org/us/courses/\n61021/discussion/\nThe in-browser virtual machine runs entirely in JavaScript and is fastest in Chrome. Note the VM and any\ncode you write is reset when you reload the page, so copy your code to a separate document. The post-video\nchallenges are not part of homework 0, but you learn the most by doing rather than passively watching. You have\nsome fun with each end-of-video challenge.\nHW0 questions are below. Copy your answers into a text document because you\u2019ll need to submit them later\nin the course.\n2.5.3 Chapter 1\nIn which our intrepid hero battles standard out, standard error, \ufb01le descriptors and writing to \ufb01les\n1.Hello, World! (system call style) Write a program that uses write() to print out \"Hi! My name is <Your\nName >\".\n2.Hello, Standard Error Stream! Write a function to print out a triangle of height nto standard error. Your\nfunction should have the signature void write_triangle(int n) and should use write() . The triangle\nshould look like this, for n =3:\n*\n**\n***", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1773, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "077bf166-95b1-41fb-a0bb-bc780e2a82d2": {"__data__": {"id_": "077bf166-95b1-41fb-a0bb-bc780e2a82d2", "embedding": null, "metadata": {"page_label": "27", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "17ed935a-f655-433e-b0f0-3585bcaf87b9", "node_type": "4", "metadata": {"page_label": "27", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7bd21865659215c5ad089dd8c9e63e2a7c4fa5dd2d06ed5908c2a3a213ce03c6", "class_name": "RelatedNodeInfo"}}, "text": "2.5. HOMEWORK 0 27\n3.Writing to \ufb01les Take your program from \"Hello, World!\" modify it write to a \ufb01le called hello_world.txt .\nMake sure to use correct \ufb02ags and a correct mode for open() (man 2 open is your friend).\n4.Not everything is a system call Take your program from \"Writing to \ufb01les\" and replace write() with\nprintf() .Make sure to print to the \ufb01le instead of standard out!\n5.What are some differences between write() andprintf() ?\n2.5.4 Chapter 2\nSizing up C types and their limits, intandchar arrays, and incrementing pointers\n1.How many bits are there in a byte?\n2.How many bytes are there in a char ?\n3.How many bytes the following are on your machine? int,double ,float ,long , and long long\n4.On a machine with 8 byte integers, the declaration for the variable data isint data[8] . If the address of\ndata is 0x7fbd9d40 , then what is the address of data+2 ?\n5.What is data[3] equivalent to in C? Hint: what does C convert data[3] to before dereferencing the\naddress? Remember, the type of a string constant \"abc\" is an array .\n6.Why does this SEGFAULT?\nchar *ptr = \"hello \";\n*ptr = \u2019J\u2019;\n7.What is the value of the variable str_size ?\nssize_t str_size = sizeof (\"Hello \\0World \")\n8.What is the value of the variable str_len\nssize_t str_len = strlen( \"Hello \\0World \")\n9.Give an example of X such that sizeof(X) is 3.\n10.Give an example of Y such that sizeof(Y) might be 4 or 8 depending on the machine.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1413, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3595dc72-3215-4622-9525-d56a5b947943": {"__data__": {"id_": "3595dc72-3215-4622-9525-d56a5b947943", "embedding": null, "metadata": {"page_label": "28", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "da86aa0a-3ee6-428e-a336-5f70c0681132", "node_type": "4", "metadata": {"page_label": "28", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "fa96d4b005bdbd514a82d41ff5c3fd708785006883ad473dc5e0a0b580655a4e", "class_name": "RelatedNodeInfo"}}, "text": "28 CHAPTER 2. BACKGROUND\n2.5.5 Chapter 3\nProgram arguments, environment variables, and working with character arrays (strings)\n1.What are at least two ways to \ufb01nd the length of argv ?\n2.What does argv[0] represent?\n3.Where are the pointers to environment variables stored (on the stack, the heap, somewhere else)?\n4.On a machine where pointers are 8 bytes, and with the following code:\nchar *ptr = \"Hello \";\nchar array[] = \"Hello \";\nWhat are the values of sizeof(ptr) andsizeof(array) ? Why?\n5.What data structure manages the lifetime of automatic variables?\n2.5.6 Chapter 4\nHeap and stack memory , and working with structs\n1.If I want to use data after the lifetime of the function it was created in ends, where should I put it? How do\nI put it there?\n2.What are the differences between heap and stack memory?\n3.Are there other kinds of memory in a process?\n4.Fill in the blank: \"In a good C program, for every malloc, there is a ___\".\n5.What is one reason malloc can fail?\n6.What are some differences between time() andctime() ?\n7.What is wrong with this code snippet?\nfree(ptr) ;\nfree(ptr) ;\n8.What is wrong with this code snippet?\nfree(ptr) ;\nprintf( \"%s\\n\", ptr) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1169, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7a70b554-eff8-4b0e-a35a-973f0f518200": {"__data__": {"id_": "7a70b554-eff8-4b0e-a35a-973f0f518200", "embedding": null, "metadata": {"page_label": "29", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a8896d80-cf5a-4214-8f05-e7ea877dee95", "node_type": "4", "metadata": {"page_label": "29", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "cd0454924f9de1592c025daae707491ccfc7cc8b56d455d6612a26d1416172ca", "class_name": "RelatedNodeInfo"}}, "text": "2.5. HOMEWORK 0 29\n9.How can one avoid the previous two mistakes?\n10.Create a struct that represents a Person . Then make a typedef , so that struct Person can be replaced\nwith a single word. A person should contain the following information: their name (a string), their age (an\ninteger), and a list of their friends (stored as a pointer to an array of pointers to Person s).\n11.Now, make two persons on the heap, \"Agent Smith\" and \"Sonny Moore\", who are 128 and 256 years old\nrespectively and are friends with each other. Create functions to create and destroy a Person (Person\u2019s and\ntheir names should live on the heap).\n12.create() should take a name and age. The name should be copied onto the heap. Use malloc to reserve\nsuf\ufb01cient memory for everyone having up to ten friends. Be sure initialize all \ufb01elds (why?).\n13.destroy() should free up both the memory of the person struct and all of its attributes that are stored on\nthe heap. Destroying one person keeps other people in tact any other.\n2.5.7 Chapter 5\nText input and output and parsing using getchar ,gets , and getline .\n1.What functions can be used for getting characters from stdin and writing them to stdout ?\n2.Name one issue with gets() .\n3.Write code that parses the string \"Hello 5 World\" and initializes 3 variables to \"Hello\", 5, and \"World\".\n4.What does one need to de\ufb01ne before including getline() ?\n5.Write a C program to print out the content of a \ufb01le line-by-line using getline() .\n2.5.8 C Development\nThese are general tips for compiling and developing using a compiler and git. Some web searches will be useful\nhere\n1.What compiler \ufb02ag is used to generate a debug build?\n2.You \ufb01x a problem in the Make\ufb01le and type make again. Explain why this may be insuf\ufb01cient to generate a\nnew build.\n3.Are tabs or spaces used to indent the commands after the rule in a Make\ufb01le?\n4.What does git commit do? What\u2019s a shain the context of git?\n5.What does git log show you?\n6.What does git status tell you and how would the contents of .gitignore change its output?\n7.What does git push do? Why is it insuf\ufb01cient to commit with git commit -m \u2019fixed all bugs\u2019 ?\n8.What does a non-fast-forward error git push reject mean? What is the most common way of dealing with\nthis?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2233, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27ccb3ba-c898-472c-81bd-bf9b6c874136": {"__data__": {"id_": "27ccb3ba-c898-472c-81bd-bf9b6c874136", "embedding": null, "metadata": {"page_label": "30", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cecf2247-2f43-4d26-ac26-c05c35d78ea2", "node_type": "4", "metadata": {"page_label": "30", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "40ca2870631f1cc42ca0f091d5ccb89d0da2ca5002c8cd30783fda5b527b7cb9", "class_name": "RelatedNodeInfo"}}, "text": "30 CHAPTER 2. BACKGROUND\n2.5.9 Optional: Just for fun\n\u2022Convert a song lyrics into System Programming and C code covered in this wiki book and share on the class\nforum.\n\u2022Find, in your opinion, the best and worst C code on the web and post the link to the class forum.\n\u2022Write a short C program with a deliberate subtle C bug and post it on the class forum to see if others can\nspot your bug.\n\u2022Do you have any cool /disastrous system programming bugs you\u2019ve heard about? Feel free to share with\nyour peers and the course staff on the class forum.\n2.6 University of Illinois Speci\ufb01c Guidelines\n2.6.1 The class forum\nTAs and student assistants get a ton of questions. Some are well-researched, and some are not. This is a handy\nguide that\u2019ll help you move away from the latter and towards the former. Oh, and did I mention that this is an\neasy way to score points with your internship managers? Ask yourself...\n1.Am I running on my Virtual Machine?\n2.Did I check the man pages?\n3.Have I searched for similar questions /followups on the class forum?\n4.Have I read the MP /Lab speci\ufb01cation completely?\n5.Have I watched all of the videos?\n6.Did I Google the error message and a few permutations thereof if necessary? How about StackOver\ufb02ow.\n7.Did I try commenting out, printing, and /or stepping through parts of the code bit by bit to \ufb01nd out precisely\nwhere the error occurs?\n8.Did I commit my code to git in case the TAs need more context?\n9.Did I include the console /GDB/Valgrind output **AND** code surrounding the bug in my the class forum\npost?\n10.Have I \ufb01xed other segmentation faults unrelated to the issue I\u2019m having?\n11.Am I following good programming practice? (i.e. encapsulation, functions to limit repetition, etc)\nThe biggest tip that we can give you when asking a question on the class forum if you want a swift answer is\ntoask your question like you were trying to answer it . Like before you ask a question, try to answer it yourself.\nIf you are thinking about posting\nHi, My code got a 50\nSounds good and courteous, but course staff would much much prefer a post resembling the following", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2100, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "997915f9-7a8d-4ba0-af4b-4cebcfbd3761": {"__data__": {"id_": "997915f9-7a8d-4ba0-af4b-4cebcfbd3761", "embedding": null, "metadata": {"page_label": "31", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5b5be961-b8de-4475-88d8-022399d68eb5", "node_type": "4", "metadata": {"page_label": "31", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ef9b28ee9c053819c7eb1019194dee5fb5574d6445312210e6f16471e20e02a0", "class_name": "RelatedNodeInfo"}}, "text": "BIBLIOGRAPHY 31\nHi, I recently failed test X, Y , Z which is about half the tests on this current assignment. I noticed that\nthey all have something to do with networking and epoll, but couldn\u2019t \ufb01gure out what was linking\nthem together, or I may be completely off track. So to test my idea, I tried spawning 1000 clients\nwith various get and put requests and verifying the \ufb01les matched their originals. I couldn\u2019t get it to\nfail while running normally , the debug build, or valgrind or tsan. I have no warnings and none of\nthe pre-syntax checks showed me anything. Could you tell me if my understanding of the failure is\ncorrect and what I could do to modify my tests to better re\ufb02ect X, Y, Z? netid: bvenkat2\nYou don\u2019t need to be as courteous, though we\u2019d appreciate it, this will get a faster response time hand over\nfoot. If you were trying to answer this question, you\u2019d have everything you need in the question body .\nBibliography\n[1]assert. URL http://www.cplusplus.com/reference/cassert/assert/ .\n[2]ssh(1). URL https://man.openbsd.org/ssh.1 .\n[3]Chapter 3. hardware interrupts. URL https://access.redhat.com/documentation/en-US/\nRed_Hat_Enterprise_MRG/1.3/html/Realtime_Reference_Guide/chap-Realtime_Reference_\nGuide-Hardware_interrupts.html .\n[4]4. memcheck: a memory error detector. URL http://valgrind.org/docs/manual/mc-manual.html .\n[5]Threadsanitizercppmanual, Dec 2018. URL https://github.com/google/sanitizers/wiki/\nThreadSanitizerCppManual .\n[6]Gdb: The gnu project debugger, Feb 2019. URL https://www.gnu.org/software/gdb/ .\n[7]Manu Garg. Sysenter based system call mechanism in linux 2.6, 2006. URL http://articles.manugarg.\ncom/systemcallinlinux2_6.html .\n[8]Part Guide. Intel\u00ae 64 and ia-32 architectures software developers manual. Volume 3B: System programming\nGuide, Part , 2, 2011.\n[9]CAT Intel. Improving real-time performance by utilizing cache allocation technology . Intel Corporation, April ,\n2015.\n[10]Xavier Leroy . How i found a bug in intel skylake processors, Jul 2017. URL http://gallium.inria.fr/\nblog/intel-skylake-bug/ .\n[11]David Levinthal. Performance analysis guide for intel core i7 processor and intel xeon 5500 processors. Intel\nPerformance Analysis Guide , 30:18, 2009.\n[12]Hermann Schweizer, Maciej Besta, and Torsten Hoe\ufb02er. Evaluating the cost of atomic operations on modern\narchitectures. In 2015 International Conference on Parallel Architecture and Compilation (PACT) , pages\n445\u2013456. IEEE, 2015.\n[13]Wikibooks. X86 assembly \u2014 wikibooks, the free textbook project, 2018. URL https://en.wikibooks.\norg/w/index.php?title=X86_Assembly&oldid=3477563 .[Online; accessed 19-March-2019 ].", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2632, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "98cc8976-1db4-4043-b48b-1cc68787f71f": {"__data__": {"id_": "98cc8976-1db4-4043-b48b-1cc68787f71f", "embedding": null, "metadata": {"page_label": "178", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bf708e73-028f-4fa9-8a5e-47cf94aa6ba2", "node_type": "4", "metadata": {"page_label": "178", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "5b80da5361aa08021ed3c9c6738a58f6ca54b5aac0638aba9fecaf673e403958", "class_name": "RelatedNodeInfo"}}, "text": "8\nDeadlock\nNo, you can\u2019t always get what you want\nYou can\u2019t always get what you want\nYou can\u2019t always get what you want\nBut if you try sometimes you \ufb01nd\nYou get what you need\nThe philosophers Jagger & Richards\nDeadlock is de\ufb01ned as when a system cannot make any forward progress. We de\ufb01ne a system for the rest\nof the chapter as a set of rules by which a set of processes can move from one state to another, where a state is\neither working or waiting for a particular resource. Forward progress is de\ufb01ned as if there is at least one process\nworking or we can award a process waiting for a resource that resource. In a lot of systems, Deadlock is avoided\nby ignoring the entire concept [4, P .237 ]. Have you heard about turn it on and off again? For products where the\nstakes are low (User Operating Systems, Phones), it may be more ef\ufb01cient to allow deadlock. But in the cases\nwhere \u201cfailure is not an option\u201d - Apollo 13, you need a system that tracks, breaks, or prevents deadlocks. Apollo\n13 didn\u2019t fail because of deadlock, but it wouldn\u2019t be good to restart the system on liftoff.\nMission-critical operating systems need this guarantee formally because playing the odds with people\u2019s lives\nisn\u2019t a good idea. Okay so how do we do this? We model the problem. Even though it is a common statistical\nphrase that all models are wrong, the more accurate the model is to the system the higher the chance the method\nwill work.\n178", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1429, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7573d4c1-dbf8-4501-a402-00ed0c4b9d81": {"__data__": {"id_": "7573d4c1-dbf8-4501-a402-00ed0c4b9d81", "embedding": null, "metadata": {"page_label": "179", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "114632de-9b30-46f5-a3a7-bcee359ddf7d", "node_type": "4", "metadata": {"page_label": "179", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6c7d0a0a1db5eaee3c08128dca421e931312a80b5e35e0434299f046fb8d8162", "class_name": "RelatedNodeInfo"}}, "text": "8.1. RESOURCE ALLOCATION GRAPHS 179\n8.1 Resource Allocation Graphs\nProcess 1\nResource 1Process 2 Process 3\nResource 2\nFigure 8.1: Resource allocation graph\nOne such way is modeling the system with a resource allocation graph (RAG). A resource allocation graph tracks\nwhich resource is held by which process and which process is waiting for a resource of a particular type. It is\na simple yet powerful tool to illustrate how interacting processes can deadlock. If a process is using a resource,\nan arrow is drawn from the resource node to the process node. If a process is requesting a resource, an arrow\nis drawn from the process node to the resource node. If there is a cycle in the Resource Allocation Graph and\neach resource in the cycle provides only one instance, then the processes will deadlock. For example, if process 1\nholds resource A, process 2 holds resource B and process 1 is waiting for B and process 2 is waiting for A, then\nprocesses 1 and 2 will be deadlocked 8.1. We\u2019ll make the distinction that the system is in deadlock by de\ufb01nition if\nall workers cannot perform an operation other than waiting. We can detect a deadlock by traversing the graph\nand searching for a cycle using a graph traversal algorithm, such as the Depth First Search (DFS). This graph is\nconsidered as a directed graph and we can treat both the processes and resources as nodes.\nm\ntypedef struct {\nint node_id ;//Node inthis particular graph\nGraph **reachable_nodes ;//List ofnodes that can bereached\nfrom this node\nint size_reachable_nodes ;//Size ofthe List\n}Graph ;\n//isCyclic ()traverses agraph using DFS and detects whether ithas\nacycle\n//isCyclic ()uses arecursive approach\n//Gpoints toanode inagraph ,which can beeither aresource or\naprocess", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1740, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5dd9444e-cfd6-430b-8dab-aec1786e1b96": {"__data__": {"id_": "5dd9444e-cfd6-430b-8dab-aec1786e1b96", "embedding": null, "metadata": {"page_label": "180", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8c106819-d756-47f1-874c-d6e955242785", "node_type": "4", "metadata": {"page_label": "180", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c5dfc1d8f3c513f63c82f626cd9187fe6d91fd2c3cd7975de0159cb6106f5807", "class_name": "RelatedNodeInfo"}}, "text": "180 CHAPTER 8. DEADLOCK\n//is_visited isanarray indexed with node_id and initialized with\nzeros (false )torecord whether aparticular node has been\nvisited\nint isCyclic(Graph *G, int* is_visited) {\nif(this graph has been visited) {\n//Oh!the cycle isfound\nreturn true ;\n}else {\n1. Mark this node as visited\n2. Traverse through all nodes in the reachable_nodes\n3. Call isCyclic() for each node\n4. Evaluate the return value of isCyclic()\n}\n//Nope ,this graph isacyclic\nreturn false ;\n}\nProcess 1\nResource 1Process 2 Process 3\nResource 2\nFigure 8.2: Graph based Deadlock\n8.2 Coffman Conditions\nSurely cycles in RAGs happen all the time in an OS, so why doesn\u2019t it grind to a halt? You may not see deadlock\nbecause the OS may preempt some processes breaking the cycle but there is still a chance that your three lonely\nprocesses could deadlock.\nThere are four necessary and suf\ufb01cient conditions for deadlock \u2013 meaning if these conditions hold then there\nis a non-zero probability that the system will deadlock at any given iteration. These are known as the Coffman\nConditions [1].\n\u2022Mutual Exclusion: No two processes can obtain a resource at the same time.\n\u2022Circular Wait: There exists a cycle in the Resource Allocation Graph, or there exists a set of processes {P1,\nP2,. . . }such that P1 is waiting for resources held by P2, which is waiting for P3,. . . , which is waiting for P1.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1377, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "92efb306-b55e-4564-915e-855359719d79": {"__data__": {"id_": "92efb306-b55e-4564-915e-855359719d79", "embedding": null, "metadata": {"page_label": "181", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cb95103d-b41b-43b0-956a-dac43d64fb70", "node_type": "4", "metadata": {"page_label": "181", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "0469889cf72f367d84e5b879514d6d7b52da8d60be0c30c33499227827ba9543", "class_name": "RelatedNodeInfo"}}, "text": "8.2. COFFMAN CONDITIONS 181\n\u2022Hold and Wait: Once a resource is obtained, a process keeps the resource locked.\n\u2022No pre-emption: Nothing can force the process to give up a resource.\nProof: Deadlock can happen if and only if the four Coffman conditions are satis\ufb01ed.\n\u2192If the system is deadlocked, the four Coffman conditions are apparent.\n\u2022For contradiction, assume that there is no circular wait. If not then that means the resource allocation\ngraph is acyclic, meaning that there is at least one process that is not waiting on any resource to be\nfreed. Since the system can move forward, the system is not deadlocked.\n\u2022For contradiction, assume that there is no mutual exclusion. If not, that means that no process is\nwaiting on any other process for a resource. This breaks circular wait and the previous argument\nproves correctness.\n\u2022For contradiction, assume that processes don\u2019t hold and wait but our system still deadlocks. Since we\nhave circular wait from the \ufb01rst condition at least one process must be waiting on another process. If\nthat and processes don\u2019t hold and wait, that means one process must let go of a resource. Since the\nsystem has moved forward, it cannot be deadlocked.\n\u2022For contradiction, assume that we have preemption, but the system cannot be un-deadlocked. Have\none process, or create one process, that recognizes the circular wait that must be apparent from above\nand break one of the links. By the \ufb01rst branch, we must not have deadlocked.\n\u2190If the four conditions are apparent, the system is deadlocked. We will prove that if the system\nis not deadlocked, the four conditions are not apparent. Though this proof is not formal, let us build a\nsystem with the three requirements not including circular wait. Let assume that there is a set of processes\nP={p1,p2, ...,pn}and there is a set of resources R={r1,r2, ...,rm}. For simplicity , a process can only\nrequest one resource at a time but the proof can be generalized to multiple. Let assume that the system is a\nstate at time t. Let us assume that the state of the system is a tuple (ht,wt)where there are two functions\nht:R\u2192P\u222a{unassigned}that maps resources to the processes that own them (this is a function, meaning\nthat we have mutual exclusion) and or unassigned and wt:P\u2192R\u222a{satis\ufb01ed}that maps the requests that\neach process makes to a resource or if the process is satis\ufb01ed. If the process is satis\ufb01ed, we consider the\nwork trivial and the process exits, releasing all resources \u2013 this can also be generalized. Let Lt\u2286P\u00d7Rbe\na set of lists of requests that a process uses to release a resource at any given time. The evolution of the\nsystem is at each step at every time.\n\u2022Release all resources in Lt.\n\u2022Find a process that is requesting a resource\n\u2022If that resource is available give it to that process, generating a new (ht+1,wt+1)and exit the current\niteration.\n\u2022Else \ufb01nd another process and try the same resource allocation procedure in the previous step.\nIf all processes have been surveyed and if all are requesting a resource and none can be granted a\nresource, consider it deadlocked. More formally , this system is deadlocked means if \u2203t0,\u2200t\u2265t0,\u2200p\u2208\nP,wt(p)\u0338=satis\ufb01ed and\u2203q,q\u0338=p\u2192ht(wt(p)) = q(which is what we need to prove).\nMutual exclusion and no pre-emption are encoded into the system. Circular wait implies the second\ncondition, a resource is owned by another process which is owned by another process meaning at this state", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3420, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6b7be912-5f70-43d4-93dc-64134f580a58": {"__data__": {"id_": "6b7be912-5f70-43d4-93dc-64134f580a58", "embedding": null, "metadata": {"page_label": "182", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2c1ceec5-b0c6-4b1e-9617-bba50e0170cc", "node_type": "4", "metadata": {"page_label": "182", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6c170792aecd5301ec4f0498154a4763f1dd182321ee59d4e42d234e07801204", "class_name": "RelatedNodeInfo"}}, "text": "182 CHAPTER 8. DEADLOCK\n\u2200p\u2208P,\u2203q\u0338=p\u2192ht(wt(p)) = q. Circular wait also implies that at this current state, no process is satis\ufb01ed,\nmeaning at this state \u2200p\u2208P,wt(p)\u0338=satis\ufb01ed . Hold and wait simply proves the condition that from this\npoint onward, the system will not change, which is all the conditions that we needed to show. \u25a1\nIf a system breaks any of them, it cannot have deadlock! Consider the scenario where two students need to\nwrite both pen and paper and there is only one of each. Breaking mutual exclusion means that the students share\nthe pen and paper. Breaking circular wait could be that the students agree to grab the pen then the paper. As\nproof by contradiction, say that deadlock occurs under the rule and the conditions. Without loss of generality ,\nthat means a student would have to be waiting on a pen while holding the paper and the other waiting on a pen\nand holding the paper. We have contradicted ourselves because one student grabbed the paper without grabbing\nthe pen, so deadlock fails to occur. Breaking hold and wait could be that the students try to get the pen and then\nthe paper and if a student fails to grab the paper then they release the pen. This introduces a new problem called\nlivelock which will be discussed later. Breaking preemption means that if the two students are in deadlock the\nteacher can come in and break up the deadlock by giving one of the students a held item or tell both students to\nput the items down.\nlivelock relates to deadlock. Consider the breaking hold-and-wait solution as above. Though deadlock is\navoided, if the philosopher picks up the same device again and again in the same pattern, no work will be done.\nLivelock is generally harder to detect because the processes generally look like they are working to the outside\noperating system whereas in deadlock the operating system generally knows when two processes are waiting on\na system-wide resource. Another problem is that there are necessary conditions for livelock (i.e. deadlock fails\nto occur) but not suf\ufb01cient conditions \u2013 meaning there is no set of rules where livelock has to occur. You must\nformally prove in a system by what is known as an invariant. One has to enumerate each of the steps of a system\nand if each of the steps eventually \u2013 after some \ufb01nite number of steps \u2013 leads to forward progress, the system fails\nto livelock. There are even better systems that prove bounded waits; a system can only be livelocked for at most n\ncycles which may be important for something like stock exchanges.\n8.3 Approaches to Solving Livelock and Deadlock\nIgnoring deadlock is the most obvious approach. Quite humorously , the name for this approach is called the\nostrich algorithm. Though there is no apparent source, the idea for the algorithm comes from the concept of\nan ostrich sticking its head in the sand. When the operating system detects deadlock, it does nothing out of the\nordinary , and any deadlock usually goes away . An operating system preempts processes when stopping them for\ncontext switches. The operating system can interrupt any system call, potentially breaking a deadlock scenario.\nThe OS also makes some \ufb01les read-only thus making the resource shareable. What the algorithm refers to is that if\nthere is an adversary that speci\ufb01cally crafts a program \u2013 or equivalently a user who poorly writes a program \u2013 that\nthe OS deadlocks. For everyday life, this tends to be \ufb01ne. When it is not we can turn to the following method.\nDeadlock detection allows the system to enter a deadlocked state. After entering, the system uses the\ninformation to break deadlock. As an example, consider multiple processes accessing \ufb01les. The operating system\ncan keep track of all of the \ufb01les /resources through \ufb01le descriptors at some level either abstracted through an\nAPI or directly . If the operating system detects a directed cycle in the operating system \ufb01le descriptor table it\nmay break one process\u2019 hold through scheduling for example and let the system proceed. Why this is a popular\nchoice in this realm is that there is no way of knowing which resources a program will select without running\nthe program. This is an extension of Rice\u2019s theorem [3]that says that we cannot know any semantic feature\nwithout running the program (semantic meaning like what \ufb01les it tries to open). So theoretically , it is sound. The", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4353, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3da0cb07-530b-485e-a8d5-26cd10e10ab6": {"__data__": {"id_": "3da0cb07-530b-485e-a8d5-26cd10e10ab6", "embedding": null, "metadata": {"page_label": "183", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "26830022-9ff3-4fb0-81b0-d4b5c9e5321d", "node_type": "4", "metadata": {"page_label": "183", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "543bd931fdf440c232939a8da3831003448409c670f0100195a1b2baa4454ab7", "class_name": "RelatedNodeInfo"}}, "text": "8.4. DINING PHILOSOPHERS 183\nproblem then gets introduced that we could reach a livelock scenario if we preempt a set of resources again and\nagain. The way around this is mostly probabilistic. The operating system chooses a random resource to break\nhold-and-wait . Now even though a user can craft a program where breaking hold and wait on each resource\nwill result in a livelock, this doesn\u2019t happen as often on machines that run programs in practice or the livelock\nthat does happen happens for a couple of cycles. These systems are good for products that need to maintain a\nnon-deadlocked state but can tolerate a small chance of livelock for a short time.\nIn addition, we have the Banker\u2019s Algorithm . Which the basic premise is the bank never runs dry , which\nprevents livelock. Feel free to check out the appendix for more details.\n8.4 Dining Philosophers\nThe Dining Philosophers problem is a classic synchronization problem. Imagine we invite n(let\u2019s say 6) philosophers\nto a meal. We will sit them at a table with 6 chopsticks, one between each philosopher. A philosopher alternates\nbetween wanting to eat or think. To eat the philosopher must pick up the two chopsticks either side of their\nposition. The original problem required each philosopher to have two forks, but one can eat with a single fork so\nwe rule this out. However, these chopsticks are shared with his neighbor.\nResources\nProcesses\nFigure 8.3: Dining Philosophers\nIs it possible to design an ef\ufb01cient solution such that all philosophers get to eat? Or, will some philosophers\nstarve, never obtaining a second chopstick? Or will all of them deadlock? For example, imagine each guest picks\nup the chopstick on their left and then waits for the chopstick on their right to be free. Oops - our philosophers have\ndeadlocked! Each philosopher is essentially the same, meaning that each philosopher has the same instruction set\nbased on the other philosopher i.e. you can\u2019t tell every even philosopher to do one thing and every odd philosopher\nto do another thing.\n8.4.1 Failed Solutions\nvoid * philosopher( void * forks) {\ninfo phil_info = forks ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2117, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "08e1120f-d6ea-4191-a07f-8ff0ef4cdbe6": {"__data__": {"id_": "08e1120f-d6ea-4191-a07f-8ff0ef4cdbe6", "embedding": null, "metadata": {"page_label": "184", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3e17fed6-e802-4f8a-bad3-1cb66691e67a", "node_type": "4", "metadata": {"page_label": "184", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4cae3abed3db71872592c376f00a799b00427b29b72d2a043ccd120bbf4d1d43", "class_name": "RelatedNodeInfo"}}, "text": "184 CHAPTER 8. DEADLOCK\npthread_mutex_t* left_fork = phil_info- >left_fork ;\npthread_mutex_t* right_fork = phil_info- >right_fork ;\nwhile (phil_info- >simulation) {\npthread_mutex_lock(left_fork) ;\npthread_mutex_lock(right_fork) ;\neat(left_fork, right_fork) ;\npthread_mutex_unlock(left_fork) ;\npthread_mutex_unlock(right_fork) ;\n}\n}\nThis looks good but. What if everyone picks up their left fork and is waiting on their right fork? We have\ndeadlocked the program. It is important to note that deadlock doesn\u2019t happen all the time and the probability\nthat this solution deadlock goes down as the number of philosophers goes up. What is important to note is that\neventually that this solution will deadlock, letting threads starve which is bad. Here is a simple resource allocation\ngraph that shows how the system could be deadlocked\nFigure 8.4: Left right dining philosopher cycle\nSo now you are thinking about breaking one of the Coffman Conditions. Let\u2019s break Hold and Wait!\nvoid * philosopher( void * forks) {\ninfo phil_info = forks ;\npthread_mutex_t* left_fork = phil_info- >left_fork ;\npthread_mutex_t* right_fork = phil_info- >right_fork ;\nwhile (phil_info- >simulation) {\nint left_succeed = pthread_mutex_trylock(left_fork) ;\nif(!left_succeed) {\nsleep() ;\ncontinue ;\n}\nint right_succeed = pthread_mutex_trylock(right_fork) ;\nif(!right_succeed) {\npthread_mutex_unlock(left_fork) ;\nsleep() ;\ncontinue ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1406, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "85a6f611-f1ee-417f-85de-a755354d345b": {"__data__": {"id_": "85a6f611-f1ee-417f-85de-a755354d345b", "embedding": null, "metadata": {"page_label": "185", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e45f51b1-2a7a-481f-8ccb-d153a9213491", "node_type": "4", "metadata": {"page_label": "185", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "39dae1653f942722aec0ceb2b5d3a3ef8c4eb9378ffd4a39f4d50b2d4fd07c3d", "class_name": "RelatedNodeInfo"}}, "text": "8.5. VIABLE SOLUTIONS 185\n}\neat(left_fork, right_fork) ;\npthread_mutex_unlock(left_fork) ;\npthread_mutex_unlock(right_fork) ;\n}\n}\nNow our philosopher picks up the left fork and tries to grab the right. If it\u2019s available, they eat. If it\u2019s not\navailable, they put the left fork down and try again. No deadlock! But, there is a problem. What if all the\nphilosophers pick up their left at the same time, try to grab their right, put their left down, pick up their left, try to\ngrab their right and so on. Here is what a time evolution of the system would look like.\nFigure 8.5: Livelock Failure\nWe have now livelocked our solution! Our poor philosophers are still starving, so let\u2019s give them some proper\nsolutions.\n8.5 Viable Solutions\nThe naive arbitrator solution has one arbitrator a mutex for example. Have each of the philosophers ask the\narbitrator for permission to eat or trylock an arbitrator mutex. This solution allows one philosopher to eat at a\ntime. When they are done, another philosopher can ask for permission to eat. This prevents deadlock because\nthere is no circular wait! No philosopher has to wait for any other philosopher. The advanced arbitrator solution\nis to implement a class that determines if the philosopher\u2019s forks are in the arbitrator\u2019s possession. If they are,\nthey give them to the philosopher, let him eat, and take the forks back. This has the bonus of being able to have\nmultiple philosophers eat at the same time.\nThere are a lot of problems with these solutions. One is that they are slow and have a single point of", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1554, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a8a43c0a-47e6-4012-821c-0114c37bfea3": {"__data__": {"id_": "a8a43c0a-47e6-4012-821c-0114c37bfea3", "embedding": null, "metadata": {"page_label": "186", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9167fb89-433d-4762-b746-a232f845d992", "node_type": "4", "metadata": {"page_label": "186", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "98819ddcf77877cd8c94da7658fb767e8562e2bef12b6fc9feff8fca12db0534", "class_name": "RelatedNodeInfo"}}, "text": "186 CHAPTER 8. DEADLOCK\nfailure. Assuming that all the philosophers are good-willed, the arbitrator needs to be fair. In practical systems,\nthe arbitrator tends to give forks to the same processes because of scheduling or pseudo-randomness. Another\nimportant thing to note is that this prevents deadlock for the entire system. But in our model of dining philosophers,\nthe philosopher has to release the lock themselves. Then, you can consider the case of the malicious philosopher\n(let\u2019s say Descartes because of his Evil Demons) could hold on to the arbitrator forever. He would make forward\nprogress and the system would make forward progress but there is no way of ensuring that each process makes\nforward progress without assuming something about the processes or having true preemption \u2013 meaning that a\nhigher authority (let\u2019s say Steve Jobs) tells them to stop eating forcibly .\nProof: The arbitrator solution doesn\u2019t deadlock\nThe proof is about as simple as it gets. Only one philosopher can request resources at a time. There is\nno way to make a cycle in the resource allocation graph with only one philosopher acting in pickup the left\nthen the right fork which is what we needed to show.\n\u25a1\nFigure 8.6: Arbitrator Diagram\n8.5.1 Leaving the Table (Stallings\u2019 Solution)\nWhy does the \ufb01rst solution deadlock? Well, there are nphilosophers and nchopsticks. What if there is only 1\nphilosopher at the table? Can we deadlock? No. How about 2 philosophers? 3? You can see where this is going.\nStallings\u2019 [5, P . 280 ]solution removes philosophers from the table until deadlock is not possible \u2013 think about what\nthe magic number of philosophers at the table. The way to do this in the actual system is through semaphores and\nletting a certain number of philosophers through. This has the bene\ufb01t that multiple philosophers can be eating.\nIn the case that the philosophers aren\u2019t evil, this solution requires a lot of time-consuming context switching.\nThere is also no reliable way to know the number of resources beforehand. In the dining philosophers case, this is\nsolved because everything is known but trying to specify an operating system where a system doesn\u2019t know which\n\ufb01le is going to get opened by what process can lead to a faulty solution. And again since semaphores are system\nconstructs, they obey system timing clocks which means that the same processes tend to get added back into\nthe queue again. Now if a philosopher becomes evil, then the problem becomes that there is no preemption. A", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2503, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "62a5874a-6ceb-43f9-b621-def05f21946c": {"__data__": {"id_": "62a5874a-6ceb-43f9-b621-def05f21946c", "embedding": null, "metadata": {"page_label": "187", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b9f290f9-4b77-48cd-9335-619aa436cb73", "node_type": "4", "metadata": {"page_label": "187", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c2cec5f004a3d0619c0f6793187ac4a584935b943c79945f81efb9e9f2374209", "class_name": "RelatedNodeInfo"}}, "text": "8.5. VIABLE SOLUTIONS 187\nphilosopher can eat for as long as they want and the system will continue to function but that means the fairness\nof this solution can be low in the worst case. This works best with timeouts or forced context switches to ensure\nbounded wait times.\nProof: Stallings\u2019 Solution Doesn\u2019t Deadlock. Let\u2019s number the philosophers {p0,p1, ..,pn\u22121}and the\nresources{r0,r1, ..,rn\u22121}. A philosopher pineeds resource ri\u22121 mod nandri+1 mod n. Without loss of generality ,\nlet us take piout of the picture. Each resource had exactly two philosophers that could use it. Now resources\nri\u22121 mod nand ri+1 mod nonly have on philosopher waiting on it. Even if hold and wait, no preemption, and\nmutual exclusion or present, the resources can never enter a state where one philosopher requests them\nand they are held by another philosopher because only one philosopher can request them. Since there is no\nway to generate a cycle otherwise, circular wait cannot hold. Since circular wait cannot hold, deadlock\ncannot happen. \u25a1\nHere is a visualization of the worst-case. The system is about to deadlock, but the approach resolves it.\nFigure 8.7: Stalling solution almost deadlock\n8.5.2 Partial Ordering (Dijkstra\u2019s Solution)\nThis is Dijkstra\u2019s solution [2, P . 20 ]. He was the one to propose this problem on an exam. Why does the \ufb01rst\nsolution deadlock? Dijkstra thought that the last philosopher who picks up his left fork (causing the solution to\ndeadlock) should pick up his right. He accomplishes it by number the forks 1 ..n, and tells each of the philosophers\nto pick up his lower number fork. Let\u2019s run through the deadlock condition again. Everyone tries to pick up their\nlower number fork \ufb01rst. Philosopher 1 gets fork 1, Philosopher 2 gets fork 2, and so on until we get to Philosopher\nn. They have to choose between fork 1 and n. fork 1 is already held up by philosopher 1, so they can\u2019t pick up\nthat fork, meaning he won\u2019t pick up fork n. We have broken circular wait ! Meaning deadlock isn\u2019t possible.\nSome problems are that an entity either needs to know the \ufb01nite set of resources in advance or be able to\nproduce a consistent partial order such that circular wait cannot happen. This also implies that there needs to be\nsome entity , either the operating system or another process, deciding on the number and all of the philosophers\nneed to agree on the number as new resources come in. As we have also seen with previous solutions, this relies\non context switching. This prioritizes philosophers that have already eaten but can be made fairer by introducing\nrandom sleeps and waits.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2603, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "11deeedb-f29f-40f1-9531-f6c19befbbf1": {"__data__": {"id_": "11deeedb-f29f-40f1-9531-f6c19befbbf1", "embedding": null, "metadata": {"page_label": "188", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ccafac37-112b-4763-ae18-85c43f5567c5", "node_type": "4", "metadata": {"page_label": "188", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b825e31f0b587e9766a28108bda83fd0a90a1756f8fb2c68b5b9aa8ea90d54cf", "class_name": "RelatedNodeInfo"}}, "text": "188 CHAPTER 8. DEADLOCK\nProof: Dijkstra\u2019s Solution Doesn\u2019t Deadlock\nThe proof is similar to the previous proof. Let\u2019s number the philosophers {p0,p1, ..,pn\u22121}and the\nresources{r0,r1, ..,rn\u22121}. A philosopher pineeds resource ri\u22121 mod nand ri+1 mod n. Each philosopher will\ngrab ri\u22121 mod nthen ri+1 mod nbut the last philosopher will grab in the reverse order. Even if hold and wait,\nno preemption, and mutual exclusion or present. Since the last philosopher will grab rn\u22121then r0there are\ntwo cases either the philosopher has the \ufb01rst lock or the philosopher doesn\u2019t.\nIf the last philosopher pn\u22121holds the \ufb01rst lock meaning the previous philosopher pn\u22122is waiting on rn\u22121\nmeaning rn\u22122is available. Since no other blockers, the philosopher previous pn\u22123will grab her \ufb01rst lock.\nThis is now a reduction to the previous proof of stalling because we now have nresources but only n\u22121\nphilosophers, meaning this cannot deadlock.\nIf the philosopher doesn\u2019t obtain that \ufb01rst lock, then we have a reduction to Stalling\u2019s proof above\nbecause now have n\u22121 philosophers vying for nresources. Since we can\u2019t reach deadlock in either case,\nthis solution cannot deadlock which is what we needed to show.\n\u25a1\nFigure 8.8: Stalling solution partial deadlock\nThere are a few other solutions (clean /dirty forks and the actor model) in the appendix.\n8.6 Topics\n\u2022Coffman Conditions\n\u2022Resource Allocation Graphs\n\u2022Dining Philosophers\n\u2022Failed DP Solutions\n\u2022Livelocking DP Solutions\n\u2022Working DP Solutions: Bene\ufb01ts /Drawbacks\n\u2022Ron Swanson Deadlock", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1517, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cc00db61-2db4-427b-8e61-92d5b584569b": {"__data__": {"id_": "cc00db61-2db4-427b-8e61-92d5b584569b", "embedding": null, "metadata": {"page_label": "189", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6aa6ddc9-85ac-44b3-a5dc-b737e01d9b70", "node_type": "4", "metadata": {"page_label": "189", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "782ff055b2560afd1c0815546d95ea4cea4b5dca36866c2d9b3e67604d3f3dfc", "class_name": "RelatedNodeInfo"}}, "text": "8.7. QUESTIONS 189\n8.7 Questions\n\u2022What are the Coffman conditions?\n\u2022What does each of the Coffman conditions mean? De\ufb01ne each one.\n\u2022Give a real-life example of breaking each Coffman condition in turn. A situation to consider: Painters, Paint,\nPaint Brushes etc. How would you assure that work would get done?\n\u2022Which Coffman condition is unsatis\ufb01ed in the following snippet?\n//Get both locks ornone\npthread_mutex_lock(a) ;\nif(pthread_mutex_trylock( b )) {/*failure */\npthread_mutex_unlock( a ) ;\n}\n\u2022The following calls are made\n//Thread 1\npthread_mutex_lock(m1) //success\npthread_mutex_lock(m2) //blocks\n//Thread 2\npthread_mutex_lock(m2) //success\npthread_mutex_lock(m1) //blocks\nWhat happens and why? What happens if a third thread calls pthread_mutex_lock(m1) ?\n\u2022How many processes are blocked? As usual, assume that a process can complete if it can acquire all of the\nresources listed below.\n\u2013P1 acquires R1\n\u2013P2 acquires R2\n\u2013P1 acquires R3\n\u2013P2 waits for R3\n\u2013P3 acquires R5\n\u2013P1 waits for R4\n\u2013P3 waits for R1\n\u2013P4 waits for R5\n\u2013P5 waits for R1\nDraw out the resource graph!", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1071, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9c16a282-639e-4e96-b176-a17801c93a63": {"__data__": {"id_": "9c16a282-639e-4e96-b176-a17801c93a63", "embedding": null, "metadata": {"page_label": "190", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "14239045-30eb-4dd9-91fb-11aab4a3ef27", "node_type": "4", "metadata": {"page_label": "190", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9e08b541712e49951970aa6a5f86c8a7237fbc1e98c817b330eadf7b0a0a558a", "class_name": "RelatedNodeInfo"}}, "text": "190 CHAPTER 8. DEADLOCK\nBibliography\n[1]Edward G Coffman, Melanie Elphick, and Arie Shoshani. System deadlocks. ACM Computing Surveys (CSUR) ,\n3(2):67\u201378, 1971.\n[2]Edsger W . Dijkstra. Hierarchical ordering of sequential processes. published as [?]WD:EWD310pub, n.d.\nURL http://www.cs.utexas.edu/users/EWD/ewd03xx/EWD310.PDF .\n[3]H. G. Rice. Classes of recursively enumerable sets and their decision problems. Transactions of the American\nMathematical Society , 74(2):358\u2013366, 1953. ISSN 00029947. URL http://www.jstor.org/stable/\n1990888 .\n[4]A. Silberschatz, P .B. Galvin, and G. Gagne. OPERATING SYSTEM PRINCIPLES, 7TH ED . Wiley student edition.\nWiley India Pvt. Limited, 2006. ISBN 9788126509621. URL https://books.google.com/books?id=\nWjvX0HmVTlMC .\n[5]William Stallings. Operating Systems: Internals and Design Principles 7th Ed. by Stallings (Inter-\nnational Economy Edition) . PE, 2011. ISBN 9332518807. URL https://www.amazon.com/\nOperating-Systems-Internals-Principles-International/dp/9332518807?SubscriptionId=\n0JYN1NVW651KCA56C102&tag=techkie-20&linkCode=xm2&camp=2025&creative=165953&\ncreativeASIN=9332518807 .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1125, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6081f2ff-0462-4966-94f1-df044ebbc5e3": {"__data__": {"id_": "6081f2ff-0462-4966-94f1-df044ebbc5e3", "embedding": null, "metadata": {"page_label": "257", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4608da6f-0ad0-4231-b0cd-ece358a687a7", "node_type": "4", "metadata": {"page_label": "257", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "39c5b21e1a84ef2032c510098fabeb7cf051d700949b3bb6394269ee9d695d3e", "class_name": "RelatedNodeInfo"}}, "text": "12\nFilesystems\n/home is where the heart is\nFilesystems are important because they allow you to persist data after a computer is shut down, crashes, or has\nmemory corruption. Back in the day , \ufb01lesystems were expensive to use. Writing to the \ufb01lesystem (FS) involved\nwriting to magnetic tape and reading from that tape [1]. It was slow, heavy, and prone to errors.\nNowadays most of our \ufb01les are stored on disk \u2013 though not all of them! The disk is still slower than memory\nby an order of magnitude at the least.\nSome terminology before we begin this chapter. A \ufb01lesystem , as we\u2019ll de\ufb01ne more concretely later, is anything\nthat satis\ufb01es the API of a \ufb01lesystem. A \ufb01lesystem is backed by a storage medium, such as a hard disk drive, solid\nstate drive, RAM, etc. A disk is either a hard disk drive (HDD) which includes a spinning metallic platter and\na head which can zap the platter to encode a 1 or a 0, or a solid-state drive (SSD) that can \ufb02ip certain\nNAND gates on a chip or standalone drive to store a 1 or a 0. As of 2019, SSDs are an order of magnitude\nfaster than the standard HDD. These are typical backings for a \ufb01lesystem. A \ufb01lesystem is implemented on top\nof this backing, meaning that we can either implement something like EXT , MinixFS, NTFS, FAT32, etc. on a\ncommercially available hard disk. This \ufb01lesystem tells the operating system how to organize the 1s and 0s to store\n\ufb01le information as well as directory information, but more on that later. To avoid being pedantic, we\u2019ll say that a\n\ufb01lesystem like EXT or NTFS implements the \ufb01lesystem API directly (open, close, etc). Often, operating systems will\nadd a layer of abstraction and require that the operating system satisfy its API instead (think imaginary functions\nlinux_open, linux_close etc). The two bene\ufb01ts are that one \ufb01lesystem can be implemented for multiple operating\nsystem APIs and adding a new OS \ufb01lesystem call doesn\u2019t require all of the underlying \ufb01le systems to change their\nAPI. For example, in the next iteration of linux if there was a new system call to create a backup of a \ufb01le, the OS\ncan implement that with the internal API rather than requiring all \ufb01lesystem drivers to change their code.\nThe last piece of background is an important one. In this chapter, we will refer to sizes of \ufb01les in the\nISO-compliant KiB or Kibibyte. The *iB family is short for power of two storage. That means the following:\nTable 12.1: Kibibyte Values\nPre\ufb01x Byte Value\nKiB 1024B\nMiB 1024 * 1024 B\nGiB 1024 \u02c63 B\n257", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2482, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "677abf42-8c04-43a2-a067-b91398340fbf": {"__data__": {"id_": "677abf42-8c04-43a2-a067-b91398340fbf", "embedding": null, "metadata": {"page_label": "258", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "39fb1508-64b5-4849-acaf-f6ce430c6596", "node_type": "4", "metadata": {"page_label": "258", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4ab278889aa6acbc66a4536648dd0455fbae83fd6be5d5d8910e47f23202da03", "class_name": "RelatedNodeInfo"}}, "text": "258 CHAPTER 12. FILESYSTEMS\nThe standard notational pre\ufb01xes mean the following:\nTable 12.2: Kilobyte Values\nPre\ufb01x Byte Value\nKB 1000B\nMB 1000 * 1000 B\nGB 1000 \u02c63 B\nWe will do this in the book and in the Networking chapter for the sake of consistency and to not confuse\nanyone. Confusingly in the real world, there is a different convention. That convention is that when a \ufb01le is\ndisplayed in the operating system, KB is the same as KiB . When we are talking about computer networks, CDs,\nother storage KB is not the same as KiB and is the ISO /Metric De\ufb01nition above. This is a historical quirk was\nbrought by a clash between network developers and memory /hard storage developers. Hard storage and memory\ndevelopers found that if a bit could take one of two states, it would be natural to call a Kilo- pre\ufb01x 1024 because it\nwas about 1000. Network developers had to deal with bits, real-time signal processing, and various other factors,\nso they went with the already accepted convention that Kilo- means 1000 of something [1]. What you need to\nknow is if you see KB in the wild, that it may be 1024 based on the context. If any time in this class you see KB or\nany of the family refer to a \ufb01lesystems question, you can safely infer that they are referring to 1024 as the base\nunit. Though when you are pushing production code, make sure to ask about the difference!\n12.1 What is a \ufb01lesystem?\nYou may have encountered the old UNIX adage, \"everything is a \ufb01le\". In most UNIX systems, \ufb01le operations\nprovide an interface to abstract many different operations. Network sockets, hardware devices, and data on the\ndisk are all represented by \ufb01le-like objects. A \ufb01le-like object must follow the following conventions:\n1.It must present itself to the \ufb01lesystem.\n2.It must support common \ufb01lesystem operations, such as open ,read ,write . At a minimum, it needs to be\nopened and closed.\nA \ufb01lesystem is an implementation of the \ufb01le interface. In this chapter, we will be exploring the various callbacks\na \ufb01lesystem provides, some typical functionality and associated implementation details. In this class, we will\nmostly talk about \ufb01lesystems that serve to allow users to access data on disk, which are integral to modern\ncomputers.\nHere are some common features of a \ufb01lesystem:\n1.They deal with both storing local \ufb01les and handle special devices that allow for safe communication between\nthe kernel and user space.\n2.They deal with failures, scalability , indexing, encryption, compression, and performance.\n3.They handle the abstraction between a \ufb01le that contains data and how exactly that data is stored on disk,\npartitioned, and protected.\nBefore we dive into the details of a \ufb01lesystem, let\u2019s take a look at some examples. To clarify , a mount point is\nsimply a mapping of a directory to a \ufb01lesystem represented in the kernel.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2823, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "517b13be-a40b-463d-b372-beafafc4785b": {"__data__": {"id_": "517b13be-a40b-463d-b372-beafafc4785b", "embedding": null, "metadata": {"page_label": "259", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "87d52158-91ec-4e54-973d-dc499b24f210", "node_type": "4", "metadata": {"page_label": "259", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "89e9a43c5f6b2e7e55b9cbc5426119ebb5581bd7ce9d0a635c1d122fb7f5d71d", "class_name": "RelatedNodeInfo"}}, "text": "12.2. STORING DATA ON DISK 259\n1.ext4 Usually mounted at /on Linux systems, this is the \ufb01lesystem that usually provides disk access as you\u2019re\nused to.\n2.procfs Usually mounted at /proc, provides information and control over processes.\n3.sysfs Usually mounted at /sys, a more modern version of /proc that also allows control over various other\nhardware such as network sockets.\n4.tmpfs Mounted at /tmp in some systems, an in-memory \ufb01lesystem to hold temporary \ufb01les.\n5.sshfs This syncs \ufb01les across the sshprotocol.\nIt tells you what \ufb01lesystem directory-based system calls resolve to. For example, /is resolved by the ext4\n\ufb01lesystem in our case, but /proc/2 is resolved by the procfs system even though it contains /as a subsystem.\nAs you may have noticed, some \ufb01lesystems provide an interface to things that aren\u2019t \"\ufb01les\". Filesystems such\nasprocfs are usually referred to as virtual \ufb01lesystems, since they don\u2019t provide data access in the same sense as a\ntraditional \ufb01lesystem would. Technically , all \ufb01lesystems in the kernel are represented by virtual \ufb01lesystems, but\nwe will differentiate virtual \ufb01lesystems as \ufb01lesystems that actually don\u2019t store anything on a hard disk.\n12.1.1 The File API\nA \ufb01lesystem must provide callback functions to a variety of actions. Some of them are listed below:\n\u2022open Opens a \ufb01le for IO\n\u2022read Read contents of a \ufb01le\n\u2022write Write to a \ufb01le\n\u2022close Close a \ufb01le and free associated resources\n\u2022chmod Modify permissions of a \ufb01le\n\u2022ioctl Interact with device parameters of character devices such as terminals\nNot every \ufb01lesystem supports all the possible callback functions. For example, many \ufb01lesystems omit ioctl\norlink . Many \ufb01lesystems aren\u2019t seekable meaning that they exclusively provide sequential access. A program\ncannot move to an arbitrary point in the \ufb01le. This is analogous to seekable stream s. In this chapter, we will not\nbe examining each \ufb01lesystem callback. If you would like to learn more about this interface, try looking at the\ndocumentation for Filesystems at the User Space Level (FUSE).\n12.2 Storing data on disk\nTo understand how a \ufb01lesystem interacts with data on disk, there are three key terms we will be using.\n1.disk block A disk block is a portion of the disk that is reserved for storing the contents of a \ufb01le or a\ndirectory .\n2.inode An inode isa \ufb01le or directory . This means that an inode contains metadata about the \ufb01le as well as\npointers to disk blocks so that the \ufb01le can actually be written to or read from.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2471, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2cee24e0-f557-49f0-8e0d-222488c4d97f": {"__data__": {"id_": "2cee24e0-f557-49f0-8e0d-222488c4d97f", "embedding": null, "metadata": {"page_label": "260", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bafc3091-f305-47af-b0ba-b563498e9bd6", "node_type": "4", "metadata": {"page_label": "260", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "cfbba4a6a6c31b838bf85a1482172061a1578c5168de41c455d35e8709183fee", "class_name": "RelatedNodeInfo"}}, "text": "260 CHAPTER 12. FILESYSTEMS\n3.superblock A superblock contains metadata about the inodes and disk blocks. An example superblock\ncan store how full each disk block is, which inodes are being used etc. Modern \ufb01lesystems may actually\ncontain multiple superblocks and a sort-of super-super block that keeps track of which sectors are governed\nby which superblocks. This tends to help with fragmentation.\nIt may seem overwhelming, but by the end of this chapter, we will be able to make sense of every part of the\n\ufb01lesystem.\nTo reason about data on some form of storage \u2013 spinning disks, solid state drives, magnetic tape \u2013 it is common\npractice to \ufb01rst consider the medium of storage as a collection of blocks . A block can be thought of as a contiguous\nregion on disk. While its size is sometimes determined by some property of the underlying hardware, it is more\nfrequently determined based on the size of a page of memory for a given system, so that data from the disk can be\ncached in memory for faster access \u2013 a important feature of many \ufb01lesystems.\nA \ufb01lesystem has a special block denoted as a superblock that stores metadata about the \ufb01lesystem such as a\njournal (which logs changes to the \ufb01lesystem), a table of inodes, the location of the \ufb01rst inode on disk, etc. The\nimportant thing about a superblock is that it is in a known location on disk. If not, your computer may fail to\nboot! Consider a simple ROM programmed into your motherboard. If your processor can\u2019t tell the motherboard\nto start reading and decipher a disk block to start the boot sequence, you are out of luck.\nThe inode is the most important structure for our \ufb01lesystem as it represents a \ufb01le. Before we explore it in-depth,\nlet\u2019s list out the key information we need to have a usable \ufb01le.\n\u2022Name\n\u2022File size\n\u2022Time created, last modi\ufb01ed, last accessed\n\u2022Permissions\n\u2022Filepath\n\u2022Checksum\n\u2022File data\n12.2.1 File Contents\nFrom Wikipedia:\nIn a Unix-style \ufb01le system, an index node, informally referred to as an inode, is a data structure used to\nrepresent a \ufb01lesystem object, which can be various things including a \ufb01le or a directory. Each inode stores\nthe attributes and disk block location(s) of the \ufb01lesystem object\u2019s data. Filesystem object attributes may\ninclude manipulation metadata (e.g. change, access, modify time), as well as owner and permission data\n(e.g. group-id, user-id, permissions).\nThe superblock may store an array of inodes, each of which stores direct, and potentially several kinds of\nindirect pointers to disk blocks. Since inodes are stored in the superblock, most \ufb01lesystems have a limit on\nhow many inodes can exist. Since each inode corresponds to a \ufb01le, this is also a limit on how many \ufb01les that\n\ufb01lesystem can have. Trying to overcome this problem by storing inodes in some other location greatly increases\nthe complexity of the \ufb01lesystem. Trying to reallocate space for the inode table is also infeasible since every byte\nfollowing the end of the inode array would have to be shifted, a highly expensive operation. This isn\u2019t to say there\naren\u2019t any solutions at all, although typically there is no need to increase the number of inodes since the number\nof inodes is usually suf\ufb01ciently high.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3192, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3f65437e-847d-418f-b885-985f2f79e4ca": {"__data__": {"id_": "3f65437e-847d-418f-b885-985f2f79e4ca", "embedding": null, "metadata": {"page_label": "261", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "efc2fe1b-45fd-4c10-be41-7bf03b69e1c1", "node_type": "4", "metadata": {"page_label": "261", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "2b932ac2c4a9bac3fcc8455d9141a59b30e112fab2d00cb9423457b82babd195", "class_name": "RelatedNodeInfo"}}, "text": "12.2. STORING DATA ON DISK 261\nBig idea: Forget names of \ufb01les. The \u2018inode\u2019 is the \ufb01le.\nIt is common to think of the \ufb01le name as the \u2018actual\u2019 \ufb01le. It\u2019s not! Instead, consider the inode as the \ufb01le. The\ninode holds the meta-information (last accessed, ownership, size) and points to the disk blocks used to hold\nthe \ufb01le contents. However, the inode does not usually store a \ufb01lename. Filenames are usually only stored in\ndirectories (see below).\nFor example, to read the \ufb01rst few bytes of the \ufb01le, follow the \ufb01rst direct block pointer to the \ufb01rst direct block\nand read the \ufb01rst few bytes. Writing follows the same process. If a program wants to read the entire \ufb01le, keep\nreading direct blocks until you\u2019ve read several bytes equal to the size of the \ufb01le. If the total size of the \ufb01le is less\nthan that of the number of direct blocks multiplied by the size of a block, then unused block pointers will be\nunde\ufb01ned. Similarly , if the size of a \ufb01le is not a multiple of the size of a block, data past the end of the last byte in\nthe last block will be garbage.\nWhat if a \ufb01le is bigger than the maximum space addressable by its direct blocks? To that, we present a motto\nprogrammers take too seriously.\n\u201cAll problems in computer science can be solved by another level of indirection.\u201d - David Wheeler\nExcept for the problem of too many layers of indirection.\nTo solve this problem, we introduce indirect blocks . A single indirect block is a block that stores pointers\nto more data blocks. Similarly , a double indirect block stores pointers to single indirect blocks, and the concept\ncan be generalized to arbitrary levels of indirection. This is a important concept, as inodes are stored in the\nsuperblock, or some other structure in a well known location with a constant amount of space, indirection allows\nexponential increases in the amount of space an inode can keep track of.\nAs a worked example, suppose we divide the disk into 4KiB blocks and we want to address up to 232blocks.\nThe maximum disk size is 4 KiB\u2217232=16T iBremember 210=1024. A disk block can store4KiB\n4Bpossible pointers\nor 1024 pointers. Four byte wide pointers are needed because we want to address 32 bits worth of blocks. Each\npointer refers to a 4KiB disk block, so you can refer up to 1024 \u22174KiB=4M iB of data. For the same disk\ncon\ufb01guration, a double indirect block stores 1024 pointers to 1024 indirection tables. Thus a double-indirect block\ncan refer up to 1024 \u22174M iB =4GiB of data. Similarly , a triple indirect block can refer up to 4TiB of data. This\nis three times as slow for reading between blocks, due to increased levels of indirection. The actual intra-block\nreading times don\u2019t change.\n12.2.2 Directory Implementation\nA directory is a mapping of names to inode numbers. It is typically a normal \ufb01le, but with some special bits set in\nits inode and a speci\ufb01c structure for its contents. POSIX provides a small set of functions to read the \ufb01lename and\ninode number for each entry, which we will talk about in depth later in this chapter.\nLet\u2019s think about what directories looks like in the actual \ufb01le system. Theoretically, they are \ufb01les. The disk\nblocks will contain directory entries ordirents . What that means is that our disk block can look like this\n| inode_num | name | | ----------- | ------ |\n| 2043567 | hi.txt | | ... |\nEach directory entry could either be a \ufb01xed size, or a variable length C-string. It depends on how the particular\n\ufb01lesystem implements it at the lower level. To see a mapping of \ufb01lenames to inode numbers on a POSIX system,\nfrom a shell, use lswith the -ioption\n#ls-i\n12983989 dirlist.c 12984068 sandwich.c", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3622, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c6e9c89-adf4-44b5-ab4e-9932ccc80279": {"__data__": {"id_": "7c6e9c89-adf4-44b5-ab4e-9932ccc80279", "embedding": null, "metadata": {"page_label": "262", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3346a9d4-3cfa-40ed-8052-4befab2915e3", "node_type": "4", "metadata": {"page_label": "262", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e15e32899a2247724f269b6d9ac1ae1bc625f0b40a834a9c7c64199c88c01768", "class_name": "RelatedNodeInfo"}}, "text": "262 CHAPTER 12. FILESYSTEMS\nYou can see later that this is a powerful abstraction. One can have a \ufb01le be multiple different names in a\ndirectory , or exist in multiple directories.\n12.2.3 UNIX Directory Conventions\nIn standard UNIX \ufb01lesystems, the following entries are specially added on requests to read a directory.\n1..represents the current directory\n2...represents the parent directory\nCounterintuitively , ...could be the name of a \ufb01le or directory on disk (You can try this with mkdir ... ),\nnot the grandparent directory . Only the current directory and the parent directory have special aliases involving\n.(namely , .and..). Confusingly, the shell zshdoes interpret ...as a handy shortcut to the grandparent\ndirectory (should it exist) while expanding shell commands.\nAdditional facts about name-related conventions:\n1.~is usually expanded to the home directory by the shell\n2.Files that start with \u2019.\u2019 (a period) on disk are conventionally considered \u2019hidden\u2019 and will be omitted by\nprograms like lswithout additional \ufb02ags ( -a). This is not a feature of the \ufb01lesystem, and programs may\nchoose to ignore this.\n3.Some \ufb01les may also start with a NUL byte. These are usually abstract UNIX sockets and are used to prevent\ncluttering up the \ufb01lesystem since they will be effectively hidden by any unexpecting program. They will,\nhowever, be listed by tools that detail information about sockets, so this is not a feature providing security .\n4.If you want to annoy your neighbor, create a \ufb01le with the terminal bell character. Every single time the \ufb01le\nis listed (by calling \u2018ls\u2019, for example), an audible bell will be heard.\n12.2.4 Directory API\nWhile interacting with a \ufb01le in C is typically done by using open to open the \ufb01le and then read orwrite to\ninteract with the \ufb01le before calling close to release resources, directories have special calls such as, opendir ,\nclosedir andreaddir . There is no function writedir since typically that implies creating a \ufb01le or link. The\nprogram would use something like open ormkdir .\nTo explore these functions, let\u2019s write a program to search the contents of a directory for a particular \ufb01le. The\ncode below has a bug, try to spot it!\nint exists( char *directory, char *name) {\nstruct dirent *dp ;\nDIR *dirp = opendir(directory) ;\nwhile ((dp = readdir(dirp)) != NULL) {\nputs(dp- >d_name) ;\nif(!strcmp(dp- >d_name, name)) {\nreturn 1;/*Found */\n}\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2393, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9ce697af-9d98-4b9a-a043-c0f6adaf317d": {"__data__": {"id_": "9ce697af-9d98-4b9a-a043-c0f6adaf317d", "embedding": null, "metadata": {"page_label": "263", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e540e024-a838-4dd0-ad68-5a7d5e927088", "node_type": "4", "metadata": {"page_label": "263", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "37fe8304b79e07808ec452e7baa8e6c1dfac00a039641de8c024c0f0b5aa2cfd", "class_name": "RelatedNodeInfo"}}, "text": "12.2. STORING DATA ON DISK 263\nclosedir(dirp) ;\nreturn 0;/*Not Found */\n}\nDid you \ufb01nd the bug? It leaks resources! If a matching \ufb01lename is found then \u2018closedir\u2019 is never called as part\nof the early return. Any \ufb01le descriptors opened and any memory allocated by opendir are never released. This\nmeans eventually the process will run out of resources and an open oropendir call will fail.\nThe \ufb01x is to ensure we free up resources in every possible code path.\nIn the above code, this means calling closedir before return 1 . Forgetting to release resources is a common\nC programming bug because there is no support in the C language to ensure resources are always released with\nall code paths.\nGiven an open directory, after a call to fork() , either (XOR), the parent or the child can use readdir() ,\nrewinddir() orseekdir() . If both the parent and the child use the above, the behavior is unde\ufb01ned.\nThere are two main gotchas and one consideration. The readdir function returns \u201c.\u201d (current directory) and\n\u201c..\u201d (parent directory). The other is programs need to explicity exclude subdirectories from a search, otherwise\nthe search may take a long time.\nFor many applications, it\u2019s reasonable to check the current directory \ufb01rst before recursively searching sub-\ndirectories. This can be achieved by storing the results in a linked list, or resetting the directory struct to restart\nfrom the beginning.\nThe following code attempts to list all \ufb01les in a directory recursively . As an exercise, try to identify the bugs it\nintroduces.\nvoid dirlist( char *path) {\nstruct dirent *dp ;\nDIR *dirp = opendir(path) ;\nwhile ((dp = readdir(dirp)) != NULL) {\nchar newpath[strlen(path) + strlen(dp- >d_name) + 1] ;\nsprintf(newpath, \"%s/%s\", newpath, dp- >d_name) ;\nprintf( \"%s\\n\", dp- >d_name) ;\ndirlist(newpath) ;\n}\n}\nint main( int argc, char **argv) {\ndirlist(argv[1]) ;\nreturn 0;\n}\nDid you \ufb01nd all 5 bugs?\n//Check opendir result (perhaps user gave usapath that can not be\nopened asadirectory\nif(!dirp) {perror( \"Could not open directory \");return ;}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2039, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3bca96f8-8999-4b64-b966-d601cbf71c2a": {"__data__": {"id_": "3bca96f8-8999-4b64-b966-d601cbf71c2a", "embedding": null, "metadata": {"page_label": "264", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2b553800-957d-4f68-94d7-bca9a054fdd0", "node_type": "4", "metadata": {"page_label": "264", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "88f6667ff26add92c3f2d60f6112c33a4fdbf9164c46fc4f00ef443461e93ba3", "class_name": "RelatedNodeInfo"}}, "text": "264 CHAPTER 12. FILESYSTEMS\n//+2asweneed space for the /and the terminating 0\nchar newpath[strlen(path) + strlen(dp- >d_name) + 2] ;\n//Correct parameter\nsprintf(newpath, \"%s/%s\", path, dp- >d_name) ;\n//Perform stat test (and verify )before recursing\nif(0 == stat(newpath,&s) && S_ISDIR(s.st_mode)) dirlist(newpath)\n//Resource leak :the directory file handle isnot closed after the\nwhile loop\nclosedir(dirp) ;\nOne \ufb01nal note of caution. readdir is not thread-safe! You shouldn\u2019t use the re-entrant version of the function.\nSynchronizing the \ufb01lesystem within a process is important, so use locks around readdir .\nSee the man page of readdir for more details.\n12.2.5 Linking\nLinks are what force us to model a \ufb01lesystem as a graph rather than a tree.\nWhile modeling the \ufb01lesystem as a tree would imply that every inode has a unique parent directory, links\nallow inodes to present themselves as \ufb01les in multiple places, potentially with different names, thus leading to an\ninode having multiple parent directories. There are two kinds of links:\n1.Hard Links A hard link is simply an entry in a directory assigning some name to an inode number that\nalready has a different name and mapping in either the same directory or a different one. If we already\nhave a \ufb01le on a \ufb01le system we can create another link to the same inode using the \u2018ln\u2019 command:\n$ ln file1.txt blip.txt\nHowever, blip.txt isthe same \ufb01le. If we edit blip, I\u2019m editing the same \ufb01le as \u2018\ufb01le1.txt!\u2019. We can prove this by\nshowing that both \ufb01le names refer to the same inode.\n$ ls -i file1.txt blip.txt\n134235 file1.txt\n134235 blip.txt\nThe equivalent C call is link\n//Function Prototype\nint link( const char *path1, const char *path2) ;\nlink( \"file1 .txt\",\"blip .txt\");", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1726, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9b3d6fc4-bc67-4a19-902e-056eb533ea4b": {"__data__": {"id_": "9b3d6fc4-bc67-4a19-902e-056eb533ea4b", "embedding": null, "metadata": {"page_label": "265", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7f401720-59ec-4d44-8364-f6df8a5c8649", "node_type": "4", "metadata": {"page_label": "265", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b5ea873716757a4c775a695372fc39f10fbc5edc0f5f33dfb6978462771ec493", "class_name": "RelatedNodeInfo"}}, "text": "12.2. STORING DATA ON DISK 265\nFor simplicity, the above examples made hard links inside the same directory . Hard links can be created\nanywhere inside the same \ufb01lesystem.\n2.Soft Links The second kind of link is called a soft link, symbolic link, or symlink. A symbolic link is\ndifferent because it is a \ufb01le with a special bit set and stores a path to another \ufb01le. Quite simply , without the\nspecial bit, it is nothing more than a text \ufb01le with a \ufb01le path inside. Note when people generally talk about\na link without specifying hard or soft, they are referring to a hard link.\nTo create a symbolic link in the shell, use ln -s . To read the contents of the link as a \ufb01le, use readlink .\nThese are both demonstrated below.\n$ ln -s file1.txt file2.txt\n$ ls -i file1.txt blip.txt\n134235 file1.txt\n134236 file2.txt\n134235 blip.txt\n$ cat file1.txt\nfile1!\n$ cat file2.txt\nfile1!\n$ cat blip.txt\nfile1!\n$ echo edited file2 >> file2.txt # >> is bash syntax for append to file\n$ cat file1.txt\nfile1!\nedited file2\n$ cat file2.txt\nI\u2019m file1!\nedited file2\n$ cat blip.txt\nfile1!\nedited file2\n$ readlink myfile.txt\nfile2.txt\nNote that file2.txt andfile1.txt have different inode numbers, unlike the hard link, blip.txt .\nThere is a C library call to create symlinks which is similar to link.\nsymlink( const char *target, const char *symlink) ;\nSome advantages of symbolic links are\n\u2022Can refer to \ufb01les that don\u2019t exist yet\n\u2022Unlike hard links, can refer to directories as well as regular \ufb01les\n\u2022Can refer to \ufb01les (and directories) that exist outside of the current \ufb01le system", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1557, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b11b705e-67e0-4446-b138-32a7d1874a21": {"__data__": {"id_": "b11b705e-67e0-4446-b138-32a7d1874a21", "embedding": null, "metadata": {"page_label": "266", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "15d15e79-4fe0-4306-b06d-f32c3bb1ae3e", "node_type": "4", "metadata": {"page_label": "266", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a33d2e2aa116bb4bd2c6427f63470716c8323c43aff2043fe2f39c9972879148", "class_name": "RelatedNodeInfo"}}, "text": "266 CHAPTER 12. FILESYSTEMS\nHowever, symlinks have a key disadvantage, they as slower than regular \ufb01les and directories. When the\nlink\u2019s contents are read, they must be interpreted as a new path to the target \ufb01le, resulting in an additional\ncall to open and read since the real \ufb01le must be opened and read. Another disadvantage is that POSIX\nforbids hard linking directories where as soft links are allowed. The lncommand will only allow root to do\nthis and only if you provide the -doption. However, even root may not be able to perform this because\nmost \ufb01lesystems prevent it!\nThe integrity of the \ufb01le system assumes the directory structure is an acyclic tree that is reachable from the root\ndirectory . It becomes expensive to enforce or verify this constraint if directory linking is allowed. Breaking these\nassumptions can leave \ufb01le integrity tools unable to repair the \ufb01le system. Recursive searches potentially never\nterminate and directories can have more than one parent but \u201c..\u201d can only refer to a single parent. All in all, a bad\nidea. Soft links are merely ignored, which is why we can use them to reference directories.\nWhen you remove a \ufb01le using rmorunlink , you are removing an inode reference from a directory . However,\nthe inode may still be referenced from other directories. To determine if the contents of the \ufb01le are still required,\neach inode keeps a reference count that is updated whenever a new link is created or destroyed. This count only\ntracks hard links, symlinks are allowed to refer to a non-existent \ufb01le and thus, do not matter.\nAn example use of hard links is to ef\ufb01ciently create multiple archives of a \ufb01le system at different points in time.\nOnce the archive area has a copy of a particular \ufb01le, then future archives can re-use these archive \ufb01les rather than\ncreating a duplicate \ufb01le. This is called an incremental backup. Apple\u2019s \u201cTime Machine\u201d software does this.\n12.2.6 Pathing\nNow that we have de\ufb01nitions, and have talked about directories, we come across the concept of a path. A path is\na sequence of directories that provide one with a \"path\" in the graph that is a \ufb01lesystem. However, there are some\nnuances. It is possible to have a path called a/b/../c/./ . Since ..and.are special entries in directories, this is\na valid path that actually refers to a/c. Most \ufb01lesystem functions will allow uncompressed paths to be passed in.\nThe C library provides a function realpath to compress the path or get the absolute path. To simplify by hand,\nremember that ..means \u2018parent folder\u2019 and that .means \u2018current folder\u2019. Below is an example that illustrates the\nsimpli\ufb01cation of the a/b/../c/. by using cdin a shell to navigate a \ufb01lesystem.\n1.cd a (in a)\n2.cd b (in a/b)\n3.cd .. (in a, because .. represents \u2018parent folder\u2019)\n4.cd c (in a/c)\n5.cd . (in a/c, because . represents \u2018current folder\u2019)\nThus, this path can be simpli\ufb01ed to a/c.\n12.2.7 Metadata\nHow can we distinguish between a regular \ufb01le and a directory? For that matter, there are many other attributes\nthat \ufb01les also might contain. We distinguish a \ufb01le type \u2013 different from the \ufb01le extension i.e. png, svg, pdf \u2013 using\n\ufb01elds inside the inode. How does the system know what type the \ufb01le is?\nThis information is stored within an inode. To access it, use the stat calls. For example, to \ufb01nd out when my\n\u2018notes.txt\u2019 \ufb01le was last accessed.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3336, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "85188aa8-3974-4dee-b1d0-e640d3752bad": {"__data__": {"id_": "85188aa8-3974-4dee-b1d0-e640d3752bad", "embedding": null, "metadata": {"page_label": "267", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bc4bbee5-e8db-4b52-b29a-da25a6faca46", "node_type": "4", "metadata": {"page_label": "267", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8f2913788dad18e650f22a935b2629410e6f766a5ad2dacfa007dabcb1346ecb", "class_name": "RelatedNodeInfo"}}, "text": "12.2. STORING DATA ON DISK 267\nstruct stat s ;\nstat( \"notes .txt\", &s) ;\nprintf( \"Last accessed %s\", ctime(&s.st_atime)) ;\nThere are actually three versions of stat ;\nint stat( const char *path, struct stat *buf) ;\nint fstat( int fd, struct stat *buf) ;\nint lstat( const char *path, struct stat *buf) ;\nFor example, a program can use fstat to learn about \ufb01le metadata if it already has a \ufb01le descriptor associated\nwith that \ufb01le.\nFILE *file = fopen( \"notes .txt\",\"r\");\nint fd = fileno(file) ;/*Just for fun -extract the file descriptor\nfrom aCFILE struct */\nstruct stat s ;\nfstat(fd, & s) ;\nprintf( \"Last accessed %s\", ctime(&s.st_atime)) ;\nlstat is almost the same as stat but handles symbolic links differently . From the stat man page.\nlstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information\nabout the link itself, not the \ufb01le that it refers to.\nThe stat functions make use of struct stat . From the stat man page:\nstruct stat {\ndev_t st_dev ; /*IDofdevice containing file */\nino_t st_ino ; /*Inode number */\nmode_t st_mode ; /*File type and mode */\nnlink_t st_nlink ; /*Number ofhard links */\nuid_t st_uid ; /*User IDofowner */\ngid_t st_gid ; /*Group IDofowner */\ndev_t st_rdev ; /*Device ID(ifspecial file )*/\noff_t st_size ; /*Total size ,inbytes */\nblksize_t st_blksize ;/*Block size for filesystem I/O*/\nblkcnt_t st_blocks ; /*Number of512Bblocks allocated */\nstruct timespec st_atim ;/*Time oflast access */\nstruct timespec st_mtim ;/*Time oflast modification */\nstruct timespec st_ctim ;/*Time oflast status change */\n};", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1577, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "924233a9-09c8-4c10-a28f-83324d8108f2": {"__data__": {"id_": "924233a9-09c8-4c10-a28f-83324d8108f2", "embedding": null, "metadata": {"page_label": "268", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e1d8cf19-4dd6-4682-8e28-520b502de329", "node_type": "4", "metadata": {"page_label": "268", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7d84e112ccdc2662ea0f5944462047ee08178974f764018d0b33e4acfa5d14d9", "class_name": "RelatedNodeInfo"}}, "text": "268 CHAPTER 12. FILESYSTEMS\nThest_mode \ufb01eld can be used to distinguish between regular \ufb01les and directories. To accomplish this, use the\nmacros, S_ISDIR andS_ISREG .\nstruct stat s ;\nif(0 == stat(name, &s)) {\nprintf( \"%s\", name) ;\nif(S_ISDIR( s.st_mode)) puts( \"isadirectory \");\nif(S_ISREG( s.st_mode)) puts( \"isaregular file \");\n}else {\nperror( \"stat failed -are you sure wecan read this file \u2019s\nmetadata ?\");\n}\n12.3 Permissions and bits\nPermissions are a key part of the way UNIX systems provide security in a \ufb01lesystem. You may have noticed that\nthest_mode \ufb01eld in struct stat contains more than the \ufb01le type. It also contains the mode, a description\ndetailing what a user can and can\u2019t do with a given \ufb01le. There are usually three sets of permissions for any \ufb01le.\nPermissions for the user, the group and other (every user falling outside the \ufb01rst two categories). For each of the\nthree categories, we need to keep track of whetherthe user is allowed to read the \ufb01le, write to the \ufb01le, and execute\nthe \ufb01le. Since there are three categories and three permissions, permissions are usually represented as a 3-digit\noctal number. For each digit, the least signi\ufb01cant byte corresponds to read privileges, the middle one to write\nprivileges and the \ufb01nal byte to execute privileges. They are always presented as User,Group ,Other (UGO ). Below\nare some common examples. Here are the bit conventions:\n1.rmeans that the set of people can read\n2.wmeans that the set of people can write\n3.xmeans that the set of people can execute\nTable 12.3: Permissions Table\nOctal Code User Group Others\n755 rwx r-x r-x\n644 rw- r\u2013 r\u2013\nIt is worth noting that the rwxbits have a slightly different meaning for directories. Write access to a directory\nthat will allow a program to create or delete new \ufb01les or directories inside. You can think about this as having\nwrite access to the directory entry (dirent) mappings. Read-access to a directory will allow a program to list a", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1951, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d99a8b89-e12f-415e-b511-c8eadefb0648": {"__data__": {"id_": "d99a8b89-e12f-415e-b511-c8eadefb0648", "embedding": null, "metadata": {"page_label": "269", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0ce00458-a9fb-40d3-a306-0ef1d34190ef", "node_type": "4", "metadata": {"page_label": "269", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6e95b0bfce5912ed9f9b0842e6ba670456b21e152abe3427e602615adc81580a", "class_name": "RelatedNodeInfo"}}, "text": "12.3. PERMISSIONS AND BITS 269\ndirectory\u2019s contents. This is read access to the directory entry (dirent) mapping. Execute will allow a program to\nenter the directory using cd. Without the execute bit, it any attempt create or remove \ufb01les or directories will fail\nsince you cannot access them. You can, however, list the contents of the directory.\nThere are several command line utilities for interacting with a \ufb01le\u2019s mode. mknod changes the type of the \ufb01le.\nchmod takes a number and a \ufb01le and changes the permission bits. However, before we can discuss chmod in detail,\nwe must also understand the user ID ( uid) and group id ( gid) as well.\n12.3.1 User ID /Group ID\nEvery user in a UNIX system has a user ID. This is a unique number that can identify a user. Similarly , users can be\nadded to collections called groups, and every group also has a unique identifying number. Groups have a variety\nof uses on UNIX systems. They can be assigned capabilities - a way of describing the level of control a user has\nover a system. For example, a group you may have run into is the sudoers group, a set of trusted users who are\nallowed to use the command sudo to temporarily gain higher privileges. We\u2019ll talk more about how sudo works in\nthis chapter. Every \ufb01le, upon creation, an owner, the creator of the \ufb01le. This owner\u2019s user ID ( uid) can be found\ninside the st_mode \ufb01le of a struct stat with a call to stat . Similarly , the group ID ( gid) is set as well.\nEvery process can determine its uidandgidwith getuid andgetgid . When a process tries to open a \ufb01le\nwith a speci\ufb01c mode, it\u2019s uidandgidare compared with the uidandgidof the \ufb01le. If the uids match, then the\nprocess\u2019s request to open the \ufb01le will be compared with the bits on the user \ufb01eld of the \ufb01le\u2019s permissions. If the\ngids match, then the process\u2019s request will be compared with the group \ufb01eld of the permissions. If none of the\nIDs match, then the other \ufb01eld will apply.\n12.3.2 Reading /Changing \ufb01le permissions\nBefore we discuss how to change permission bits, we should be able to read them. In C, the stat family of library\ncalls can be used. To read permission bits from the command line, use ls -l . Note, the permissions will output\nin the format \u2018trwxrwxrwx\u2019. The \ufb01rst character indicates the type of \ufb01le type. Possible values for the \ufb01rst character\ninclude but aren\u2019t limited to.\n1.(-) regular \ufb01le\n2.(d) directory\n3.(c) character device \ufb01le\n4.(l) symbolic link\n5.(p) named pipe (also called FIFO)\n6.(b) block device\n7.(s) socket\nAlternatively , use the program stat which presents all the information that one could retrieve from the stat\nlibrary call.\nTo change the permission bits, there is a system call, int chmod(const char *path, mode_t mode); . To\nsimplify our examples, we will be using the command line utility of the same name chmod short of \u201cchange mode\u201d.\nThere are two common ways to use chmod , with either an octal value or with a symbolic string.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2929, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d7be4361-5548-467c-9aee-922c8c01c2a1": {"__data__": {"id_": "d7be4361-5548-467c-9aee-922c8c01c2a1", "embedding": null, "metadata": {"page_label": "270", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3a1856b2-b6b6-4205-bf0d-852eca18c0ad", "node_type": "4", "metadata": {"page_label": "270", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d7b666079bb7aa5a03dde599511a4e66058a586bf96409ff05863d79b6bff298", "class_name": "RelatedNodeInfo"}}, "text": "270 CHAPTER 12. FILESYSTEMS\n$ chmod 644 file1\n$ chmod 755 file2\n$ chmod 700 file3\n$ chmod ugo-w file4\n$ chmod o-rx file4\nThe base-8 (\u2018octal\u2019) digits describe the permissions for each role: The user who owns the \ufb01le, the group and\neveryone else. The octal number is the sum of three values given to the three types of permission: read(4),\nwrite(2), execute(1)\nExample: chmod 755 myfile\n1.r+w+x=digit * user has 4 +2+1, full permission\n2.group has 4 +0+1, read and execute permission\n3.all users have 4 +0+1, read and execute permission\n12.3.3 Understanding the \u2018umask\u2019\nThe umask subtracts (reduces) permission bits from 777and is used when new \ufb01les and new directories are created\nby open, mkdir etc. By default, the umask is set to 022(octal), which means that group and other privileges will\nbe exclusively readable. Each process has a current umask value. When forking, the child inherits the parent\u2019s\numask value.\nFor example, by setting the umask to 077in the shell, ensures that future \ufb01le and directory creation will only\nbe accessible to the current user,\n$umask 077\n$ mkdir secretdir\nAs a code example, suppose a new \ufb01le is created with open() and mode bits 666(write and read bits for user,\ngroup and other):\nopen( \"myfile \", O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH\n| S_IWOTH) ;\nIf umask is octal 022, then the permissions of the created \ufb01le will be 0666 & ~022for example.\nS_IRUSR | S_IWUSR | S_IRGRP | S_IROTH", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1437, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a1e91f87-2783-4dca-8e4d-d1a98c8eb242": {"__data__": {"id_": "a1e91f87-2783-4dca-8e4d-d1a98c8eb242", "embedding": null, "metadata": {"page_label": "271", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "457c1c42-ade1-4b82-845e-44e59115c28d", "node_type": "4", "metadata": {"page_label": "271", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d9b6f71e113a0c6405b6583042234906e0d226594967fa07b4cf95e0fb605520", "class_name": "RelatedNodeInfo"}}, "text": "12.3. PERMISSIONS AND BITS 271\n12.3.4 The \u2018setuid\u2019 bit\nYou may have noticed an additional bit that \ufb01les with execute permission may have set. This bit is the setuid bit.\nIt indicated that when run, the program will set the uid of the user to that of the owner of the \ufb01le. Similar, there\nis asetgid bit which sets the gid of the executor to the gid of the owner. The canonical example of a program\nwith setuid set is sudo .\nsudo is usually a program that is owned by the root user - a user that has all capabilities. By using sudo , an\notherwise unprivileged user can gain access to most parts of the system. This is useful for running programs that\nmay require elevated privileges, such as using chown to change ownership of a \ufb01le, or to use mount to mount or\nunmount \ufb01lesystems (an action we will discuss later in this chapter). Here are some examples:\n$ sudo mount /dev/sda2 /stuff/mydisk\n$ sudo adduser fred\n$ ls -l /usr/bin/sudo\n-r-s--x--x 1 root wheel 327920 Oct 24 09:04 /usr/bin/sudo\nWhen executing a process with the setuid bit, it is still possible to determine a user\u2019s original uid with getuid .\nThe real action of the setuid bit is to set the effective user ID ( euid ) which can be determined with geteuid .\nThe actions of getuid andgeteuid are described below.\n\u2022getuid returns the real user id (zero if logged in as root)\n\u2022geteuid returns the effective user id (zero if acting as root, e.g. due to the setuid \ufb02ag set on a program)\nThese functions can allow one to write a program that can only be run by a privileged user by checking\ngeteuid or go a step further and ensure that the only user who can run the code is root by using getuid .\n12.3.5 The \u2018sticky\u2019 bit\nSticky bits as we use them today serve a different purpose from initial introduction. Sticky bits were a bit that\ncould be set on an executable \ufb01le that would allow a program\u2019s text segment to remain in swap even after the end\nof the program\u2019s execution. This made subsequent executions of the same program faster. Today , this behavior is\nno longer supported and the sticky bit only holds meaning when set on a directory,\nWhen a directory\u2019s sticky bit is set only the \ufb01le\u2019s owner, the directory\u2019s owner, and the root user can rename or\ndelete the \ufb01le. This is useful when multiple users have write access to a common directory . A common use of the\nsticky bit is for the shared and writable /tmp directory where many users\u2019 \ufb01les may be stored, but users should\nnot be able to access \ufb01les belonging to other users.\nTo set the sticky bit, use chmod +t .\naneesh$ mkdir sticky\naneesh$ chmod +t sticky\naneesh$ ls -l\ndrwxr-xr-x 7 aneesh aneesh 4096 Nov 1 14:19 .\ndrwxr-xr-x 53 aneesh aneesh 4096 Nov 1 14:19 ..\ndrwxr-xr-t 2 aneesh aneesh 4096 Nov 1 14:19 sticky", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2734, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "477b8e43-e6d0-40ed-90ff-670b5fc7e925": {"__data__": {"id_": "477b8e43-e6d0-40ed-90ff-670b5fc7e925", "embedding": null, "metadata": {"page_label": "272", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "03bae95b-083b-4d2b-bafc-b1573ea5a6c5", "node_type": "4", "metadata": {"page_label": "272", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4b0e99bc3dd301812efe22abfb0b3937bb1b6a7466325f06bdc23a8f599c6395", "class_name": "RelatedNodeInfo"}}, "text": "272 CHAPTER 12. FILESYSTEMS\naneesh$ su newuser\nnewuser$ rm -rf sticky\nrm: cannot remove \u2019sticky \u2019: Permission denied\nnewuser$ exit\naneesh$ rm -rf sticky\naneesh$ ls -l\ndrwxr-xr-x 7 aneesh aneesh 4096 Nov 1 14:19 .\ndrwxr-xr-x 53 aneesh aneesh 4096 Nov 1 14:19 ..\nNote that in the example above, the username is prepended to the prompt, and the command suis used to\nswitch users.\n12.4 Virtual \ufb01lesystems and other \ufb01lesystems\nPOSIX systems, such as Linux and Mac OS X (which is based on BSD) include several virtual \ufb01lesystems that are\nmounted (available) as part of the \ufb01le-system. Files inside these virtual \ufb01lesystems may be generated dynamically\nor stored in ram. Linux provides 3 main virtual \ufb01lesystems.\nTable 12.4: Virtual Filesystem list\nDevice Use Case\n/dev A list of physical and virtual devices (for example network card, cdrom, random number generator\n/proc A list of resources used by each process and (by tradition) set of system information\n/sys An organized list of internal kernel entities\nIf we want a continuous stream of 0s, we can run cat /dev/zero .\nAnother example is the \ufb01le /dev/null , a great place to store bits that you never need to read. Bytes sent to\n/dev/null/ are never stored and simply discarded. A common use of /dev/null is to discard standard output.\nFor example,\n$ ls . >/dev/null\n12.4.1 Managing \ufb01les and \ufb01lesystems\nGiven the multitude of operations that are available to you from the \ufb01lesystem, let\u2019s explore some tools and\ntechniques that can be used to manage \ufb01les and \ufb01lesystems.\nOne example is creating a secure directory . Suppose you created your own directory in /tmp and then set the\npermissions so that only you can use the directory (see below). Is this secure?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1708, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "acdbfbc5-0267-47d6-92c4-059695bffda1": {"__data__": {"id_": "acdbfbc5-0267-47d6-92c4-059695bffda1", "embedding": null, "metadata": {"page_label": "273", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8f662ad1-2c47-4939-a066-f72699dc706e", "node_type": "4", "metadata": {"page_label": "273", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7d1e01ac7562bb0152862bcdd20a85531abb05642c89dafb11518382f194afd6", "class_name": "RelatedNodeInfo"}}, "text": "12.4. VIRTUAL FILESYSTEMS AND OTHER FILESYSTEMS 273\n$ mkdir /tmp/mystuff\n$ chmod 700 /tmp/mystuff\nThere is a window of opportunity between when the directory is created and when it\u2019s permissions are changed.\nThis leads to several vulnerabilities that are based on a race condition.\nAnother user replaces mystuff with a hard link to an existing \ufb01le or directory owned by the second user, then\nthey would be able to read and control the contents of the mystuff directory . Oh no - our secrets are no longer\nsecret!\nHowever in this speci\ufb01c example, the /tmp directory has the sticky bit set, so only the owner may delete the\nmystuff directory , and the simple attack scenario described above is impossible. This does not mean that creating\nthe directory and then later making the directory private is secure! A better version is to atomically create the\ndirectory with the correct permissions from its inception.\n$ mkdir -m 700 /tmp/mystuff\n12.4.2 Obtaining Random Data\n/dev/random is a \ufb01le that contains a random number generator where the entropy is determined from environ-\nmental noise. Random will block /wait until enough entropy is collected from the environment.\n/dev/urandom is like random, but differs in the fact that it allows for repetition (lower entropy threshold),\nthus won\u2019t block.\nOne can think of both of these as streams of characters from which a program can read as opposed to \ufb01les\nwith a start and end. To touch on a misconception, most of the time one should be using /dev/urandom . The\nonly speci\ufb01c use case of /dev/random is when one needs cryptographically secure data on bootup and the system\nshould block. Otherwise, there are the following reasons.\n1.Empirically , they both produce numbers that look random enough.\n2./dev/random may block at an inconvenient time. If one is programming a service for high scalability and\nrelies on /dev/random , an attacker can reliably exhaust the entropy pool and cause the service to block.\n3.Manual page authors pose a hypothetical attack where an attacker exhausts the entropy pool and guesses\nthe seeding bits, but that attack has yet to be implemented.\n4.Some operating system don\u2019t have a true /dev/random like MacOS.\n5.Security experts will talk about Computational Security vs Information Theoretic security, more on this\narticle Urandom Myths. Most encryption is computationally secure, which means /dev/urandom is as well.\n12.4.3 Copying Files\nUse the versatile ddcommand. For example, the following command copies 1 MiB of data from the \ufb01le\n/dev/urandom to the \ufb01le /dev/null . The data is copied as 1024 blocks of block size 1024 bytes.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2610, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0df18f33-aa85-4ca0-8bd7-743969d8d807": {"__data__": {"id_": "0df18f33-aa85-4ca0-8bd7-743969d8d807", "embedding": null, "metadata": {"page_label": "274", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5d0d79f9-8443-4827-a00f-d877c124c94a", "node_type": "4", "metadata": {"page_label": "274", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6837f13c881309757d4b147ffb7aa6ef410a263cde84ea9ea44ac3522f416cb2", "class_name": "RelatedNodeInfo"}}, "text": "274 CHAPTER 12. FILESYSTEMS\n$ dd if=/dev/urandom of=/dev/null bs=1k count=1024\nBoth the input and output \ufb01les in the example above are virtual - they don\u2019t exist on a disk. This means the\nspeed of the transfer is unaffected by hardware power.\nddis also commonly used to make a copy of a disk or an entire \ufb01lesystem to create images that can either be\nburned on to other disks or to distribute data to other users.\n12.4.4 Updating Modi\ufb01cation Time\nThetouch executable creates a \ufb01le if it is non-existant and also updates the \ufb01le\u2019s last modi\ufb01ed time to be the\ncurrent time. For example, we can make a new private \ufb01le with the current time:\n$umask 077 #all future new files will mask out all r,w,x\nbits for group and other access\n$ touch file123 #create afile ifitnon-existant ,and update\nits modified time\n$ stat file123\nFile: \u2018file123 \u2019\nSize :0 Blocks :0 IOBlock :65536 regular empty\nfile\nDevice :21h/33dInode :226148 Links :1\nAccess :(0600/- rw-------) Uid:(395606/ angrave )Gid:(61019/\news)\nAccess :2014-11-12 13:42:06.000000000 -0600\nModify :2014-11-12 13:42:06.001787000 -0600\nChange :2014-11-12 13:42:06.001787000 -0600\nAn example use of touch is to force make to recompile a \ufb01le that is unchanged after modifying the compiler\noptions inside the make\ufb01le. Remember that make is \u2018lazy\u2019 - it will compare the modi\ufb01ed time of the source \ufb01le\nwith the corresponding output \ufb01le to see if the \ufb01le needs to be recompiled.\n$ touch myprogram.c #force mysource file toberecompiled\n$ make\n12.4.5 Managing Filesystems\nTo manage \ufb01lesystems on your machine, use mount . Using mount without any options generates a list (one\n\ufb01lesystem per line) of mounted \ufb01lesystems including networked, virtual and local (spinning disk /SSD-based)\n\ufb01lesystems. Here is a typical output of mount", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1765, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d403fd87-cd04-41a4-91f8-3033ce0a9bdf": {"__data__": {"id_": "d403fd87-cd04-41a4-91f8-3033ce0a9bdf", "embedding": null, "metadata": {"page_label": "275", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "80184271-f926-4a49-86d5-97be07677f66", "node_type": "4", "metadata": {"page_label": "275", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c69366b808002d481d531944b1130e75746039677922753aac1c2d33f7332c9f", "class_name": "RelatedNodeInfo"}}, "text": "12.4. VIRTUAL FILESYSTEMS AND OTHER FILESYSTEMS 275\n$ mount\n/dev/mapper/cs341--server_sys-root on / type ext4 (rw)\nproc on /proc type proc (rw)\nsysfs on /sys type sysfs (rw)\ndevpts on /dev/pts type devpts (rw,gid=5,mode=620)\ntmpfs on /dev/shm type tmpfs\n(rw,rootcontext= \"system_u :object_r :tmpfs_t :s0\")\n/dev/sda1 on /boot type ext3 (rw)\n/dev/mapper/cs341--server_sys-srv on /srv type ext4 (rw)\n/dev/mapper/cs341--server_sys-tmp on /tmp type ext4 (rw)\n/dev/mapper/cs341--server_sys-var on /var type ext4 (rw)rw, bind )\n/srv/software/Mathematica-8.0 on /software/Mathematica-8.0 type\nnone (rw, bind )\nengr-ews-homes.engr.illinois.edu:/fs1-homes/angrave/linux on\n/home/angrave type nfs\n(rw,soft,intr,tcp,noacl,acregmin=30,vers=3,sec=sys,sloppy,addr=128.174.252.102)\nNotice that each line includes the \ufb01lesystem type source of the \ufb01lesystem and mount point. To reduce this\noutput, we can pipe it into grep and only see lines that match a regular expression.\n>mount | grep proc #only see lines that contain \u2019proc \u2019\nproc on /proc type proc (rw)\nnone on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)\nFilesystem Mounting\nSuppose you had downloaded a bootable Linux disk image from the arch linux download page\n$ wget $URL\nBefore putting the \ufb01lesystem on a CD, we can mount the \ufb01le as a \ufb01lesystem and explore its contents. Note:\nmount requires root access, so let\u2019s run it using sudo\n$ mkdir arch\n$ sudo mount -o loop archlinux-2015.04.01-dual.iso ./arch\n$cdarch\nBefore the mount command, the arch directory is new and obviously empty . After mounting, the contents of", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1563, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "016ab5cf-685e-4bc6-80b2-4389ecf03535": {"__data__": {"id_": "016ab5cf-685e-4bc6-80b2-4389ecf03535", "embedding": null, "metadata": {"page_label": "276", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c775a736-baf5-4116-bdba-5968271262e9", "node_type": "4", "metadata": {"page_label": "276", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4ac3e37595cb2a2d0f3331de67783472a6738c414079a84b729e4e70bb639a05", "class_name": "RelatedNodeInfo"}}, "text": "276 CHAPTER 12. FILESYSTEMS\narch/ will be drawn from the \ufb01les and directories stored in the \ufb01lesystem stored inside the archlinux-2014.11.01-dual.iso\n\ufb01le. The loop option is required because we want to mount a regular \ufb01le, not a block device such as a physical\ndisk.\nThe loop option wraps the original \ufb01le as a block device. In this example, we will \ufb01nd out below that the\n\ufb01le system is provided under /dev/loop0 . We can check the \ufb01lesystem type and mount options by running the\nmount command without any parameters. We will pipe the output into grep so that we only see the relevant\noutput line(s) that contain \u2018arch\u2019.\n$ mount | grep arch\n/home/demo/archlinux-2014.11.01-dual.iso on /home/demo/arch type\niso9660 (rw,loop=/dev/loop0)\nThe iso9660 \ufb01lesystem is a read-only \ufb01lesystem originally designed for optical storage media (i.e. CDRoms).\nAttempting to change the contents of the \ufb01lesystem will fail\n$ touch arch/nocando\ntouch: cannot touch \u2018/home/demo/arch/nocando \u2019:Read -only file system\n12.5 Memory Mapped IO\nWhile we traditionally think of reading and writing from a \ufb01le as an operation that happens by using the read\nandwrite calls, there is an alternative, mapping a \ufb01le into memory using mmap .mmap can also be used for IPC,\nand you can see more about mmap as a system call that enables shared memory in the IPC chapter. In this chapter,\nwe\u2019ll brie\ufb02y explore mmap as a \ufb01lesystem operation.\nmmap takes a \ufb01le and maps its contents into memory . This allows a user to treat the entire \ufb01le as a buffer in\nmemory for easier semantics while programming, and to avoid having to read a \ufb01le as discrete chunks explicitly .\nNot all \ufb01lesystems support using mmap for IO. Those that do have varying behavior. Some will simply implement\nmmap as a wrapper around read andwrite . Others will add additional optimizations by taking advantage of the\nkernel\u2019s page cache. Of course, such optimization can be used in the implementation of read andwrite as well,\nso often using mmap has identical performance.\nmmap is used to perform some operations such as loading libraries and processes into memory. If many\nprograms only need read-access to the same \ufb01le, then the same physical memory can be shared between multiple\nprocesses. This is used for common libraries like the C standard library.\nThe process to map a \ufb01le into memory is as follows.\n1.mmap requires a \ufb01le descriptor, so we need to open the \ufb01le \ufb01rst\n2.We seek to our desired size and write one byte to ensure that the \ufb01le is suf\ufb01cient length\n3.When \ufb01nished call munmap to unmap the \ufb01le from memory .\nHere is a quick example.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2578, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c27b2e73-8b3f-409b-b2e4-9fcbf5122bb7": {"__data__": {"id_": "c27b2e73-8b3f-409b-b2e4-9fcbf5122bb7", "embedding": null, "metadata": {"page_label": "277", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "eca13ed7-1787-46fc-8d41-2a1f8ece1ae7", "node_type": "4", "metadata": {"page_label": "277", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "fc7a412449bfe358404d290467a9222225cd02f21a456e00da34718f12ea126a", "class_name": "RelatedNodeInfo"}}, "text": "12.5. MEMORY MAPPED IO 277\n#include <stdio.h >\n#include <stdlib.h >\n#include <sys/types.h >\n#include <sys/stat.h >\n#include <sys/mman.h >\n#include <fcntl.h >\n#include <unistd.h >\n#include <errno.h >\n#include <string.h >\nint fail( char *filename, int linenumber) {\nfprintf(stderr, \"%s:%d%s\\n\", filename, linenumber, strerror(errno)) ;\nexit(1) ;\nreturn 0;/*Make compiler happy */\n}\n#define QUIT fail(__FILE__, __LINE__ )\nint main() {\n//Wewant afile big enough tohold 10integers\nint size = sizeof (int) * 10 ;\nint fd = open( \"data \", O_RDWR | O_CREAT | O_TRUNC, 0600) ;//6=\nread +write for me!\nlseek(fd, size, SEEK_SET) ;\nwrite(fd, \"A\", 1) ;\nvoid *addr = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0) ;\nprintf( \"Mapped at%p\\n\", addr) ;\nif(addr == ( void *) -1 ) QUIT ;\nint *array = addr ;\narray[0] = 0x12345678 ;\narray[1] = 0xdeadc0de ;\nmunmap(addr,size) ;\nreturn 0;\n}\nThe careful reader may notice that our integers were written in least-signi\ufb01cant-byte format because that\nis the endianness of the CPU that we ran this example on. We also allocated a \ufb01le that is one byte too many!\nThePROT_READ | PROT_WRITE options specify the virtual memory protection. The option PROT_EXEC (not used\nhere) can be set to allow CPU execution of instructions in memory.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1262, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "848c723b-1c70-42c3-b6bd-eaae13ae0ea9": {"__data__": {"id_": "848c723b-1c70-42c3-b6bd-eaae13ae0ea9", "embedding": null, "metadata": {"page_label": "278", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6904bba4-c48a-4801-885a-a32484b981fe", "node_type": "4", "metadata": {"page_label": "278", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4c6d636c04b9a384e60b9f153734968b9994a3aaaf2f72194570f699a8714501", "class_name": "RelatedNodeInfo"}}, "text": "278 CHAPTER 12. FILESYSTEMS\n12.6 Reliable Single Disk Filesystems\nMost \ufb01lesystems cache signi\ufb01cant amounts of disk data in physical memory . Linux, in this respect, is extreme. All\nunused memory is used as a giant disk cache. The disk cache can have a signi\ufb01cant impact on overall system\nperformance because disk I /O is slow. This is especially true for random access requests on spinning disks where\nthe disk read-write latency is dominated by the seek time required to move the read-write disk head to the correct\nposition.\nFor ef\ufb01ciency , the kernel caches recently used disk blocks. For writing, we have to choose a trade-off between\nperformance and reliability . Disk writes can also be cached (\u201cWrite-back cache\u201d) where modi\ufb01ed disk blocks are\nstored in memory until evicted. Alternatively , a \u2018write-through cache\u2019 policy can be employed where disk writes\nare sent immediately to the disk. The latter is safer as \ufb01lesystem modi\ufb01cations are quickly stored to persistent\nmedia but slower than a write-back cache. If writes are cached then they can be delayed and ef\ufb01ciently scheduled\nbased on the physical position of each disk block. Note, this is a simpli\ufb01ed description because solid state drives\n(SSDs) can be used as a secondary write-back cache.\nBoth solid state disks (SSD) and spinning disks have improved performance when reading or writing sequential\ndata. Thus, operating systems can often use a read-ahead strategy to amortize the read-request costs and request\nseveral contiguous disk blocks per request. By issuing an I /O request for the next disk block before the user\napplication requires the next disk block, the apparent disk I /O latency can be reduced.\nIf your data is important and needs to be force written to disk, call sync to request that a \ufb01lesystem\u2019s changes\nbe written (\ufb02ushed) to disk. However, operating systems may ignore this request. Even if the data is evicted from\nthe kernel buffers, the disk \ufb01rmware may use an internal on-disk cache or may not yet have \ufb01nished changing the\nphysical media. Note, you can also request that all changes associated with a particular \ufb01le descriptor are \ufb02ushed\nto disk using fsync(int fd) . There is a \ufb01ery debate about this call being useless, initiated by PostgresQL\u2019s team\nhttps://lwn.net/Articles/752063/\nIf your operating system fails in the middle of an operation, most modern \ufb01le systems do something called\njournaling to work around this. What the \ufb01le system does is before it completes a potentially expensive operation,\nis that it writes what it is going to do down in a journal. In the case of a crash or failure, one can step through the\njournal and see which \ufb01les are corrupt and \ufb01x them. This is a way to salvage hard disks in cases there is critical\ndata and there is no apparent backup.\nEven though it is unlikely for your computer, programming for data centers means that disks fail every few\nseconds. Disk failures are measured using \u201cMean-Time-To-Failure (MTTF)\u201d. For large arrays, the mean failure time\ncan be surprisingly short. If the MTTF(single disk) =30,000 hours, then the MTTF(1000 disks) =30000 /1000 =30\nhours or about a day and a half! That\u2019s also assuming that the failures between the disks are independent, which\nthey often aren\u2019t.\n12.6.1 RAID - Redundant Array of Inexpensive Disks\nOne way to protect against this is to store the data twice! This is the main principle of a \u201cRAID-1\u201d disk array . By\nduplicating the writes to a disk with writes to another backup disk, there are exactly two copies of the data. If one\ndisk fails, the other disk serves as the only copy until it can be re-cloned. Reading data is faster since data can be\nrequested from either disk, but writes are potentially twice as slow because now two write commands need to be\nissued for every disk block write. Compared to using a single disk, the cost of storage per byte has doubled.\nAnother common RAID scheme is RAID-0, meaning that a \ufb01le could be split up among two disks, but if any\ndisk fails then the \ufb01les are irrecoverable. This has the bene\ufb01t of halving write times because one part of the \ufb01le\ncould be writing to hard disk one and another part to hard disk two.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4150, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dad43463-3492-4dd7-b83e-eef46b9b33e2": {"__data__": {"id_": "dad43463-3492-4dd7-b83e-eef46b9b33e2", "embedding": null, "metadata": {"page_label": "279", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "38151ae5-019f-4f99-b324-7df5ed92b5c9", "node_type": "4", "metadata": {"page_label": "279", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b4be424e712d1ed25a62b4e6a68a7f679fa4fcf5af62d5e6355573970e56b14c", "class_name": "RelatedNodeInfo"}}, "text": "12.6. RELIABLE SINGLE DISK FILESYSTEMS 279\nIt is also common to combine these systems. If you have a lot of hard disks, consider RAID-10. This is where\nyou have two systems of RAID-1, but the systems are hooked up in RAID-0 to each other. This means you would\nget roughly the same speed from the slowdowns but now any one disk can fail and you can recover that disk. If\ntwo disks from opposing raid partitions fail, there is a chance that you can recover though we don\u2019t could on it\nmost of the time.\n12.6.2 Higher Levels of RAID\nRAID-3 uses parity codes instead of mirroring the data. For each N-bits written, we will write one extra bit, the\n\u2018Parity bit\u2019 that ensures the total number of 1s written is even. The parity bit is written to an additional disk. If any\ndisk including the parity disk is lost, then its contents can still be computed using the contents of the other disks.\nOne disadvantage of RAID-3 is that whenever a disk block is written, the parity block will always be written\ntoo. This means that there is effectively a bottleneck in a separate disk. In practice, this is more likely to cause a\nfailure because one disk is being used 100% of the time and once that disk fails then the other disks are more\nprone to failure.\nA single disk failure is recoverable because there is suf\ufb01cient data to rebuild the array from the remaining\ndisks. Data-loss will occur when two disks are unusable because there is no longer suf\ufb01cient data to rebuild the\narray . We can calculate the probability of a two disk failure based on the repair time which factors both the time\nto insert a new disk and the time required to rebuild the entire contents of the array.\nMTTF = mean time to failure\nMTTR = mean time to repair\nN = number of original disks\np = MTTR / (MTTF-one-disk / (N-1))\nUsing typical numbers (MTTR =1day , MTTF =1000days, N-1 =9, p=0.009)\nThere is a 1% chance that another drive will fail during the rebuild process (at that point you had better hope\nyou still have an accessible backup of your original data. In practice, the probability of a second failure during the\nrepair process is likely higher because rebuilding the array is I /O-intensive (and on top of normal I /O request\nactivity). This higher I /O load will also stress the disk array .\nRAID-5 is similar to RAID-3 except that the check block (parity information) is assigned to different disks\nfor different blocks. The check-block is \u2018rotated\u2019 through the disk array . RAID-5 provides better read and write\nperformance than RAID-3 because there is no longer the bottleneck of the single parity disk. The one drawback is\nthat you need more disks to have this setup, and there are more complicated algorithms that need to be used.\nFailure is common. Google reports 2-10% of disks fail per year. Multiplying that by 60,000 +disks in a single\nwarehouse. Services must survive single disk, rack of servers, or whole data center failures.\n12.6.3 Solutions\nSimple redundancy (2 or 3 copies of each \ufb01le) e.g., Google GFS (2001). More ef\ufb01cient redundancy (analogous to\nRAID 3 ++) e.g., Google Colossus \ufb01lesystem (~2010): customizable replication including Reed-Solomon codes\nwith 1.5x redundancy", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3169, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "66e3258b-1d3c-43b7-b577-dafe91bfbd63": {"__data__": {"id_": "66e3258b-1d3c-43b7-b577-dafe91bfbd63", "embedding": null, "metadata": {"page_label": "280", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "971d8269-c87e-4c17-a49d-fcc3deea8074", "node_type": "4", "metadata": {"page_label": "280", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b2909bd8c1a20682bde38161920938a2955c53eb0208fd5369c7d7affe16ebbd", "class_name": "RelatedNodeInfo"}}, "text": "280 CHAPTER 12. FILESYSTEMS\n12.7 Simple Filesystem Model\nSoftware developers need to implement \ufb01lesystems all the time. If that is surprising to you, we encourage you to\ntake a look at Hadoop, GlusterFS, Qumulo, etc. Filesystems are hot areas of research as of 2018 because people\nhave realized that the software models that we have devised don\u2019t take full advantage of our current hardware.\nAdditionally , the hardware that we use for storing information is getting better all the time. As such, you may end\nup designing a \ufb01lesystem yourself someday . In this section, we will go over one of a fake \ufb01lesystems and \u201cwalk\nthrough\u201d some examples of how things work.\nSo, what does our hypothetical \ufb01lesystem look like? We will base it off of the minixfs , a simple \ufb01lesystem\nthat happens to be the \ufb01rst \ufb01lesystem that Linux ran on. It is laid out sequentially on disk, and the \ufb01rst section is\nthe superblock. The superblock stores important metadata about the entire \ufb01lesystem. Since we want to be able to\nread this block before we know anything else about the data on disk, this needs to be in a well-known location so\nthe start of the disk is a good choice. After the superblock, we\u2019ll keep a map of which inodes are being used. The\nnth bit is set if the nth inode \u2013 0 being the inode root \u2013 is being used. Similarly , we store a map recording which\ndata blocks are used. Finally , we have an array of inodes followed by the rest of the disk - implicitly partitioned\ninto data blocks. One data block may be identical to the next from the perspective of the hardware components of\nthe disk. Thinking about the disk as an array of data blocks is simply something we do so that we have a way to\ndescribe where \ufb01les live on disk.\nBelow, we have an example of how an inode that describes a \ufb01le may look. Note that for the sake of simplicity ,\nwe have drawn arrows mapping data block numbers in the inode to their locations on disk. These aren\u2019t pointers\nso much as indices into an array.\nFigure 12.1: Sample \ufb01le \ufb01lling up\nWe will assume that a data block is 4 KiB.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2058, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c5959a23-2d6c-4417-87db-d43ac7f8f559": {"__data__": {"id_": "c5959a23-2d6c-4417-87db-d43ac7f8f559", "embedding": null, "metadata": {"page_label": "281", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7c24d009-5108-42f1-9092-ced92f6f122a", "node_type": "4", "metadata": {"page_label": "281", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ebb6bc92880b7bbf37309e1039e8f5f1c1d1e03c273a7fb26e85c24be41705d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ce41bafc-e1af-4f03-b452-f0a8d1c0df26", "node_type": "1", "metadata": {}, "hash": "05e7c6966727c99187770cfad192872ab4d79d783c2eecd9f433299e047230a8", "class_name": "RelatedNodeInfo"}}, "text": "12.7. SIMPLE FILESYSTEM MODEL 281\nNote that a \ufb01le will \ufb01ll up each of its data blocks completely before requesting an additional data block. We\nwill refer to this property as the \ufb01le being compact . The \ufb01le presented above is interesting since it uses all of its\ndirect blocks, one of the entries for its indirect block and partially uses another indirect block.\nThe following subsections will all refer to the \ufb01le presented above.\n12.7.1 File Size vs Space on Disk\nOur \ufb01le\u2019s size must be stored in the inode. The \ufb01lesystem isn\u2019t aware of the actual contents of what is in a \ufb01le -\nthat data is considered the user\u2019s and should only be manipulated by the user. However, we can compute upper\nand lower bounds on the \ufb01lesize by only looking at how many blocks the \ufb01le uses.\nThere are two full direct blocks, which together store 2 \u2217sizeo f (data _block ) =2\u22174KiB=8KiB.\nThere are two used blocks referenced by the indirect block, which can store up to 8 KiB as calculated above.\nWe can now add these values to get an upper bound on the \ufb01le size of 16 KiB.\nWhat about a lower bound? We know that we must use the two direct blocks, one block referenced by the\nindirect block and at least 1 byte of a second block referenced by the indirect block. With this information, we can\nwork out the lower bound to be 2 \u22174KiB+4KiB+1=12KiB+1B.\nNote that our calculations so far have been to determine how much data the user is storing on disk. What about\ntheoverhead of storing this data incurred while using this \ufb01lesystem? You\u2019ll notice that we use an indirect block to\nstore the disk block numbers of blocks used beyond the two direct blocks. While doing our above calculations,\nwe omitted this block. This would instead be counted as the overhead of the \ufb01le, and thus the total overhead of\nstoring this \ufb01le on disk is sizeo f (indirect _block ) =4KiB).\nThinking about overhead, a related calculation could be to determine the max /min disk usage per \ufb01le in this\n\ufb01lesystem.\nTrivially a \ufb01le of size 0 has no associated data blocks and takes up no space on disk (ignoring the space\nrequired for the inode since these are located in a \ufb01xed size array somewhere on disk). How about the disk usage\nof the smallest non-empty \ufb01le? That is, consider a \ufb01le of size 1 B. Note that when a user writes the \ufb01rst byte, a\ndata block will be allocated. Since each data block is 4 KiB, we \ufb01nd that 4 KiBis the minimum disk usage for a\nnon-empty \ufb01le. Here, we observe that the \ufb01le size will only be 1 B, despite that 4 KiB of the disk is used \u2013 there is\na distinction between \ufb01le size and disk usage because of overhead!\nFinding maximum is slightly more involved. As we saw earlier in this chapter, a \ufb01lesystem with this structure\ncan have 1024 data block numbers in one indirect block. This implies that the maximum \ufb01lesize can be 2 \u22174KiB+\n1024 \u22174KiB=4M iB+8KiB (after accounting for the direct blocks as well). However, on disk we also store the\nindirect block itself. This means that an additional 4 KiB of overhead will be used to account for the indirect block,\nso the total disk usage will be 4 M iB+12KiB.\nNote that when only using direct blocks, completely \ufb01lling up a direct block implies that our \ufb01lesize and our\ndisk usage are the same thing! While it would seem like we always want this ideal scenario, it puts a restrictive\nlimit on the maximum \ufb01lesize. Attempting to remedy this by increasing the number of direct blocks seems\npromising, but note that this requires increasing the size of an inode and reducing the amount of space available\nto store user data \u2013 a tradeoff you will have to evaluate for yourself. Alternatively always trying to split your data\nup into chunks that never use indirect blocks is may exhaust the limited pool of available inodes.\n12.7.2 Performing Reads\nPerforming reads tend to be pretty easy in our \ufb01lesystem because our \ufb01les are compact.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3851, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ce41bafc-e1af-4f03-b452-f0a8d1c0df26": {"__data__": {"id_": "ce41bafc-e1af-4f03-b452-f0a8d1c0df26", "embedding": null, "metadata": {"page_label": "281", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7c24d009-5108-42f1-9092-ced92f6f122a", "node_type": "4", "metadata": {"page_label": "281", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ebb6bc92880b7bbf37309e1039e8f5f1c1d1e03c273a7fb26e85c24be41705d8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c5959a23-2d6c-4417-87db-d43ac7f8f559", "node_type": "1", "metadata": {"page_label": "281", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c8a0e4f9dd9a1fc68aeef5a8c11f3b92ae851c51f5294ef50a5c289732fead82", "class_name": "RelatedNodeInfo"}}, "text": "Note that when only using direct blocks, completely \ufb01lling up a direct block implies that our \ufb01lesize and our\ndisk usage are the same thing! While it would seem like we always want this ideal scenario, it puts a restrictive\nlimit on the maximum \ufb01lesize. Attempting to remedy this by increasing the number of direct blocks seems\npromising, but note that this requires increasing the size of an inode and reducing the amount of space available\nto store user data \u2013 a tradeoff you will have to evaluate for yourself. Alternatively always trying to split your data\nup into chunks that never use indirect blocks is may exhaust the limited pool of available inodes.\n12.7.2 Performing Reads\nPerforming reads tend to be pretty easy in our \ufb01lesystem because our \ufb01les are compact. Let\u2019s say that we want to\nread the entirety of this particular \ufb01le. What we\u2019d start by doing is go to the inode\u2019s direct struct and \ufb01nd the\n\ufb01rst direct data block number. In our case, it is #7. Then we \ufb01nd the 7th data block from the start of all data", "mimetype": "text/plain", "start_char_idx": 3081, "end_char_idx": 4103, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9133e626-bf32-45f9-9076-2e3607725f55": {"__data__": {"id_": "9133e626-bf32-45f9-9076-2e3607725f55", "embedding": null, "metadata": {"page_label": "282", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a581ae2a-654b-4cb6-9aad-64526a04f76a", "node_type": "4", "metadata": {"page_label": "282", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "97d442426be78295bd5dbb7f7bb12f760eac19e04dfc4bbb05b3ebe77805fafe", "class_name": "RelatedNodeInfo"}}, "text": "282 CHAPTER 12. FILESYSTEMS\nblocks. Then we read all of those bytes. We do the same thing for all of the direct nodes. What do we do after?\nWe go to the indirect block and read the indirect block. We know that every 4 bytes of the indirect block is either\na sentinel node (-1) or the number of another data block. In our particular example, the \ufb01rst four bytes evaluate\nto the integer 5, meaning that our data continues on the 5th data block from the beginning. We do the same for\ndata block #4 and we stop after because we exceed the size of the inode\nNow, let\u2019s think about the edge cases. How would a program start the read starting at an arbitrary offset of\nnbytes given that block sizes are 4 KiBs . How many indirect blocks should there be if the \ufb01lesystem is correct?\n(Hint: think about using the size of the inode )\n12.7.3 Performing Writes\nWriting to \ufb01les\nPerforming writes fall into two categories, writes to \ufb01les and writes to directories. First we\u2019ll focus on \ufb01les and\nassume that we are writing a byte to the 6th KiB of our \ufb01le. To perform a write on a \ufb01le at a particular offset, \ufb01rst\nthe \ufb01lesystem must go to the data block would start at that offset. For this particular example we would have to\ngo to the 2nd or indexed number 1 inode to perform our write. We would once again fetch this number from the\ninode, go to the root of the data blocks, go to the 5th data block and perform our write at the 2KiB offset from\nthis block because we skipped the \ufb01rst four kibibytes of the \ufb01le in block 7. We perform our write and go on our\nmerry way .\nSome questions to consider.\n\u2022How would a program perform a write go across data block boundaries?\n\u2022How would a program perform a write after adding the offset would extend the length of the \ufb01le?\n\u2022How would a program perform a write where the offset is greater than the length of the original \ufb01le?\nWriting to directories\nPerforming a write to a directory implies that an inode needs to be added to a directory . If we pretend that the\nexample above is a directory. We know that we will be adding at most one directory entry at a time. Meaning\nthat we have to have enough space for one directory entry in our data blocks. Luckily the last data block that we\nhave has enough free space. This means we need to \ufb01nd the number of the last data block as we did above, go to\nwhere the data ends, and write one directory entry. Don\u2019t forget to update the size of the directory so that the\nnext creation doesn\u2019t overwrite your \ufb01le!\nSome more questions:\n\u2022How would would a program perform a write when the last data block is already full?\n\u2022How about when all the direct blocks have been \ufb01lled up and the inode doesn\u2019t have an indirect block?\n\u2022What about when the \ufb01rst indirect entry (#4) is full?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2743, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "62198fb0-1d6b-443a-b60e-739d738233c2": {"__data__": {"id_": "62198fb0-1d6b-443a-b60e-739d738233c2", "embedding": null, "metadata": {"page_label": "283", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0276b75e-f3d1-49ee-b4fc-236aa4d0de82", "node_type": "4", "metadata": {"page_label": "283", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c148c126de2f34d1ba91e147cfd3b13b587c7d9099b93959bb0fbb5343edf703", "class_name": "RelatedNodeInfo"}}, "text": "12.8. TOPICS 283\n12.7.4 Adding Deletes\nIf the inode is a \ufb01le, then remove the directory entry in the parent directory by marking it as invalid (maybe\nmaking it point to inode -1) and skip it in your reads. A \ufb01lesystem decreases the hard link count of the inode and\nif the count reaches zero, free the inode in the inode map and free all associated data blocks so they are reclaimed\nby the \ufb01lesystem. In many operating systems, several \ufb01elds in the inode get overwritten.\nIf the inode is a directory , the \ufb01lesystem checks if it is empty . If not, then the kernel will most likely mark an\nerror.\nBe sure to check out the appendix for modern and cutting edge \ufb01lesystems.\n12.8 Topics\n\u2022Superblock\n\u2022Data Block\n\u2022Inode\n\u2022Relative Path\n\u2022File Metadata\n\u2022Hard and Soft Links\n\u2022Permission Bits\n\u2022Mode bits\n\u2022Working with Directories\n\u2022Virtual File System\n\u2022Reliable File Systems\n\u2022RAID\n12.9 Questions\n\u2022How big can \ufb01les be on a \ufb01le system with 15 Direct blocks, 2 double, 3 triple indirect, 4kb blocks and 4byte\nentries? (Assume enough in\ufb01nite blocks)\n\u2022What is a superblock? Inode? Data block?\n\u2022How do we simplify /./proc/../dev/./random /\n\u2022In ext2, what is stored in an inode, and what is stored in a directory entry?\n\u2022What are /sys,/proc, /dev/random, and /dev/urandom?\n\u2022What are the permission bits?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1282, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "93a8ecff-c04f-4c40-ae4a-68e4ee49e9bd": {"__data__": {"id_": "93a8ecff-c04f-4c40-ae4a-68e4ee49e9bd", "embedding": null, "metadata": {"page_label": "284", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "04c8efb9-91db-4be8-8990-c5905fe3b4f3", "node_type": "4", "metadata": {"page_label": "284", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b34ae9901a295522e4d522de021d093267e114f4f7aae50634f595432aeae8ed", "class_name": "RelatedNodeInfo"}}, "text": "284 CHAPTER 12. FILESYSTEMS\n\u2022How does one use chmod to set user /group /owner read /write /execute permissions?\n\u2022What does the \u201cdd\u201d command do?\n\u2022What is the difference between a hard link and a symbolic link? Does the \ufb01le need to exist?\n\u2022\u201cls -l\u201d shows the size of each \ufb01le in a directory . Is the size stored in the directory or in the \ufb01le\u2019s inode?\nBibliography\n[1]International. URL https://www.iec.ch/si/binary.htm .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 418, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3a1a71ec-69c4-4542-b32b-2a0ffad7b137": {"__data__": {"id_": "3a1a71ec-69c4-4542-b32b-2a0ffad7b137", "embedding": null, "metadata": {"page_label": "321", "file_name": "honors.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/honors.pdf", "file_type": "application/pdf", "file_size": 127370, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "fe6ba256-f571-4f60-a6d6-2f5d76fbc4f2", "node_type": "4", "metadata": {"page_label": "321", "file_name": "honors.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/honors.pdf", "file_type": "application/pdf", "file_size": 127370, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "63ef58d0b8e10a32ef89b5a4d1165f9f930173f668e2ce0126cdc3e5f3fcb225", "class_name": "RelatedNodeInfo"}}, "text": "16\nHonors topics\nIf I have seen further it is by standing on the sholders [sic]of Giants\nSir Isaac Newton\nThis chapter contains the contents of some of the honors lectures (CS 296-41). These topics are aimed at\nstudents who want to dive deeper into the topics of CS 341.\n16.1 The Linux Kernel\nThroughout the course of CS 341, you become familiar with system calls - the userspace interface to interacting\nwith the kernel. How does this kernel actually work? What is a kernel? In this section, we will explore these\nquestions in more detail and shed some light on various black boxes that you have encountered in this course. We\nwill mostly be focusing on the Linux kernel in this chapter, so please assume that all examples pertain to the Linux\nkernel unless otherwise speci\ufb01ed.\n16.1.1 What kinds of kernels are there?\nAs it stands, most of you are probably familiar with the Linux kernel, at least in terms of interacting with it via\nsystem calls. Some of you may also have explored the Windows kernel, which we won\u2019t talk about too much in\nthis chapter. or Darwin , the UNIX-like kernel for macOS (a derivative of BSD). Those of you who might have\ndone a bit more digging might have also encountered projects such a GNU HURD orzircon .\nKernels can generally be classi\ufb01ed into one of two categories, a monolithic kernel or a micro-kernel. A\nmonolithic kernel is essentially a kernel and all of it\u2019s associated services as a single program. A micro-kernel on\nthe other hand is designed to have a main component which provides the bare-minimum functionality that a kernel\nneeds. This involves setting up important device drivers, the root \ufb01lesystem, paging or other functionality that is\nimperative for other higher-level features to be implemented. The higher-level features (such as a networking stack,\nother \ufb01lesystems, and non-critical device drivers) are then implemented as separate programs that can interact\nwith the kernel by some form of IPC, typically RPC. As a result of this design, micro-kernels have traditionally\nbeen slower than monolithic kernels due to the IPC overhead.\nWe will devote our discussion from here onwards to focusing on monolithic kernels and unless speci\ufb01ed\notherwise, speci\ufb01cally the Linux kernel.\n321", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2235, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1286b271-f7c6-4594-8619-f120cfe391cf": {"__data__": {"id_": "1286b271-f7c6-4594-8619-f120cfe391cf", "embedding": null, "metadata": {"page_label": "322", "file_name": "honors.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/honors.pdf", "file_type": "application/pdf", "file_size": 127370, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8fdd045c-b452-4d92-91bf-9b299c248a24", "node_type": "4", "metadata": {"page_label": "322", "file_name": "honors.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/honors.pdf", "file_type": "application/pdf", "file_size": 127370, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9f5cc19dadf67c1752b0b481b57d22bec4170759270081db0ea590e338bb3c14", "class_name": "RelatedNodeInfo"}}, "text": "322 CHAPTER 16. HONORS TOPICS\n16.1.2 System Calls Demysti\ufb01ed\nSystem Calls use an instruction that can be run by a program operating in userspace that traps to the kernel (by\nuse of a signal) to complete the call. This includes actions such as writing data to disk, interacting directly with\nhardware in general or operations related to gaining or relinquishing privileges (e.g. becoming the root user and\ngaining all capabilities).\nIn order to ful\ufb01ll a user\u2019s request, the kernel will rely on kernel calls . Kernel calls are essentially the \"public\"\nfunctions of the kernel - functions implemented by other developers for use in other parts of the kernel. Here is a\nsnippet for a kernel call man page:\nName\nkmalloc allocate memory\nSynopsis\nvoid * kmalloc ( size_t size,\ngfp_t flags) ;\nArguments\nsize_t size\nhow many bytes of memory are required.\ngfp_t flags\nthe type of memory to allocate.\nDescription\nkmalloc is the normal method of allocating memory for objects smaller\nthan page size in the kernel.\nThe flags argument may be one of:\nGFP_USER - Allocate memory on behalf of user. May sleep.\nGFP_KERNEL - Allocate normal kernel ram. May sleep.\nGFP_ATOMIC - Allocation will not sleep. May use emergency pools. For\nexample, use this inside interrupt handlers.\nYou\u2019ll note that some \ufb02ags are marked as potentially causing sleeps. This tells us whetherwe can use those\n\ufb02ags in special scenarios, like interrupt contexts, where speed is of the essence, and operations that may block or\nwait for another process may never complete.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1526, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dab7fc72-61d6-4d47-a6fb-8bafcf9c4747": {"__data__": {"id_": "dab7fc72-61d6-4d47-a6fb-8bafcf9c4747", "embedding": null, "metadata": {"page_label": "323", "file_name": "honors.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/honors.pdf", "file_type": "application/pdf", "file_size": 127370, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "234721b9-6b02-4866-8e80-213ba2c1459b", "node_type": "4", "metadata": {"page_label": "323", "file_name": "honors.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/honors.pdf", "file_type": "application/pdf", "file_size": 127370, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7e7887ae81dc3d9bd94a0ec7e699184e21eb5ff683b1cea02d381416a7dc6b71", "class_name": "RelatedNodeInfo"}}, "text": "16.2. CONTAINERIZATION 323\n16.2 Containerization\nAs we enter an era of unprecedented scale with around 20 billion devices connected to the internet in 2018,\nwe need technologies that help us develop and maintain software capable of scaling upwards. Additionally ,\nas software increases in complexity , and designing secure software becomes harder, we \ufb01nd that we have new\nconstraints imposed on us as we develop applications. As if that wasn\u2019t enough, efforts to simplify software\ndistribution and development, like package manager systems can often lead to headaches of their own, leading to\nbroken packages, dependencies that are impossible to resolve and other such environmental nightmares that have\nbecome all to common today . While these seem like disjoint problems at \ufb01rst, all of these and more can be solved\nby throwing containerization at the problem.\n16.2.1 What is a container?\nA container is almost like a virtual machine. In some senses, containers are to virtual machines as threads are\nto processes. A container is a lightweight environment that shares resources and a kernel with a host machine,\nwhile isolating itself from other containers or processes on the host. You may have encountered containers while\nworking with technologies such as Docker , perhaps the most well-known implementation of containers out there.\n16.2.2 Linux Namespaces\n16.2.3 Building a container from scratch\n16.2.4 Containers in the wild: Software distribution is a Snap\nBibliography", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1478, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b15f9cb3-4e37-4d07-95f0-d8165dde5203": {"__data__": {"id_": "b15f9cb3-4e37-4d07-95f0-d8165dde5203", "embedding": null, "metadata": {"page_label": "32", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0ba40b67-ae26-4674-9e9a-acb2a56f3394", "node_type": "4", "metadata": {"page_label": "32", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4159e719764373e859cb1d8eb5f7fb3fa77847f85429476bfd4e7bac5be72ad7", "class_name": "RelatedNodeInfo"}}, "text": "3\nThe C Programming Language\nIf you want to teach systems, don\u2019t drum up the programmers, sort\nthe issues, and make PRs. Instead, teach them to yearn for the vast and\nendless C.\nAntoine de Saint-Exup\u00e9ry (With edits)\nNote: This chapter is long and goes into a lot of detail. Feel free to gloss over parts with which you have\nexperience in.\nC is the de-facto programming language to do serious system serious programming. Why? Most kernels have\ntheir API accessible through C. The Linux kernel [7]and the XNU kernel [4]of which MacOS is based on are\nwritten in C and have C API - Application Programming Interface. The Windows Kernel uses C ++, but doing\nsystem programming on that is much harder on windows that UNIX for novice system programmers. C doesn\u2019t\nhave abstractions like classes and Resource Acquisition Is Initialization (RAII) to clean up memory . C also gives you\nmuch more of an opportunity to shoot yourself in the foot, but it lets you do things at a much more \ufb01ne-grained\nlevel.\n3.1 History of C\nC was developed by Dennis Ritchie and Ken Thompson at Bell Labs back in 1973 [8]. Back then, we had gems of\nprogramming languages like Fortran, ALGOL, and LISP . The goal of C was two-fold. Firstly , it was made to target\nthe most popular computers at the time, such as the PDP-7. Secondly , it tried to remove some of the lower-level\nconstructs (managing registers, and programming assembly for jumps), and create a language that had the power\nto express programs procedurally (as opposed to mathematically like LISP) with readable code. All this while still\nhaving the ability to interface with the operating system. It sounded like a tough feat. At \ufb01rst, it was only used\ninternally at Bell Labs along with the UNIX operating system.\nThe \ufb01rst \"real\" standardization was with Brian Kernighan and Dennis Ritchie\u2019s book [6]. It is still widely\nregarded today as the only portable set of C instructions. The K&R book is known as the de-facto standard for\nlearning C. There were different standards of C from ANSI to ISO, though ISO largely won out as a language\nspeci\ufb01cation. We will be mainly focusing on is the POSIX C library which extends ISO. Now to get the elephant out\nof the room, the Linux kernel is fails to be POSIX compliant. Mostly , this is so because the Linux developers didn\u2019t\nwant to pay the fee for compliance. It is also because they did not want to be fully compliant with a multitude of\ndifferent standards because that meant increased development costs to maintain compliance.\nWe will aim to use C99, as it is the standard that most computers recognize, but sometimes use some of the\n32", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2620, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "29485d82-043c-42f7-bf1b-5c093797ca72": {"__data__": {"id_": "29485d82-043c-42f7-bf1b-5c093797ca72", "embedding": null, "metadata": {"page_label": "33", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d02311e9-d5bd-4e06-b784-322e73f26c57", "node_type": "4", "metadata": {"page_label": "33", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "06f1f96476c364c5c4b5db16dabe2baf56fa3df9aaa0170b64d5a6a72933dcb9", "class_name": "RelatedNodeInfo"}}, "text": "3.2. CRASH COURSE INTRODUCTION TO C 33\nnewer C11 features. We will also talk about some off-hand features like getline because they are so widely used\nwith the GNU C library . We\u2019ll begin by providing a fairly comprehensive overview of the language with language\nfacilities. Feel free to gloss over if you have already worked with a C based language.\n3.1.1 Features\n\u2022Speed. There is little separating a program and the system.\n\u2022Simplicity . C and its standard library comprise a simple set of portable functions.\n\u2022Manual Memory Management. C gives a program the ability to manage its memory . However, this can be a\ndownside if a program has memory errors.\n\u2022Ubiquity . Through foreign function interfaces (FFI) and language bindings of various types, most other\nlanguages can call C functions and vice versa. The standard library is also everywhere. C has stood the test\nof time as a popular language, and it doesn\u2019t look like it is going anywhere.\n3.2 Crash course introduction to C\nThe canonical way to start learning C is by starting with the hello world program. The original example that\nKernighan and Ritchie proposed way back when hasn\u2019t changed.\n#include <stdio.h >\nint main( void ){\nprintf( \"Hello World \\n\");\nreturn 0;\n}\n1.The #include directive takes the \ufb01le stdio.h (which stands for standardinput and output) located\nsomewhere in your operating system, copies the text, and substitutes it where the #include was.\n2.Theint main(void) is a function declaration. The \ufb01rst word inttells the compiler the return type of the\nfunction. The part before the parenthesis ( main ) is the function name. In C, no two functions can have the\nsame name in a single compiled program, although shared libraries may be able. Then, the parameter list\ncomes after. When we provide the parameter list for regular functions (void) that means that the compiler\nshould produce an error if the function is called with a non-zero number of arguments. For regular functions\nhaving a declaration like void func() means that the function can be called like func(1, 2, 3) , because\nthere is no delimiter. main is a special function. There are many ways of declaring main but the standard\nones are int main(void) ,int main() , and int main(int argc, char *argv[]) .\n3.printf(\"Hello World\"); is what a function call. printf is de\ufb01ned as a part of stdio.h . The function\nhas been compiled and lives somewhere else on our machine - the location of the C standard library . Just\nremember to include the header and call the function with the appropriate parameters (a string literal\n\"Hello World\" ). If the newline isn\u2019t included, the buffer will not be \ufb02ushed (i.e. the write will not complete\nimmediately).", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2685, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9160406c-4317-42de-83bd-b02c29f09cce": {"__data__": {"id_": "9160406c-4317-42de-83bd-b02c29f09cce", "embedding": null, "metadata": {"page_label": "34", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "785d8154-8807-44df-9dd6-af769b07f0aa", "node_type": "4", "metadata": {"page_label": "34", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "09ae936fa9ecc680156c511a72b2c0bac6dc4637f30d2f5af99c10497f5b323a", "class_name": "RelatedNodeInfo"}}, "text": "34 CHAPTER 3. THE C PROGRAMMING LANGUAGE\n4.return 0 .main has to return an integer. By convention, return 0 means success and anything else means\nfailure. Here are some exit codes /statuses with special meaning: http://tldp.org/LDP/abs/html/\nexitcodes.html . In general, assume 0 means success.\n$ gcc main.c -o main\n$ ./main\nHello World\n$\n1.gccis short for the GNU Compiler Collection which has a host of compilers ready for use. The compiler\ninfers from the extension that you are trying to compile a .c \ufb01le.\n2../main tells your shell to execute the program in the current directory called main. The program then\nprints out \"hello world\".\nIf systems programming was as easy as writing hello world though, our jobs would be much easier.\n3.2.1 Preprocessor\nWhat is the preprocessor? Preprocessing is a copy and paste operation that the compiler performs before actually\ncompiling the program. The following is an example of substitution\n//Before preprocessing\n#define MAX_LENGTH 10\nchar buffer[MAX_LENGTH]\n//After preprocessing\nchar buffer[10]\nThere are side effects to the preprocessor though. One problem is that the preprocessor needs to be able\nto tokenize properly , meaning trying to rede\ufb01ne the internals of the C language with a preprocessor may be\nimpossible. Another problem is that they can\u2019t be nested in\ufb01nitely - there is a bounded depth where they need to\nstop. Macros are also simple text substitutions, without semantics. For example, look at what can happen if a\nmacro tries to perform an inline modi\ufb01cation.\n#define min(a,b) a <b ? a : b\nint main() {\nint x = 4 ;\nif(min(x ++, 5)) printf( \"%dissix\", x) ;\nreturn 0;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1632, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d4aa39c5-267b-4fd1-8a78-f250d52223e2": {"__data__": {"id_": "d4aa39c5-267b-4fd1-8a78-f250d52223e2", "embedding": null, "metadata": {"page_label": "35", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c5997d7a-b89d-4b61-8761-2507394e40a0", "node_type": "4", "metadata": {"page_label": "35", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "2a799a5efbe67b9077b62b521b00315c7867b1486554108283dadbb81d048975", "class_name": "RelatedNodeInfo"}}, "text": "3.3. LANGUAGE FACILITIES 35\nMacros are simple text substitution so the above example expands to\nx++<5 ? x ++: 5\nIn this case, it is opaque what gets printed out, but it will be 6. Can you try to \ufb01gure out why? Also, consider\nthe edge case when operator precedence comes into play .\nint x = 99 ;\nint r = 10 + min(99, 100) ;//ris100!\n//This iswhat itisexpanded to\nint r = 10 + 99 <100 ? 99 : 100\n//Which means\nint r = (10 + 99) <100 ? 99 : 100\nThere are also logical problems with the \ufb02exibility of certain parameters. One common source of confusion is\nwith static arrays and the sizeof operator.\n#define ARRAY_LENGTH(A) ( sizeof ((A)) / sizeof ((A)[0]))\nint static_array[10] ;//ARRAY_LENGTH (static_array )=10\nint* dynamic_array = malloc(10) ;//ARRAY_LENGTH (dynamic_array )=2or\n1consistently\nWhat is wrong with the macro? Well, it works if a static array is passed in because sizeof a static array\nreturns the number of bytes that array takes up and dividing it by the sizeof(an_element) would give the\nnumber of entries. But if passed a pointer to a piece of memory , taking the sizeof the pointer and dividing it by\nthe size of the \ufb01rst entry won\u2019t always give us the size of the array .\n3.3 Language Facilities\n3.3.1 Keywords\nC has an assortment of keywords. Here are some constructs that you should know brie\ufb02y as of C99.\n1.break is a keyword that is used in case statements or looping statements. When used in a case statement,\nthe program jumps to the end of the block.\nswitch (1) {\ncase 1:/*Goes tothis switch */", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1519, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "50671a7a-f068-4e5c-a625-50e14bdfb738": {"__data__": {"id_": "50671a7a-f068-4e5c-a625-50e14bdfb738", "embedding": null, "metadata": {"page_label": "36", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "19e93801-918d-4282-9a4b-30cddf48c0da", "node_type": "4", "metadata": {"page_label": "36", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e837e72de4e5621aeff0ee3e2ceb77917dce4ca7e4b94b5c93718431fb009e98", "class_name": "RelatedNodeInfo"}}, "text": "36 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nputs( \"1\");\nbreak ;/*Jumps tothe end ofthe block */\ncase 2:/*Ignores this program */\nputs( \"2\");\nbreak ;\n}/*Continues here */\nIn the context of a loop, using it breaks out of the inner-most loop. The loop can be either a for,while , or\ndo-while construct\nwhile (1) {\nwhile (2) {\nbreak ;/*Breaks out ofwhile (2) */\n}/*Jumps here */\nbreak ;/*Breaks out ofwhile (1) */\n}/*Continues here */\n2.const is a language level construct that tells the compiler that this data should remain constant. If\none tries to change a const variable, the program will fail to compile. const works a little differently\nwhen put before the type, the compiler re-orders the \ufb01rst type and const. Then the compiler uses a left\nassociativity rule. Meaning that whatever is left of the pointer is constant. This is known as const-correctness.\nconst int i = 0 ;//Same as\"int const i=0\"\nchar *str = ... ;//Mutable pointer toamutable string\nconst char *const_str = ... ;//Mutable pointer toaconstant string\nchar const *const_str2 = ... ;//Same asabove\nconst char *const const_ptr_str = ... ;\n//Constant pointer toaconstant string\nBut, it is important to know that this is a compiler imposed restriction only . There are ways of getting\naround this, and the program will run \ufb01ne with de\ufb01ned behavior. In systems programming, the only type of\nmemory that you can\u2019t write to is system write-protected memory .\nconst int i = 0 ;//Same as\"int const i=0\"\n(*(( int *)&i)) = 1 ;//i==1now\nconst char *ptr = \"hi\";\n*ptr = \u2019\\0\u2019;//Will cause aSegmentation Violation", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1561, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "52827f85-7134-4794-b1c0-96a1eb266f2b": {"__data__": {"id_": "52827f85-7134-4794-b1c0-96a1eb266f2b", "embedding": null, "metadata": {"page_label": "37", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0063fd8e-5d1b-4add-8c82-045fe6ff6f3a", "node_type": "4", "metadata": {"page_label": "37", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "37620311ad9faa1d41db69e98d651e3b1078284a6acc319b8d57d945e47489e3", "class_name": "RelatedNodeInfo"}}, "text": "3.3. LANGUAGE FACILITIES 37\n3.continue is a control \ufb02ow statement that exists only in loop constructions. Continue will skip the rest of\nthe loop body and set the program counter back to the start of the loop before.\nint i = 10 ;\nwhile (i--) {\nif(1) continue ;/*This gets triggered */\n*((int *)NULL) = 0 ;\n}/*Then reaches the end ofthe while loop */\n4.do {} while(); is another loop construct. These loops execute the body and then check the condition at\nthe bottom of the loop. If the condition is zero, the next statement is executed \u2013 the program counter is set\nto the \ufb01rst instruction after the loop. Otherwise, the loop body is executed.\nint i = 1 ;\ndo{\nprintf( \"%d\\n\", i--) ;\n}while (i>10) /*Only executed once */\n5.enum is to declare an enumeration. An enumeration is a type that can take on many , \ufb01nite values. If you\nhave an enum and don\u2019t specify any numerics, the C compiler will generate a unique number for that enum\n(within the context of the current enum) and use that for comparisons. The syntax to declare an instance\nof an enum is enum <type> varname . The added bene\ufb01t to this is that the compiler can type check these\nexpressions to make sure that you are only comparing alike types.\nenum day{monday, tuesday, wednesday,\nthursday, friday, saturday, sunday };\nvoid process_day( enum day foo) {\nswitch (foo) {\ncase monday:\nprintf( \"Gohome !\\n\");break ;\n//...\n}\n}\nIt is completely possible to assign enum values to either be different or the same. It is not advisable to rely\non the compiler for consistent numbering, if you assign numbers. If you are going to use this abstraction,\ntry not to break it.\nenum day{", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1631, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6cbfa301-f914-4db1-b2cd-a0e7b3ab8609": {"__data__": {"id_": "6cbfa301-f914-4db1-b2cd-a0e7b3ab8609", "embedding": null, "metadata": {"page_label": "38", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8b50b211-4d4b-4821-a539-16359be8f707", "node_type": "4", "metadata": {"page_label": "38", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "72b0185fe33818159794cec2c280075994e5f082cba8b1c75daa59b5e7467d15", "class_name": "RelatedNodeInfo"}}, "text": "38 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nmonday = 0,\ntuesday = 0,\nwednesday = 0,\nthursday = 1,\nfriday = 10,\nsaturday = 10,\nsunday = 0 };\nvoid process_day( enum day foo) {\nswitch (foo) {\ncase monday:\nprintf( \"Gohome !\\n\");break ;\n//...\n}\n}\n6.extern is a special keyword that tells the compiler that the variable may be de\ufb01ned in another object \ufb01le or\na library , so the program compiles on missing variable because the program will reference a variable in the\nsystem or another \ufb01le.\n//file1 .c\nextern int panic ;\nvoid foo() {\nif(panic) {\nprintf( \"NONONONONO \");\n}else {\nprintf( \"This isfine \");\n}\n}\n//file2 .c\nint panic = 1 ;\n7.foris a keyword that allows you to iterate with an initialization condition, a loop invariant, and an update\ncondition. This is meant to be equivalent to a while loop, but with differing syntax.\nfor (initialization ;check ;update) {\n//...\n}\n//Typically", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 879, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed4c75bb-678b-4403-8321-b02e7953532d": {"__data__": {"id_": "ed4c75bb-678b-4403-8321-b02e7953532d", "embedding": null, "metadata": {"page_label": "39", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "dfd067fe-0603-49d5-a708-cafac975920b", "node_type": "4", "metadata": {"page_label": "39", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "117efb54caad6c288b321a3524dbc0d59f231b3e6b28320518c179817ef17b92", "class_name": "RelatedNodeInfo"}}, "text": "3.3. LANGUAGE FACILITIES 39\nint i;\nfor (i = 0 ;i<10;i++){\n//...\n}\nAs of the C89 standard, one cannot declare variables inside the forloop initialization block. This is because\nthere was a disagreement in the standard for how the scoping rules of a variable de\ufb01ned in the loop would\nwork. It has since been resolved with more recent standards, so people can use the for loop that they know\nand love today\nfor(int i = 0 ;i<10;++i){\nThe order of evaluation for a forloop is as follows\n(a)Perform the initialization statement.\n(b)Check the invariant. If false, terminate the loop and execute the next statement. If true, continue to\nthe body of the loop.\n(c)Perform the body of the loop.\n(d)Perform the update statement.\n(e)Jump to checking the invariant step.\n8.goto is a keyword that allows you to do conditional jumps. Do not use goto in your programs. The reason\nbeing is that it makes your code in\ufb01nitely more hard to understand when strung together with multiple\nchains, which is called spaghetti code. It is acceptable to use in some contexts though, for example, error\nchecking code in the Linux kernel. The keyword is usually used in kernel contexts when adding another\nstack frame for cleanup isn\u2019t a good idea. The canonical example of kernel cleanup is as below.\nvoid setup( void ){\nDoe *deer ;\nRay *drop ;\nMi *myself ;\nif(!setupdoe(deer)) {\ngoto finish ;\n}\nif(!setupray(drop)) {\ngoto cleanupdoe ;\n}\nif(!setupmi(myself)) {\ngoto cleanupray ;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1450, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6898adb5-101b-48d4-a2bb-f0c32f673c96": {"__data__": {"id_": "6898adb5-101b-48d4-a2bb-f0c32f673c96", "embedding": null, "metadata": {"page_label": "40", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c5c165ea-2e69-4106-b490-3e88aa7a6cf1", "node_type": "4", "metadata": {"page_label": "40", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4fdc387f973c28d5c3dc0123037df83d5736a6d80dde9b927381b97093d37d8c", "class_name": "RelatedNodeInfo"}}, "text": "40 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nperform_action(deer, drop, myself) ;\ncleanupray:\ncleanup(drop) ;\ncleanupdoe:\ncleanup(deer) ;\nfinish:\nreturn ;\n}\n9.if else else-if are control \ufb02ow keywords. There are a few ways to use these (1) A bare if (2) An if with\nan else (3) an if with an else-if (4) an if with an else if and else. Note that an else is matched with the most\nrecent if. A subtle bug related to a mismatched if and else statement, is the dangling else problem. The\nstatements are always executed from the if to the else. If any of the intermediate conditions are true, the if\nblock performs that action and goes to the end of that block.\n//(1)\nif(connect(...))\nreturn -1;\n//(2)\nif(connect(...)) {\nexit(-1) ;\n}else {\nprintf( \"Connected !\");\n}\n//(3)\nif(connect(...)) {\nexit(-1) ;\n}else if(bind(..)) {\nexit(-2) ;\n}\n//(1)\nif(connect(...)) {\nexit(-1) ;\n}else if(bind(..)) {\nexit(-2) ;\n}else {\nprintf( \"Successfully bound !\");\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 935, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6c755554-2e0a-4ce0-a45a-b107ac0836db": {"__data__": {"id_": "6c755554-2e0a-4ce0-a45a-b107ac0836db", "embedding": null, "metadata": {"page_label": "41", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3e1357db-0d6c-417a-ac58-5a204ea30351", "node_type": "4", "metadata": {"page_label": "41", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "20a8aa416acb4045176b14cfbc58f4e723efc1d0eca005ee32a7d2709615817a", "class_name": "RelatedNodeInfo"}}, "text": "3.3. LANGUAGE FACILITIES 41\n10.inline is a compiler keyword that tells the compiler it\u2019s okay to omit the C function call procedure and\n\"paste\" the code in the callee. Instead, the compiler is hinted at substituting the function body directly into\nthe calling function. This is not always recommended explicitly as the compiler is usually smart enough to\nknow when to inline a function for you.\ninline int max( int a,int b){\nreturn a<b ? a : b ;\n}\nint main() {\nprintf( \"Max %d\", max(a, b)) ;\n//printf (\"Max %d\",a<b?a:b);\n}\n11.restrict is a keyword that tells the compiler that this particular memory region shouldn\u2019t overlap with all\nother memory regions. The use case for this is to tell users of the program that it is unde\ufb01ned behavior if\nthe memory regions overlap. Note that memcpy has unde\ufb01ned behavior when memory regions overlap. If\nthis might be the case in your program, consider using memmove.\nmemcpy( void * restrict dest, const void * restrict src, size_t\nbytes) ;\nvoid add_array( int *a, int * restrict c) {\n*a += *c ;\n}\nint *a = malloc(3* sizeof (*a)) ;\n*a = 1 ;*a = 2 ;*a = 3 ;\nadd_array(a + 1, a) //Well defined\nadd_array(a, a) //Undefined\n12.return is a control \ufb02ow operator that exits the current function. If the function is void then it simply exits\nthe functions. Otherwise, another parameter follows as the return value.\nvoid process() {\nif(connect(...)) {\nreturn -1;\n}else if(bind(...)) {\nreturn -2\n}\nreturn 0;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1436, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cec21d6f-04e2-474e-ada7-ce40a5410507": {"__data__": {"id_": "cec21d6f-04e2-474e-ada7-ce40a5410507", "embedding": null, "metadata": {"page_label": "42", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bb8cb03c-b84d-45c8-8111-1ea6652c5e10", "node_type": "4", "metadata": {"page_label": "42", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ebd4032091c29589a71b207b2abb15782e458c4a973560f75818cd7f711fc772", "class_name": "RelatedNodeInfo"}}, "text": "42 CHAPTER 3. THE C PROGRAMMING LANGUAGE\n13.signed is a modi\ufb01er which is rarely used, but it forces a type to be signed instead of unsigned. The reason\nthat this is so rarely used is because types are signed by default and need to have the unsigned modi\ufb01er to\nmake them unsigned but it may be useful in cases where you want the compiler to default to a signed type\nsuch as below.\nint count_bits_and_sign( signed representation) {\n//...\n}\n14.sizeof is an operator that is evaluated at compile-time, which evaluates to the number of bytes that the\nexpression contains. When the compiler infers the type the following code changes as follows.\nchar a = 0 ;\nprintf( \"%zu\",sizeof (a++));\nchar a = 0 ;\nprintf( \"%zu\", 1) ;\nWhich then the compiler is allowed to operate on further. The compiler must have a complete de\ufb01nition of\nthe type at compile-time - not link time - or else you may get an odd error. Consider the following\n//file .c\nstruct person ;\nprintf( \"%zu\",sizeof (person)) ;\n//file2 .c\nstruct person {\n//Declarations\n}\nThis code will not compile because sizeof is not able to compile file.c without knowing the full declaration\nof the person struct. That is typically why programmers either put the full declaration in a header \ufb01le or\nwe abstract the creation and the interaction away so that users cannot access the internals of our struct.\nAdditionally , if the compiler knows the full length of an array object, it will use that in the expression instead\nof having it decay into a pointer.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1496, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9ad0da2c-2865-455c-94ef-4ec35f1eb79b": {"__data__": {"id_": "9ad0da2c-2865-455c-94ef-4ec35f1eb79b", "embedding": null, "metadata": {"page_label": "43", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9f9ea3b1-e133-45f9-925b-a881bd94f9bd", "node_type": "4", "metadata": {"page_label": "43", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d21f40d59d29cfb5e9bb946cd06d9815707eb62de94d4e31f828880fae0e6e65", "class_name": "RelatedNodeInfo"}}, "text": "3.3. LANGUAGE FACILITIES 43\nchar str1[] = \"will be11\";\nchar * str2 = \"will be8\";\nsizeof (str1) //11because itisanarray\nsizeof (str2) //8because itisapointer\nBe careful, using sizeof for the length of a string!\n15.static is a type speci\ufb01er with three meanings.\n(a)When used with a global variable or function declaration it means that the scope of the variable or the\nfunction is only limited to the \ufb01le.\n(b)When used with a function variable, that declares that the variable has static allocation \u2013 meaning that\nthe variable is allocated once at program startup not every time the program is run, and its lifetime is\nextended to that of the program.\n//visible tothis file only\nstatic int i = 0 ;\nstatic int _perform_calculation( void ){\n//...\n}\nchar *print_time( void ){\nstatic char buffer[200] ;//Shared every time afunction iscalled\n//...\n}\n16.struct is a keyword that allows you to pair multiple types together into a new structure. C-structs are\ncontiguous regions of memory that one can access speci\ufb01c elements of each memory as if they were separate\nvariables. Note that there might be padding between elements, such that each variable is memory-aligned\n(starts at a memory address that is a multiple of its size).\nstruct hostname {\nconst char *port ;\nconst char *name ;\nconst char *resource ;\n};//You need the semicolon atthe end\n//Assign each individually\nstruct hostname facebook ;\nfacebook.port = \"80\";\nfacebook.name = \"www.google .com\";\nfacebook.resource = \"/\";", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1472, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "75cdd08e-a2e1-4721-8dab-9cf2a00c7b78": {"__data__": {"id_": "75cdd08e-a2e1-4721-8dab-9cf2a00c7b78", "embedding": null, "metadata": {"page_label": "44", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "53956d4c-29dd-4108-9497-1da36dc63c6f", "node_type": "4", "metadata": {"page_label": "44", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4c2d63d3648810ef5c981a87f9e68c6caff79cca7b5d46f9ae27325b2d022bef", "class_name": "RelatedNodeInfo"}}, "text": "44 CHAPTER 3. THE C PROGRAMMING LANGUAGE\n//You can use static initialization inlater versions ofc\nstruct hostname google = {\"80\",\"www.google .com\",\"/\"};\n17.switch case default Switches are essentially glori\ufb01ed jump statements. Meaning that you take either a\nbyte or an integer and the control \ufb02ow of the program jumps to that location. Note that, the various cases\nof a switch statement fall through. It means that if execution starts in one case, the \ufb02ow of control will\ncontinue to all subsequent cases, until a break statement.\nswitch (/*char orint */){\ncase INT1: puts( \"1\");\ncase INT2: puts( \"2\");\ncase INT3: puts( \"3\");\n}\nIf we give a value of 2 then\nswitch (2) {\ncase 1: puts( \"1\");/*Doesn \u2019trun this */\ncase 2: puts( \"2\");/*Runs this */\ncase 3: puts( \"3\");/*Also runs this */\n}\nOne of the more famous examples of this is Duff\u2019s device which allows for loop unrolling. You don\u2019t need to\nunderstand this code for the purposes of this class, but it is fun to look at [2].\nsend(to, from, count)\nregister short *to, *from ;\nregister count ;\n{\nregister n=(count+7)/8 ;\nswitch (count%8) {\ncase 0: do{*to = *from ++;\ncase 7: *to = *from ++;\ncase 6: *to = *from ++;\ncase 5: *to = *from ++;\ncase 4: *to = *from ++;\ncase 3: *to = *from ++;\ncase 2: *to = *from ++;\ncase 1: *to = *from ++;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1284, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "78d91caa-36f4-424a-af48-414b7a4548f5": {"__data__": {"id_": "78d91caa-36f4-424a-af48-414b7a4548f5", "embedding": null, "metadata": {"page_label": "45", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "762165b3-cf30-40a1-9890-05b1bd6a7aa0", "node_type": "4", "metadata": {"page_label": "45", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a58886618f305815db6689b2c6bc77ce6486f792bac9b30a793f78cad5d84ac6", "class_name": "RelatedNodeInfo"}}, "text": "3.3. LANGUAGE FACILITIES 45\n}while (--n >0);\n}\n}\nThis piece of code highlights that switch statements are goto statements, and you can put any code on the\nother end of a switch case. Most of the time it doesn\u2019t make sense, some of the time it just makes too much\nsense.\n18.typedef declares an alias for a type. Often used with structs to reduce the visual clutter of having to write\n\u2018struct\u2019 as part of the type.\ntypedef float real ;\nreal gravity = 10 ;\n//Also typedef gives usanabstraction over the underlying type\nused .\n//Inthe future ,weonly need tochange this typedef ifwe\n//wanted our physics library touse doubles instead offloats .\ntypedef struct link link_t ;\n//With structs ,include the keyword \u2019struct \u2019aspart ofthe\noriginal types\nIn this class, we regularly typedef functions. A typedef for a function can be this for example\ntypedef int (*comparator)( void *,void *);\nint greater_than( void * a, void * b) {\nreturn a>b;\n}\ncomparator gt = greater_than ;\nThis declares a function type comparator that accepts two void* params and returns an integer.\n19.union is a new type speci\ufb01er. A union is one piece of memory that many variables occupy . It is used to\nmaintain consistency while having the \ufb02exibility to switch between types without maintaining functions to\nkeep track of the bits. Consider an example where we have different pixel values.\nunion pixel {\nstruct values {\nchar red;\nchar blue ;\nchar green ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1420, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a66f8708-11b5-4beb-b3fa-ae79a71c16ae": {"__data__": {"id_": "a66f8708-11b5-4beb-b3fa-ae79a71c16ae", "embedding": null, "metadata": {"page_label": "46", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ee687696-8b4d-46fe-858f-496a3d4dda20", "node_type": "4", "metadata": {"page_label": "46", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d07fc6dc79a7a39db8b89764f88f056579daea9ba7221080a750f7f0d9692ba9", "class_name": "RelatedNodeInfo"}}, "text": "46 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nchar alpha ;\n}values ;\nuint32_t encoded ;\n};//Ending semicolon needed\nunion pixel a ;\n//When modifying orreading\na.values.red ;\na.values.blue = 0x0 ;\n//When writing toafile\nfprintf(picture, \"%d\", a.encoded) ;\n20.unsigned is a type modi\ufb01er that forces unsigned behavior in the variables they modify . Unsigned can only\nbe used with primitive int types (like intandlong ). There is a lot of behavior associated with unsigned\narithmetic. For the most part, unless your code involves bit shifting, it isn\u2019t essential to know the difference\nin behavior with regards to unsigned and signed arithmetic.\n21.void is a double meaning keyword. When used in terms of function or parameter de\ufb01nition, it means that\nthe function explicitly returns no value or accepts no parameter, respectively . The following declares a\nfunction that accepts no parameters and returns nothing.\nvoid foo( void );\nThe other use of void is when you are de\ufb01ning an lvalue . Avoid * pointer is just a memory address. It\nis speci\ufb01ed as an incomplete type meaning that you cannot dereference it but it can be promoted to any\ntime to any other type. Pointer arithmetic with this pointer is unde\ufb01ned behavior.\nint *array = void_ptr ;//Nocast needed\n22.volatile is a compiler keyword. This means that the compiler should not optimize its value out. Consider\nthe following simple function.\nint flag = 1 ;\npass_flag(&flag) ;\nwhile (flag) {\n//Dothings unrelated toflag\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1469, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c65d8bcb-eab9-42cb-b1d8-0c910b867f28": {"__data__": {"id_": "c65d8bcb-eab9-42cb-b1d8-0c910b867f28", "embedding": null, "metadata": {"page_label": "47", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d4476196-7a25-4dfb-939c-657bf8852838", "node_type": "4", "metadata": {"page_label": "47", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f085ccefdaeb02bee00e4cb83fb444bc4aad9e98067cc3d7be71159daea96cb0", "class_name": "RelatedNodeInfo"}}, "text": "3.3. LANGUAGE FACILITIES 47\nThe compiler may , since the internals of the while loop have nothing to do with the \ufb02ag, optimize it to the\nfollowing even though a function may alter the data.\nwhile (1) {\n//Dothings unrelated toflag\n}\nIf you use the volatile keyword, the compiler is forced to keep the variable in and perform that check. This\nis useful for cases where you are doing multi-process or multi-threaded programs so that we can affect the\nrunning of one sequence of execution with another.\n23.while represents the traditional while loop. There is a condition at the top of the loop, which is checked\nbefore every execution of the loop body . If the condition evaluates to a non-zero value, the loop body will\nbe run.\n3.3.2 C data types\nThere are many data types in C. As you may realize, all of them are either integers or \ufb02oating point numbers and\nother types are variations of these.\n1.char Represents exactly one byte of data. The number of bits in a byte might vary . unsigned char and\nsigned char are always the same size, which is true for the unsigned andsigned versions of all data\ntypes. This must be aligned on a boundary (meaning you cannot use bits in between two addresses). The\nrest of the types will assume 8 bits in a byte.\n2.short (short int) must be at least two bytes. This is aligned on a two byte boundary , meaning that the\naddress must be divisible by two.\n3.intmust be at least two bytes. Again aligned to a two byte boundary [5, P . 34 ]. On most machines this will\nbe 4 bytes.\n4.long (long int) must be at least four bytes, which are aligned to a four byte boundary . On some machines\nthis can be 8 bytes.\n5.long long must be at least eight bytes, aligned to an eight byte boundary .\n6.float represents an IEEE-754 single precision \ufb02oating point number tightly speci\ufb01ed by IEEE [1]. This will\nbe four bytes aligned to a four byte boundary on most machines.\n7.double represents an IEEE-754 double precision \ufb02oating point number speci\ufb01ed by the same standard,\nwhich is aligned to the nearest eight byte boundary .\nIf you want a \ufb01xed width integer type, for more portable code, you may use the types de\ufb01ned in stdint.h,\nwhich are of the form [u]intwidth _t, where u (which is optional) represents the signedness, and width is any of 8,\n16, 32, and 64.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2283, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "18c5cb38-7dec-441c-aba3-45cd9ae7a57a": {"__data__": {"id_": "18c5cb38-7dec-441c-aba3-45cd9ae7a57a", "embedding": null, "metadata": {"page_label": "48", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8b8b6da9-a36f-440d-90c8-f6434dffb4d2", "node_type": "4", "metadata": {"page_label": "48", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "606d8889904d458fe7dc281f4b3963ba5ab4a5d23ed8a70debb0b8e7a20a0f3b", "class_name": "RelatedNodeInfo"}}, "text": "48 CHAPTER 3. THE C PROGRAMMING LANGUAGE\n3.3.3 Operators\nOperators are language constructs in C that are de\ufb01ned as part of the grammar of the language. These operators\nare listed in order of precedence.\n\u2022[]is the subscript operator. a[n] == *(a + n) where nis a number type and ais a pointer type.\n\u2022->is the structure dereference (or arrow) operator. If you have a pointer to a struct *p, you can use this to\naccess one of its elements. p->element .\n\u2022.is the structure reference operator. If you have an object athen you can access an element a.element .\n\u2022+/-a is the unary plus and minus operator. They either keep or negate the sign, respectively , of the integer\nor \ufb02oat type underneath.\n\u2022*ais the dereference operator. If you have a pointer *p, you can use this to access the element located at\nthis memory address. If you are reading, the return value will be the size of the underlying type. If you are\nwriting, the value will be written with an offset.\n\u2022&ais the address-of operator. This takes an element and returns its address.\n\u2022++is the increment operator. You can use it as a pre\ufb01x or post\ufb01x, meaning that the variable that is being\nincremented can either be before or after the operator. a = 0; ++a == 1 anda = 1; a++ == 0 .\n\u2022\u2013is the decrement operator. This has the same semantics as the increment operator except that it decreases\nthe value of the variable by one.\n\u2022sizeof is the sizeof operator, that is evaluated at the time of compilation. This is also mentioned in the\nkeywords section.\n\u2022a <mop> b where <mop> in {+, -, *, %, /} are the arithmetic binary operators. If the operands are\nboth number types, then the operations are plus, minus, times, modulo, and division respectively . If the left\noperand is a pointer and the right operand is an integer type, then only plus or minus may be used and the\nrules for pointer arithmetic are invoked.\n\u2022\u00bb/\u00abare the bit shift operators. The operand on the right has to be an integer type whose signedness is\nignored unless it is signed negative in which case the behavior is unde\ufb01ned. The operator on the left decides\na lot of semantics. If we are left shifting, there will always be zeros introduced on the right. If we are right\nshifting there are a few different cases\n\u2013If the operand on the left is signed, then the integer is sign-extended. This means that if the number\nhas the sign bit set, then any shift right will introduce ones on the left. If the number does not have\nthe sign bit set, any shift right will introduce zeros on the left.\n\u2013If the operand is unsigned, zeros will be introduced on the left either way .\nunsigned short uns = -127 ;//1111111110000001\nshort sig = 1 ;//0000000000000001\nuns <<2;//1111111000000100\nsig <<2;//0000000000000100\nuns >>2;//0011111111100000\nsig >>2;//0000000000000000", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2775, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f999694d-be96-4621-b713-7e9e15915870": {"__data__": {"id_": "f999694d-be96-4621-b713-7e9e15915870", "embedding": null, "metadata": {"page_label": "49", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6650b649-d903-4435-bf1b-d7a26e61fe86", "node_type": "4", "metadata": {"page_label": "49", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a01bdf4d058799ac7ab64c49cbfbb1199883374d3171efc42e83149bb58d666e", "class_name": "RelatedNodeInfo"}}, "text": "3.4. THE C AND LINUX 49\nNote that shifting by the word size (e.g. by 64 in a 64-bit architecture) results in unde\ufb01ned behavior.\n\u2022<=/>= are the greater than equal to /less than equal to, relational operators. They work as their name\nimplies.\n\u2022</>are the greater than /less than relational operators. They again do as the name implies.\n\u2022==/ = are the equal /not equal to relational operators. They once again do as the name implies.\n\u2022&&is the logical AND operator. If the \ufb01rst operand is zero, the second won\u2019t be evaluated and the expression\nwill evaluate to 0. Otherwise, it yields a 1-0 value of the second operand.\n\u2022||is the logical OR operator. If the \ufb01rst operand is not zero, then second won\u2019t be evaluated and the\nexpression will evaluate to 1. Otherwise, it yields a 1-0 value of the second operand.\n\u2022!is the logical NOT operator. If the operand is zero, then this will return 1. Otherwise, it will return 0.\n\u2022&is the bitwise AND operator. If a bit is set in both operands, it is set in the output. Otherwise, it is not.\n\u2022|is the bitwise OR operator. If a bit is set in either operand, it is set in the output. Otherwise, it is not.\n\u2022 is the bitwise NOT operator. If a bit is set in the input, it will not be set in the output and vice versa.\n\u2022?:is the ternary /conditional operator. You put a boolean condition before the and if it evaluates to\nnon-zero the element before the colon is returned otherwise the element after is. 1 ? a : b == a and\n0 ? a : b == b .\n\u2022a, b is the comma operator. ais evaluated and then bis evaluated and bis returned. In a sequence of\nmultiple statements delimited by commas, all statements are evaluated from left to right, and the right-most\nexpression is returned.\n3.4 The C and Linux\nUp until this point, we\u2019ve covered C\u2019s language fundamentals. We\u2019ll now be focusing our attention to C and the\nPOSIX variety of functions available to us to interact with the operating systems. We will talk about portable\nfunctions, for example fwrite printf . We will be evaluating the internals and scrutinizing them under the POSIX\nmodels and more speci\ufb01cally GNU /Linux. There are several things to that philosophy that makes the rest of this\neasier to know, so we\u2019ll put those things here.\n3.4.1 Everything is a \ufb01le\nOne POSIX mantra is that everything is a \ufb01le. Although that has become recently outdated, and moreover wrong,\nit is the convention we still use today . What this statement means is that everything is a \ufb01le descriptor, which is\nan integer. For example, here is a \ufb01le object, a network socket, and a kernel object. These are all references to\nrecords in the kernel\u2019s \ufb01le descriptor table.\nint file_fd = open(...) ;\nint network_fd = socket(...) ;\nint kernel_fd = epoll_create1(...) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2726, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "771bdba7-42f5-452b-83a1-2ee8b27882df": {"__data__": {"id_": "771bdba7-42f5-452b-83a1-2ee8b27882df", "embedding": null, "metadata": {"page_label": "50", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c2fd7088-d6e0-430a-babd-5f72b6b5aa9d", "node_type": "4", "metadata": {"page_label": "50", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "774cfbeb08d75eb171be920e47af1f54ad02db5668872e7c4ce53ff5a4d14eb2", "class_name": "RelatedNodeInfo"}}, "text": "50 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nAnd operations on those objects are done through system calls. One last thing to note before we move on is\nthat the \ufb01le descriptors are merely pointers . Imagine that each of the \ufb01le descriptors in the example actually refers\nto an entry in a table of objects that the operating system picks and chooses from (that is, the \ufb01le descriptor table).\nObjects can be allocated and deallocated, closed and opened, etc. The program interacts with these objects by\nusing the API speci\ufb01ed through system calls, and library functions.\n3.4.2 System Calls\nBefore we dive into common C functions, we need to know what a system call is. If you are a student and have\ncompleted HW0, feel free to gloss over this section.\nA system call is an operation that the kernel carries out. First, the operating system prepares a system call.\nNext, the kernel executes the system call to the best of its ability in kernel space and is a privileged operation.\nIn the previous example, we got access to a \ufb01le descriptor object. We can now also write some bytes to the \ufb01le\ndescriptor object that represents a \ufb01le, and the operating system will do its best to get the bytes written to the disk.\nwrite(file_fd, \"Hello !\", 6) ;\nWhen we say the kernel tries its best, this includes the possibility that the operation could fail for several\nreasons. Some of them are: the \ufb01le is no longer valid, the hard drive failed, the system was interrupted etc. The\nway that a programmer communicates with the outside system is with system calls. An important thing to note is\nthat system calls are expensive. Their cost in terms of time and CPU cycles has recently been decreased, but try to\nuse them as sparingly as possible.\n3.4.3 C System Calls\nMany C functions that will be discussed in the next sections are abstractions that call the correct underlying\nsystem call, based on the current platform. Their Windows implementation, for example, may be entirely different\nfrom that of other operating systems. Nevertheless, we will be studying these in the context of their Linux\nimplementation.\n3.5 Common C Functions\nTo \ufb01nd more information about any functions, please use the man pages. Note the man pages are organized into\nsections. Section 2 are System calls. Section 3 are C libraries. On the web, Google man 7 open . In the shell,\nman -S2 open orman -S3 printf\n3.5.1 Handling Errors\nBefore we get into the nitty gritty of all the functions, know that most functions in C handle errors return oriented.\nThis is at odds with programming languages like C ++or Java where the errors are handled with exceptions.\nThere are a number of arguments against exceptions.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2663, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cc68e32d-5c6b-4472-842a-71495f0bfcc1": {"__data__": {"id_": "cc68e32d-5c6b-4472-842a-71495f0bfcc1", "embedding": null, "metadata": {"page_label": "51", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e690c4d2-8baf-4595-9640-e564cc8d472b", "node_type": "4", "metadata": {"page_label": "51", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9d96ac753a5ea2a76e1b57cddfc170a8540432405fdf8c13ed26bf31b1e26ddb", "class_name": "RelatedNodeInfo"}}, "text": "3.5. COMMON C FUNCTIONS 51\n1.Exceptions make control \ufb02ow harder to understand.\n2.Exception oriented languages need to keep stack traces and maintain jump tables.\n3.Exceptions may be complex objects.\nThere are a few arguments for exceptions as well\n1.Exceptions can come from several layers deep.\n2.Exceptions help reduce global state.\n3.Exceptions differentiate business logic and normal \ufb02ow.\nWhatever the pros /cons are, we use the former because of backwards compatibility with languages like\nFORTRAN [3, P . 84 ]. Each thread will get a copy of errno because it is stored at the top of each thread\u2019s stack \u2013\nmore on threads later. One makes a call to a function that could return an error and if that function returns an\nerror according to the man pages, it is up to the programmer to check errno.\n#include <errno.h >\nFILE *f = fopen( \"/does /not/exist .txt\",\"r\");\nif(NULL == f) {\nfprintf(stderr, \"Errno is%d\\n\", errno) ;\nfprintf(stderr, \"Description is%s\\n\", strerror(errno)) ;\n}\nThere is a shortcut function perror that prints the english description of errno. Also, a function may return\nthe error code in the return value itself.\nint s = getnameinfo(...) ;\nif(0 != s) {\nfprintf(stderr, \"getnameinfo :%s\\n\", gai_strerror(s)) ;\n}\nBe sure to check the man page for return code characteristics.\n3.5.2 Input /Output\nIn this section we will cover all the basic input and output functions in the standard library with references to\nsystem calls. Every process has three streams of data when it starts execution: standard input (for program input),\nstandard output (for program output), and standard error (for error and debug messages). Usually , standard\ninput is sourced from the terminal in which the program is being run in, and standard out is the same terminal.\nHowever, a programmer can use redirection such that their program can send output and /or receive input, to and\nfrom a \ufb01le, or other programs.\nThey are designated by the \ufb01le descriptors 0 and 1 respectively . 2 is reserved for standard error which by\nlibrary convention is unbuffered (i.e. IO operations are performed immediately).", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2099, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d21cfd19-30ba-4210-b470-b9bccf74f1cf": {"__data__": {"id_": "d21cfd19-30ba-4210-b470-b9bccf74f1cf", "embedding": null, "metadata": {"page_label": "52", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "05747e15-8e37-488f-9692-e33ef86e8ce0", "node_type": "4", "metadata": {"page_label": "52", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d963dd4e2f0385d2029db13d1c91450b372c354b3c69bb13736eb4013a4508f3", "class_name": "RelatedNodeInfo"}}, "text": "52 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nstdout oriented streams\nStandard output or stdout oriented streams are streams whose only options are to write to stdout. printf is the\nfunction with which most people are familiar in this category . The \ufb01rst parameter is a format string that includes\nplaceholders for the data to be printed. Common format speci\ufb01ers are the following\n1.%streat the argument as a c string pointer, keep printing all characters until the NULL-character is reached\n2.%dprints the argument as an integer\n3.%pprint the argument as a memory address.\nFor performance, printf buffers data until its cache is full or a newline is printed. Here is an example of printing\nthings out.\nchar *name = ... ;int score = ... ;\nprintf( \"Hello %s,your result is%d\\n\", name, score) ;\nprintf( \"Debug :The string and int are stored at:%pand %p\\n\", name,\n&score ) ;\n//name already isachar pointer and points tothe start ofthe array .\n//Weneed \"&\" toget the address ofthe int variable\nFrom the previous section, printf calls the system call write .printf is a C library function, while write is\na system call system.\nThe buffering semantics of printf is a little complicated. ISO de\ufb01nes three types of streams [5, P . 278 ]\n\u2022Unbuffered, where the contents of the stream reach their destination as soon as possible.\n\u2022Line Buffered, where the contents of the stream reach their destination as soon as a newline is provided.\n\u2022Fully Buffered, where the contents of the stream reach their destination as soon as the buffer is full.\nStandard Error is de\ufb01ned as \u201cnot fully buffered\u201d [5, P . 279 ]. Standard Output and Input are merely de\ufb01ned to\nbe fully buffered if and only if the stream destination is not an interactive device. Usually , standard error will be\nunbuffered, standard input and output will be line buffered if the output is a terminal otherwise fully buffered.\nThis relates to printf because printf merely uses the abstraction provided by the FILE interface and uses the above\nsemantics to determine when to write. One can force a write by calling f\ufb02ush() on the stream.\nTo print strings and single characters, use puts(char *name ) andputchar(char c )\nputs( \"Current selection :\");\nputchar( \u20191\u2019);\nOther streams\nTo print to other \ufb01le streams, use fprintf( _file_ , \"Hello %s, score: %d\", name, score); Where\n_\ufb01le_ is either prede\ufb01ned (\u2018stdout\u2019 or \u2018stderr\u2019) or a FILE pointer that was returned by fopen orfdopen . There is a\nprintf equivalent that works with \ufb01le descriptors, called dprintf. Just use dprintf(int fd, char* format_string, ...); .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2554, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "17c3ea39-de87-4f56-817f-5ce8e3cd8248": {"__data__": {"id_": "17c3ea39-de87-4f56-817f-5ce8e3cd8248", "embedding": null, "metadata": {"page_label": "53", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "69f5ee2e-4e66-47ca-8e65-dc1010d73b0b", "node_type": "4", "metadata": {"page_label": "53", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "157fd406cf0d42e685ab07de00f83661065925835dc5a90774e3f0cf286f7c8f", "class_name": "RelatedNodeInfo"}}, "text": "3.5. COMMON C FUNCTIONS 53\nTo print data into a C string, use sprintf or better snprintf .snprintf returns the number of characters\nwritten excluding the terminating byte. We would use sprintf the size of the printed string is less than the\nprovided buffer \u2013 think about printing an integer, it will never be more than 11 characters with the NUL byte. If\nprintf is dealing with variadic input, it is safer to use the former function as shown in the following snippet.\n//Fixed\nchar int_string[20] ;\nsprintf(int_string, \"%d\", integer) ;\n//Variable length\nchar result[200] ;\nint len = snprintf(result, sizeof (result), \"%s:%d\", name, score) ;\n3.5.3 stdin oriented functions\nStandard input or stdin oriented functions read from stdin directly . Most of these functions have been deprecated\ndue to them being poorly designed. These functions treat stdin as a \ufb01le from which we can read bytes. One of\nthe most notorious offenders is gets .gets is deprecated in C99 standard and has been removed from the latest\nC standard (C11). The reason that it was deprecated was that there is no way to control the length being read,\ntherefore buffers could get overrun easily . When this is done maliciously to hijack program control \ufb02ow, this is\nknown as a buffer over\ufb02ow.\nPrograms should use fgets orgetline instead. Here is a quick example of reading at most 10 characters\nfrom standard input.\nchar *fgets ( char *str, int num, FILE *stream) ;\nssize_t getline( char **lineptr, size_t *n, FILE *stream) ;\n//Example ,the following will not read more than 9chars\nchar buffer[10] ;\nchar *result = fgets(buffer, sizeof (buffer), stdin) ;\nNote that, unlike gets ,fgets copies the newline into the buffer. On the other hand, one of the advantages of\ngetline is that will automatically allocate and reallocate a buffer on the heap of suf\ufb01cient size.\n//ssize_t getline (char **lineptr ,size_t *n,FILE *stream );\n/*set buffer and size to0;they will bechanged bygetline */\nchar *buffer = NULL ;\nsize_t size = 0 ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1987, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7b5bf126-0a4e-49f3-80b4-530f7ec84131": {"__data__": {"id_": "7b5bf126-0a4e-49f3-80b4-530f7ec84131", "embedding": null, "metadata": {"page_label": "54", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "33ad6aa0-b2ef-4e06-b5df-a26aeb760b34", "node_type": "4", "metadata": {"page_label": "54", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3c861d510a4bbc7be6ddde928c4af715d0b394f23b17a3084e4a70899023af01", "class_name": "RelatedNodeInfo"}}, "text": "54 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nssize_t chars = getline(&buffer, &size, stdin) ;\n//Discard newline character ifitispresent ,\nif(chars >0 && buffer[chars-1] == \u2019\\n\u2019)\nbuffer[chars-1] = \u2019\\0\u2019;\n//Read another line .\n//The existing buffer will bere-used ,or,ifnecessary ,\n//Itwill be\u2018free \u2018\u2019dand anew larger buffer will \u2018malloc \u2018\u2019d\nchars = getline(&buffer, &size, stdin) ;\n//Later ... don\u2019tforget tofree the buffer !\nfree(buffer) ;\nIn addition to those functions, we have perror that has a two-fold meaning. Let\u2019s say that a function call\nfailed using the errno convention. perror(const char* message) will print the English version of the error to\nstderr.\nint main() {\nint ret = open( \"IDoNotExist .txt\", O_RDONLY) ;\nif(ret <0){\nperror( \"Opening IDoNotExist :\");\n}\n//...\nreturn 0;\n}\nTo have a library function parse input in addition to reading it, use scanf (orfscanf orsscanf ) to get input\nfrom the default input stream, an arbitrary \ufb01le stream or a C string, respectively . All of those functions will return\nhow many items were parsed. It is a good idea to check if the number is equal to the amount expected. Also\nnaturally like printf ,scanf functions require valid pointers. Instead of pointing to valid memory , they need to\nalso be writable. It\u2019s a common source of error to pass in an incorrect pointer value. For example,\nint *data = malloc( sizeof (int));\nchar *line = \"v10\";\nchar type ;\n//Good practice :Check scanf parsed the line and read two values :\nint ok = 2 == sscanf(line, \"%c%d\", &type, &data) ;//pointer error\nWe wanted to write the character value into c and the integer value into the malloc\u2019d memory . However, we\npassed the address of the data pointer, not what the pointer is pointing to! So sscanf will change the pointer\nitself. The pointer will now point to address 10 so this code will later fail when free(data) is called.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1860, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fe5af126-fb62-46be-b02d-10ea2f80b1f5": {"__data__": {"id_": "fe5af126-fb62-46be-b02d-10ea2f80b1f5", "embedding": null, "metadata": {"page_label": "55", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5be53cfa-ce6c-4f79-b84e-0144051b36df", "node_type": "4", "metadata": {"page_label": "55", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9832d21da0b04f6bb466bae7d39aaae1a8000feaede8d914eea33b4b0357873a", "class_name": "RelatedNodeInfo"}}, "text": "3.5. COMMON C FUNCTIONS 55\nNow, scanf will keep reading characters until the string ends. To stop scanf from causing a buffer over\ufb02ow, use\na format speci\ufb01er. Make sure to pass one less than the size of the buffer.\nchar buffer[10] ;\nscanf( \"%9s\", buffer) ;//reads upto9characters from input (leave\nroom for the 10thbyte tobethe terminating byte )\nOne last thing to note is if system calls are expensive, the scanf family is much more expensive due to\ncompatibility reasons. Since it needs to be able to process all of the printf speci\ufb01ers correctly , the code isn\u2019t\nef\ufb01cient TODO: citation needed . For highly performant programs, one should write the parsing themselves. If it is\na one-off program or script, feel free to use scanf.\n3.5.4 string.h\nString.h functions are a series of functions that deal with how to manipulate and check pieces of memory . Most of\nthem deal with C-strings. A C-string is a series of bytes delimited by a NUL character which is equal to the byte\n0x00. More information about all of these functions. Any behavior missing from the documentation, such as the\nresult of strlen(NULL) is considered unde\ufb01ned behavior.\n\u2022int strlen(const char *s) returns the length of the string.\n\u2022int strcmp(const char *s1, const char *s2) returns an integer determining the lexicographic order\nof the strings. If s1 where to come before s2 in a dictionary , then a -1 is returned. If the two strings are\nequal, then 0. Else, 1.\n\u2022char *strcpy(char *dest, const char *src) Copies the string at src todest .This function as-\nsumes dest has enough space for src otherwise unde\ufb01ned behavior\n\u2022char *strcat(char *dest, const char *src) Concatenates the string at srcto the end of destination.\nThis function assumes that there is enough space for srcat the end of destination including the NUL\nbyte\n\u2022char *strdup(const char *dest) Returns a malloc \u2019d copy of the string.\n\u2022char *strchr(const char *haystack, int needle) Returns a pointer to the \ufb01rst occurrence of needle\nin the haystack . If none found, NULL is returned.\n\u2022char *strstr(const char *haystack, const char *needle) Same as above but this time a string!\n\u2022char *strtok(const char *str, const char *delims)\nA dangerous but useful function strtok takes a string and tokenizes it. Meaning that it will transform the\nstrings into separate strings. This function has a lot of specs so please read the man pages a contrived\nexample is below.\n#include <stdio.h >\n#include <string.h >", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2437, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f1c16bba-8c7c-4ed8-a837-b52c8d2686ff": {"__data__": {"id_": "f1c16bba-8c7c-4ed8-a837-b52c8d2686ff", "embedding": null, "metadata": {"page_label": "56", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "48e829f2-6f0b-40bc-91e3-d3e60df8dbf2", "node_type": "4", "metadata": {"page_label": "56", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c0799397e21b94812d79fa80e3a2ef3a4c77ac080ade261120ef43289a6ed058", "class_name": "RelatedNodeInfo"}}, "text": "56 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nint main() {\nchar * upped = strdup( \"strtok ,is,tricky ,!!\");\nchar * start = strtok(upped, \",\");\ndo{\nprintf( \"%s\\n\", start) ;\n}while ((start = strtok(NULL, \",\")));\nreturn 0;\n}\nOutput\nstrtok\nis\ntricky\n!!\nWhy is it tricky? Well what happens when upped is changed to the following?\nchar * upped = strdup( \"strtok ,is,tricky ,,,!! \");\n\u2022For integer parsing use long int strtol(const char *nptr, char **endptr, int base); orlong long int strtoll(const char *nptr, char **endptr, int base); .\nWhat these functions do is take the pointer to your string *nptr and a base (i.e. binary , octal, decimal,\nhexadecimal etc) and an optional pointer endptr and returns a parsed value.\nint main() {\nconst char *nptr = \"1A2436 \";\nchar * endptr ;\nlong int result = strtol(nptr, &endptr, 16) ;\nreturn 0;\n}\nBe careful though! Error handling is tricky because the function won\u2019t return an error code. If passed an\ninvalid number string, it will return 0. The caller has to be careful from a valid 0 and an error. This often\ninvolves an errno trampoline as shown below.\nint main() {\nconst char *input = \"0\";//or\"!## @\"or\"\"\nchar * endptr ;\nint saved_errno = errno ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1182, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "078ab933-ead9-4998-87c8-74150d9ed248": {"__data__": {"id_": "078ab933-ead9-4998-87c8-74150d9ed248", "embedding": null, "metadata": {"page_label": "57", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7359bfb4-f319-4cec-9fa4-5ff20b7d1356", "node_type": "4", "metadata": {"page_label": "57", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "52094c64703096c325a12866ae261b66e7ad05d0ef56977ed541ca459c9d337d", "class_name": "RelatedNodeInfo"}}, "text": "3.6. C MEMORY MODEL 57\nerrno = 0\nlong int parsed = strtol(input, &endptr, 10) ;\nif(parsed == 0 && errno != 0) {\n//Definitely anerror\n}\nerrno = saved_errno ;\nreturn 0;\n}\n\u2022void *memcpy(void *dest, const void *src, size_t n) moves nbytes starting at srctodest .Be\ncareful , there is unde\ufb01ned behavior when the memory regions overlap. This is one of the classic \"This\nworks on my machine!\" examples because many times Valgrind won\u2019t be able to pick it up because it will\nlook like it works on your machine. Consider the safer version memmove .\n\u2022void *memmove(void *dest, const void *src, size_t n) does the same thing as above, but if the\nmemory regions overlap then it is guaranteed that all the bytes will get copied over correctly . memcpy and\nmemmove both in string.h ?\n3.6 C Memory Model\nThe C memory model is probably unlike most that you\u2019ve seen before. Instead of allocating an object with type\nsafety , we either use an automatic variable or request a sequence of bytes with malloc or another family member\nand later we free it.\n3.6.1 Structs\nIn low-level terms, a struct is a piece of contiguous memory , nothing more. Just like an array , a struct has enough\nspace to keep all of its members. But unlike an array , it can store different types. Consider the contact struct\ndeclared above.\nstruct contact {\nchar firstname[20] ;\nchar lastname[20] ;\nunsigned int phone ;\n};\nstruct contact person ;\nWe will often use the following typedef, so we can write use the struct name as the full type.\ntypedef struct contact contact ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1529, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "245ce618-bd18-478c-bfcf-18d9555140ee": {"__data__": {"id_": "245ce618-bd18-478c-bfcf-18d9555140ee", "embedding": null, "metadata": {"page_label": "58", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7a7b53a5-e10b-4db9-b62a-a4fb8e73c083", "node_type": "4", "metadata": {"page_label": "58", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6f4d1008e9783edd8ab468d0556eeec3806c3a6f3a02751cde42c0a132d953fa", "class_name": "RelatedNodeInfo"}}, "text": "58 CHAPTER 3. THE C PROGRAMMING LANGUAGE\ncontact person ;\ntypedef struct optional_name {\n...\n}contact ;\nIf you compile the code without any optimizations and reordering, you can expect the addresses of each of the\nvariables to look like this.\n&person //0x100\n&person.firstname //0x100 =0x100 +0x00\n&person.lastname //0x114 =0x100 +0x14\n&person.phone //0x128 =0x100 +0x28\nAll your compiler does is say \"reserve this much space\". Whenever a read or write occurs in the code, the\ncompiler will calculate the offsets of the variable. The offsets are where the variable starts at. The phone variables\nstarts at the 0x128 th bytes and continues for sizeof(int) bytes with this compiler. Offsets don\u2019t determine where\nthe variable ends though . Consider the following hack seen in a lot of kernel code.\ntypedef struct {\nint length ;\nchar c_str[0] ;\n}string ;\nconst char * to_convert = \"person \";\nint length = strlen(to_convert) ;\n//Let\u2019sconvert toacstring\nstring* person ;\nperson = malloc( sizeof (string) + length+1) ;\nCurrently , our memory looks like the following image. There is nothing in those boxes\nFigure 3.1: Struct pointing to 11 empty boxes", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1145, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec653924-a576-4a59-876d-4057a73f9878": {"__data__": {"id_": "ec653924-a576-4a59-876d-4057a73f9878", "embedding": null, "metadata": {"page_label": "59", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5f40c19d-e13d-4ecd-84ca-53b30f4ca2b1", "node_type": "4", "metadata": {"page_label": "59", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6c3f41af35be143a89b9adb311fad84f2772dafccfbfa944f0f64ecaaa11dcda", "class_name": "RelatedNodeInfo"}}, "text": "3.6. C MEMORY MODEL 59\nSo what happens when we assign length? The \ufb01rst four boxes are \ufb01lled with the value of the variable at length.\nThe rest of the space is left untouched. We will assume that our machine is big endian. This means that the least\nsigni\ufb01cant byte is last.\nperson- >length = length ;\nFigure 3.2: Struct pointing to 11 boxes, 4 \ufb01lled with 0006, 7 junk\nNow, we can write a string to the end of our struct with the following call.\nm\nstrcpy(person- >c_str, to_convert) ;\nFigure 3.3: Struct pointing to 11 boxes, 4 \ufb01lled with 0006, 7 the stirng \u201cperson\u201d\nWe can even do a sanity check to make sure that the strings are equal.\nm\nstrcmp(person- >c_str, \"person \") == 0 //The strings are equal !\nWhat that zero length array does is point to the end of the struct this means that the compiler will leave room\nfor all of the elements calculated with respect to their size on the operating system (ints, chars, etc). The zero\nlength array will take up no bytes of space. Since structs are continuous pieces of memory , we can allocate more\nspace than required and use the extra space as a place to store extra bytes. Although this seems like a parlor trick,\nit is an important optimization because to have a variable length string any other way , one would need to have\ntwo different memory allocation calls. This is highly inef\ufb01cient for doing something as common in programming\nas is string manipulation.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1410, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "83a94922-b1cc-45de-beb0-b4060a4b1005": {"__data__": {"id_": "83a94922-b1cc-45de-beb0-b4060a4b1005", "embedding": null, "metadata": {"page_label": "60", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "04f47935-4eb2-413c-a396-3ee88762431a", "node_type": "4", "metadata": {"page_label": "60", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "116d1f58661e0ab8e009877a595d2689f106503775b5308cf011a87060013848", "class_name": "RelatedNodeInfo"}}, "text": "60 CHAPTER 3. THE C PROGRAMMING LANGUAGE\n3.6.2 Strings in C\nIn C, we have Null Terminated strings rather than Length Pre\ufb01xed for historical reasons. For everyday programmers,\nremember to NUL terminate your string! A string in C is de\ufb01ned as a bunch of bytes ended by \u2018\u2019 or the NUL Byte.\n3.6.3 Places for strings\nWhenever you de\ufb01ne a string literal - one in the form char* str = \"constant\" \u2013 that string is stored in the\ndata section. Depending on your architecture, it is read-only , meaning that any attempt to modify the string will\ncause a SEGFAULT . One can also declare strings to be either in the writable data segment or the stack. To do\nso, specify a length for the string or put brackets instead of a pointer char str[] = \"mutable\" and put in the\nglobal scope or the function scope for the data segment or the stack respectively . If one, however, malloc \u2019s space,\none can change that string to be whatever they want. Forgetting to NUL terminate a string has a big effect on the\nstrings! Bounds checking is important. The heartbleed bug mentioned earlier in the book is partially because of\nthis.\nStrings in C are represented as characters in memory . The end of the string includes a NUL (0) byte. So \"ABC\"\nrequires four(4) bytes. The only way to \ufb01nd out the length of a C string is to keep reading memory until you \ufb01nd\nthe NUL byte. C characters are always exactly one byte each.\nString literals are constant\nA string literal is naturally constant. Any write will cause the operating system to produce a SEGFAULT .\nchar array[] = \"Hi!\";//array contains amutable copy\nstrcpy(array, \"OK\");\nchar *ptr = \"Can\u2019tchange me\";//ptr points tosome immutable memory\nstrcpy(ptr, \"Will not work \");\nString literals are character arrays stored in the read-only data segment of the program, which is immutable.\nTwo string literals may share the same space in memory . An example follows.\nchar *str1 = \"Mark Twain likes books \";\nchar *str2 = \"Mark Twain likes books \";\nThe strings pointed to by str1 andstr2 may actually reside in the same location in memory .\nChar arrays, however, contain the literal value which has been copied from the code segment into either the\nstack or static memory . These following char arrays reside in different memory locations.\nchar arr1[] = \"Mark Twain also likes towrite \";\nchar arr2[] = \"Mark Twain also likes towrite \";\nHere are some common ways to initialize a string include. Where do they reside in memory?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2439, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8af00d5c-5958-418e-9a32-f9ab00c63441": {"__data__": {"id_": "8af00d5c-5958-418e-9a32-f9ab00c63441", "embedding": null, "metadata": {"page_label": "61", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9abc826b-aaac-4f70-92e4-56573e5d8295", "node_type": "4", "metadata": {"page_label": "61", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "0abb5248bfc97c982f66c6f4a57823c2d981e7493efd93deb6e151ce2a2966d6", "class_name": "RelatedNodeInfo"}}, "text": "3.6. C MEMORY MODEL 61\nchar *str = \"ABC\";\nchar str[] = \"ABC\";\nchar str[]= {\u2019A\u2019,\u2019B\u2019,\u2019C\u2019,\u2019\\0\u2019};\nchar ary[] = \"Hello \";\nchar *ptr = \"Hello \";\nWe can also print out the pointer and the contents of a C-string easily . Here is some boilerplate code to\nillustrate this.\nchar ary[] = \"Hello \";\nchar *ptr = \"Hello \";\n//Print out address and contents\nprintf( \"%p:%s\\n\", ary, ary) ;\nprintf( \"%p:%s\\n\", ptr, ptr) ;\nAs mentioned before, the char array is mutable, so we can change its contents. Be careful to write within\nthe bounds of the array . C does notdo bounds checking at compile-time, but invalid reads /writes can get your\nprogram to crash.\nstrcpy(ary, \"World \");//OK\nstrcpy(ptr, \"World \");//NOT OK-Segmentation fault (crashes by\ndefault ;unless SIGSEGV isblocked )\nUnlike the array , however, we can change ptrto point to another piece of memory ,\nptr = \"World \";//OK!\nptr = ary ;//OK!\nary = \"World \";//NOwon\u2019tcompile\n//ary isdoomed toalways refer tothe original array .\nprintf( \"%p:%s\\n\", ptr, ptr) ;\nstrcpy(ptr, \"World \");//OKbecause now ptr ispointing tomutable\nmemory (the array )\nUnlike pointers, that hold addresses to variables on the heap, or stack, char arrays (string literals) point to\nread-only memory located in the data section of the program. This means that pointers are more \ufb02exible than\narrays, even though the name of an array is a pointer to its starting address.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1381, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e28efa31-8a17-46a2-a1e2-37f4d0a73cf0": {"__data__": {"id_": "e28efa31-8a17-46a2-a1e2-37f4d0a73cf0", "embedding": null, "metadata": {"page_label": "62", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bf77a913-0cbd-4f71-b224-5f9c204e497b", "node_type": "4", "metadata": {"page_label": "62", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ed4e834fac535014088f36bebb2fb2da9e569d69c8bae8696212a7da3ec23edc", "class_name": "RelatedNodeInfo"}}, "text": "62 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nIn a more common case, pointers will point to heap memory in which case the memory referred to by the\npointer canbe modi\ufb01ed.\n3.7 Pointers\nPointers are variables that hold addresses. These addresses have a numeric value, but usually , programmers are\ninterested in the value of the contents at that memory address. In this section, we will try to take you through a\nbasic introduction to pointers.\n3.7.1 Pointer Basics\nDeclaring a Pointer\nA pointer refers to a memory address. The type of the pointer is useful \u2013 it tells the compiler how many bytes\nneed to be read /written and delineates the semantics for pointer arithmetic (addition and subtraction).\nint *ptr1 ;\nchar *ptr2 ;\nDue to C\u2019s syntax, an int* or any pointer is not actually its own type. You have to precede each pointer\nvariable with an asterisk. As a common gotcha, the following\nint* ptr3, ptr4 ;\nWill only declare *ptr3 as a pointer. ptr4 will actually be a regular int variable. To \ufb01x this declaration, ensure\nthe*precedes the pointer.\nint *ptr3, *ptr4 ;\nKeep this in mind for structs as well. If one declares without a typedef, then the pointer goes after the type.\nstruct person *ptr3 ;\nReading /Writing with pointers\nLet\u2019s say that int *ptr was declared. For the sake of discussion, let us assume that ptrcontains the memory\naddress 0x1000 . To write to the pointer, it must be dereferenced and assigned a value.\n*ptr = 0 ;//Writes some memory .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1457, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ccea796f-fc4e-4228-9eae-6e4a61c8f2e2": {"__data__": {"id_": "ccea796f-fc4e-4228-9eae-6e4a61c8f2e2", "embedding": null, "metadata": {"page_label": "63", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d8697d45-c8d6-46b2-81b4-061c436099d9", "node_type": "4", "metadata": {"page_label": "63", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "88194ccee2fdf140a595bd0b64c979c8cd55ee673367a7b71159ead144df1832", "class_name": "RelatedNodeInfo"}}, "text": "3.7. POINTERS 63\nWhat C does is take the type of the pointer which is an intand write sizeof(int) bytes from the start of\nthe pointer, meaning that bytes 0x1000 ,0x1001 ,0x1002 ,0x1003 will all be zero. The number of bytes written\ndepends on the pointer type. It is the same for all primitive types but structs are a little different.\nReading works roughly the same way , except you put the variable in the spot that it needs the value.\nint doubled = *ptr * 2 ;\nReading and writing to non-primitive types gets tricky . The compilation unit - usually the \ufb01le or a header -\nneeds to have the size of the data structure readily available. This means that opaque data structures can\u2019t be\ncopied. Here is an example of assigning a struct pointer:\n#include <stdio.h >\ntypedef struct {\nint a1;\nint a2;\n}pair ;\nint main() {\npair obj ;\npair zeros ;\nzeros.a1 = 0 ;\nzeros.a2 = 0 ;\npair *ptr = &obj ;\nobj.a1 = 1 ;\nobj.a2 = 2 ;\n*ptr = zeros ;\nprintf( \"a1:%d,a2:%d\\n\", ptr- >a1, ptr- >a2);\nreturn 0;\n}\nAs for reading structure pointers, don\u2019t do it directly . Instead, programmers create abstractions for creating,\ncopying, and destroying structs. If this sounds familiar, it is what C ++originally intended to do before the\nstandards committee went off the deep end.\n3.7.2 Pointer Arithmetic\nIn addition to adding to an integer, pointers can be added to. However, the pointer type is used to determine how\nmuch to increment the pointer. A pointer is moved over by the value added times the size of the underlying type.\nFor char pointers, this is trivial because characters are always one byte.\nchar *ptr = \"Hello \";//ptr holds the memory location of\u2019H\u2019\nptr += 2 ;//ptr now points tothe first \u2019l\u2019\u2019", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1683, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2cf8df8a-dffc-4088-94a1-fe1daed08f1b": {"__data__": {"id_": "2cf8df8a-dffc-4088-94a1-fe1daed08f1b", "embedding": null, "metadata": {"page_label": "64", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5a64a2df-968e-4f10-a4d0-38d68d4b22f9", "node_type": "4", "metadata": {"page_label": "64", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "24247d2cd3f0875312d65581f748d5903559d0951aaaf05eb4ea80ab75e9696d", "class_name": "RelatedNodeInfo"}}, "text": "64 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nIf an int is 4 bytes then ptr +1 points to 4 bytes after whatever ptr is pointing at.\nchar *ptr = \"ABCDEFGH \";\nint *bna = ( int *) ptr ;\nbna +=1 ;//Would cause iterate byone integer space (i.e4bytes on\nsome systems )\nptr = ( char *) bna ;\nprintf( \"%s\", ptr) ;\nNotice how only \u2019EFGH\u2019 is printed. Why is that? Well as mentioned above, when performing \u2019bna +=1\u2019 we are\nincreasing the **integer** pointer by 1, (translates to 4 bytes on most systems) which is equivalent to 4 characters\n(each character is only 1 byte) Because pointer arithmetic in C is always automatically scaled by the size of the\ntype that is pointed to, POSIX standards forbid arithmetic on void pointers. Having said that, compilers will often\ntreat the underlying type as char . Here is a machine translation. The following two pointer arithmetic operations\nare equal\nint *ptr1 = ... ;\n//1\nint *offset = ptr1 + 4 ;\n//2\nchar *temp_ptr1 = ( char *) ptr1 ;\nint *offset = ( int*)(temp_ptr1 + sizeof (int)*4) ;\nEvery time you do pointer arithmetic, take a deep breath and make sure that you are shifting over the\nnumber of bytes you think you are shifting over.\n3.7.3 So what is a void pointer?\nA void pointer is a pointer without a type. Void pointers are used when either the datatype is unknown or when\ninterfacing C code with other programming languages without APIs. You can think of this as a raw pointer, or a\nmemory address. malloc by default returns a void pointer that can be safely promoted to any other type.\nvoid *give_me_space = malloc(10) ;\nchar *string = give_me_space ;\nC automatically promotes void* to its appropriate type. gcc andclang are not totally ISO C compliant,\nmeaning that they will permit arithmetic on a void pointer. They will treat it as a char pointer. Do not do this\nbecause it is not portable - it is not guaranteed to work with all compilers!", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1885, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c30c87ee-cf45-4a7c-adcf-cb1a8efee26e": {"__data__": {"id_": "c30c87ee-cf45-4a7c-adcf-cb1a8efee26e", "embedding": null, "metadata": {"page_label": "65", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "672c52db-1169-4d88-9422-a873ce53b643", "node_type": "4", "metadata": {"page_label": "65", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8ba070586ef608d226b4590f8d18537baf511bd7ce518282cb22e660947744be", "class_name": "RelatedNodeInfo"}}, "text": "3.8. COMMON BUGS 65\n3.8 Common Bugs\n3.8.1 Nul Bytes\nWhat\u2019s wrong with this code?\nvoid mystrcpy( char *dest, char * src) {\n//void means noreturn value\nwhile ( *src ) {dest = src ;src ++;dest ++;}\n}\nIn the above code it simply changes the dest pointer to point to source string. Also the NUL bytes are not\ncopied. Here is a better version -\nwhile ( *src ) {*dest = *src ;src ++;dest ++;}\n*dest = *src ;\nNote that it is also common to see the following kind of implementation, which does everything inside the\nexpression test, including copying the NUL byte. However, this is bad style, as a result of doing multiple operations\nin the same line.\nwhile ( (*dest ++= *src ++)){};\n3.8.2 Double Frees\nA double free error is when a program accidentally attempt to free the same allocation twice.\nint *p = malloc( sizeof (int));\nfree(p) ;\n*p = 123 ;//Oops !-Dangling pointer !Writing tomemory wedon\u2019town\nanymore\nfree(p) ;//Oops !-Double free !\nThe \ufb01x is \ufb01rst to write correct programs! Secondly , it is a good habit to set pointers to NULL, once the memory\nhas been freed. This ensures that the pointer cannot be used incorrectly without the program crashing.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1150, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "19f47f77-aee3-40b9-a68b-dfb2135cc2ef": {"__data__": {"id_": "19f47f77-aee3-40b9-a68b-dfb2135cc2ef", "embedding": null, "metadata": {"page_label": "66", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "fef06e5c-c24b-430a-92f0-4e1b10b3ccdf", "node_type": "4", "metadata": {"page_label": "66", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f7de28d86c4cafd31fb149976c0a42ed96b35ae8788897e569e351b5248ef38e", "class_name": "RelatedNodeInfo"}}, "text": "66 CHAPTER 3. THE C PROGRAMMING LANGUAGE\np = NULL ;//Nodangling pointers\n3.8.3 Returning pointers to automatic variables\nint *f() {\nint result = 42 ;\nstatic int imok ;\nreturn &imok ;//OK-static variables are not onthe stack\nreturn &result ;//Not OK\n}\nAutomatic variables are bound to stack memory only for the lifetime of the function. After the function returns,\nit is an error to continue to use the memory .\n3.8.4 Insuf\ufb01cient memory allocation\nstruct User {\nchar name[100] ;\n};\ntypedef struct User user_t ;\nuser_t *user = (user_t *) malloc( sizeof (user)) ;\nIn the above example, we needed to allocate enough bytes for the struct. Instead, we allocated enough bytes\nto hold a pointer. Once we start using the user pointer we will corrupt memory . The correct code is shown below.\nstruct User {\nchar name[100] ;\n};\ntypedef struct User user_t ;\nuser_t * user = (user_t *) malloc( sizeof (user_t)) ;\n3.8.5 Buffer over\ufb02ow /under\ufb02ow\nA famous example: Heart Bleed performed a memcpy into a buffer that was of insuf\ufb01cient size. A simple example:\nimplement a strcpy and forget to add one to strlen, when determining the size of the memory required.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1143, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e5f6d7f7-9670-40ed-a15c-ac7e233ce616": {"__data__": {"id_": "e5f6d7f7-9670-40ed-a15c-ac7e233ce616", "embedding": null, "metadata": {"page_label": "67", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "98dc8c61-0938-40a0-bcd1-865c86dd1d6f", "node_type": "4", "metadata": {"page_label": "67", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f7c935b4d97fc51632e3d364437d88d41049e237f3d22f9349afaa4c1ddb3cd5", "class_name": "RelatedNodeInfo"}}, "text": "3.8. COMMON BUGS 67\n#define N (10)\nint i = N, array[N] ;\nfor(;i>= 0;i--) array[i] = i ;\nC fails to check if pointers are valid. The above example writes into array[10] which is outside the array\nbounds. This can cause memory corruption because that memory location is probably being used for something\nelse. In practice, this can be harder to spot because the over\ufb02ow /under\ufb02ow may occur in a library call. Here is\nour old friend gets.\ngets(array) ;//Let\u2019shope the input isshorter than myarray !\n3.8.6 Strings require strlen(s) +1 bytes\nEvery string must have a NUL byte after the last characters. To store the string \u201cHi\u201d it takes 3 bytes: [H] [i] [\\0].\nchar *strdup( const char *input) {/*return acopy of\u2019input \u2019*/\nchar *copy ;\ncopy = malloc( sizeof (char *));/*nope !this allocates space for a\npointer ,not astring */\ncopy = malloc(strlen(input)) ;/*Almost ...but what about the null\nterminator ?*/\ncopy = malloc(strlen(input) + 1) ;/*That \u2019sright .*/\nstrcpy(copy, input) ;/*strcpy will provide the null terminator */\nreturn copy ;\n}\n3.8.7 Using uninitialized variables\nint myfunction() {\nint x;\nint y = x + 2 ;\n...\nAutomatic variables hold garbage or bit pattern that happened to be in memory or register. It is an error to\nassume that it will always be initialized to zero.\n3.8.8 Assuming Uninitialized memory will be zeroed", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1329, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d9030338-2be4-4856-bb1e-64a2a9fdf852": {"__data__": {"id_": "d9030338-2be4-4856-bb1e-64a2a9fdf852", "embedding": null, "metadata": {"page_label": "68", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e777113e-ee66-495a-8484-fa5a32bcc454", "node_type": "4", "metadata": {"page_label": "68", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "1b862f6418ab892521676633215407369c4a490d9c4e9ed8ea681351afeaed35", "class_name": "RelatedNodeInfo"}}, "text": "68 CHAPTER 3. THE C PROGRAMMING LANGUAGE\nvoid myfunct() {\nchar array[10] ;\nchar *p = malloc(10) ;\nAutomatic (temporary variables) and heap allocations may contain random bytes or garbage.\n3.9 Logic and Program \ufb02ow mistakes\nThese are a set of mistakes that may let the program compile but perform unintended functionality .\n3.9.1 Equal vs. Equality\nConfusingly in C, the assignment operator also returns the assigned value. Most of the time it is ignored. We can\nuse it to initialize multiple things on the same line.\nint p1, p2 ;\np1 = p2 = 0 ;\nMore confusingly , if we forget an equals sign in the equality operator we will end up assigning that variable.\nMost of the time this isn\u2019t what we want to do.\nint answer = 3 ;//Will print out the answer .\nif(answer = 42) {printf( \"The answer is%d\", answer) ;}\nThe quick way to \ufb01x that is to get in the habit of putting constants \ufb01rst. This mistake is common enough in\nwhile loop conditions. Most modern compilers disallows assigning variables a condition without parenthesis.\nif(42 = answer) {printf( \"The answer is%d\", answer) ;}\nThere are cases where we want to do it. A common example is getline.\nwhile ((nread = getline(&line, &len, stream)) != -1)\nThis piece of code calls getline, and assigns the return value or the number of bytes read to nread. It also in\nthe same line checks if that value is -1 and if so terminates the loop. It is always good practice to put parentheses\naround any assignment condition.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1460, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3f0d11df-538c-4959-b75d-17647f4acd23": {"__data__": {"id_": "3f0d11df-538c-4959-b75d-17647f4acd23", "embedding": null, "metadata": {"page_label": "69", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6f6c2f5f-6b4c-4296-a8b1-a9ec10497351", "node_type": "4", "metadata": {"page_label": "69", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e13eb96d6b00abee1a0f2f015f7cdccbb177511b1af2d5f4262169473545e13f", "class_name": "RelatedNodeInfo"}}, "text": "3.10. TOPICS 69\n3.9.2 Undeclared or incorrectly prototyped functions\nSome snippets of code may do the following.\ntime_t start = time() ;\nThe system function \u2018time\u2019 actually takes a parameter a pointer to some memory that can receive the time_t\nstructure or NULL. The compiler fails to catch this error because the programmer omitted the valid function\nprototype by including time.h .\nMore confusingly this could compile, work for decades and then crash. The reason for that is that time would\nbe found at link time, not compile-time in the C standard library which almost surely is already in memory . Since\na parameter isn\u2019t being passed, we are hoping the arguments on the stack (any garbage) is zeroed out because if\nit isn\u2019t, time will try to write the result of the function to that garbage which will cause the program to SEGFAULT .\n3.9.3 Extra Semicolons\nThis is a pretty simple one, don\u2019t put semicolons when unneeded.\nfor(int i = 0 ;i<5;i++);printf( \"Printed once \");\nwhile (x<10);x++;//Xisnever incremented\nHowever, the following code is perfectly OK.\nfor(int i = 0 ;i<5;i++){\nprintf( \"%d\\n\", i) ;;;;;;;;;;;;;\n}\nIt is OK to have this kind of code because the C language uses semicolons (;) to separate statements. If\nthere is no statement in between semicolons, then there is nothing to do and the compiler moves on to the next\nstatement To save a lot of confusion, always use braces. It increases the number of lines of code, which is a great\nproductivity metric.\n3.10 Topics\n\u2022C-strings representation\n\u2022C-strings as pointers\n\u2022char p []vs char* p\n\u2022Simple C string functions (strcmp, strcat, strcpy)\n\u2022sizeof char\n\u2022sizeof x vs x*", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1637, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "18ee8e8a-cdf5-42ca-9347-1dd8a2cb028a": {"__data__": {"id_": "18ee8e8a-cdf5-42ca-9347-1dd8a2cb028a", "embedding": null, "metadata": {"page_label": "70", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "66108743-8e72-4c8f-a2a5-34d8b61b174f", "node_type": "4", "metadata": {"page_label": "70", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4c820fc5025e57a136e9edf7ba5e2b83cc98344d9ebbd80e970dd78895f1a6c8", "class_name": "RelatedNodeInfo"}}, "text": "70 CHAPTER 3. THE C PROGRAMMING LANGUAGE\n\u2022Heap memory lifetime\n\u2022Calls to heap allocation\n\u2022Dereferencing pointers\n\u2022Address-of operator\n\u2022Pointer arithmetic\n\u2022String duplication\n\u2022String truncation\n\u2022double-free error\n\u2022String literals\n\u2022Print formatting.\n\u2022memory out of bounds errors\n\u2022static memory\n\u2022\ufb01le input /output. POSIX vs. C library\n\u2022C input output: fprintf and printf\n\u2022POSIX \ufb01le IO (read, write, open)\n\u2022Buffering of stdout\n3.11 Questions /Exercises\n\u2022What does the following print out?\nint main() {\nfprintf(stderr, \"Hello \");\nfprintf(stdout, \"It\u2019sasmall \");\nfprintf(stderr, \"World \\n\");\nfprintf(stdout, \"place \\n\");\nreturn 0;\n}\n\u2022What are the differences between the following two declarations? What does sizeof return for one of\nthem?\nchar str1[] = \"first one\";\nchar *str2 = \"another one\";", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 788, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6b383aa2-ffd3-40a1-8248-b54e1d570312": {"__data__": {"id_": "6b383aa2-ffd3-40a1-8248-b54e1d570312", "embedding": null, "metadata": {"page_label": "71", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "521e1d8b-fbaf-4ab2-b69b-2e48b8230a7a", "node_type": "4", "metadata": {"page_label": "71", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "637ed75cd760902073c66bdbf5bf67ee818ea716d5845cd310354266683429f7", "class_name": "RelatedNodeInfo"}}, "text": "3.11. QUESTIONS /EXERCISES 71\n\u2022What is a string in C?\n\u2022Code up a simple my_strcmp . How about my_strcat ,my_strcpy , ormy_strdup ? Bonus: Code the\nfunctions while only going through the strings once.\n\u2022What should each of the following lines usually return?\nint *ptr ;\nsizeof (ptr) ;\nsizeof (*ptr) ;\n\u2022What is malloc ? How is it different from calloc . Once memory is allocated how can we use realloc ?\n\u2022What is the &operator? How about *?\n\u2022Pointer Arithmetic. Assume the following addresses. What are the following shifts?\nchar ** ptr = malloc(10) ;//0x100\nptr[0] = malloc(20) ;//0x200\nptr[1] = malloc(20) ;//0x300\n\u2013ptr + 2\n\u2013ptr + 4\n\u2013ptr[0] + 4\n\u2013ptr[1] + 2000\n\u2013*((int)(ptr + 1)) + 3\n\u2022How do we prevent double free errors?\n\u2022What is the printf speci\ufb01er to print a string, int, orchar ?\n\u2022Is the following code valid? Why? Where is output located?\nchar *foo( int var) {\nstatic char output[20] ;\nsnprintf(output, 20, \"%d\", var) ;\nreturn output ;\n}\n\u2022Write a function that accepts a path as a string, and opens that \ufb01le, prints the \ufb01le contents 40 bytes at a\ntime but, every other print reverses the string (try using the POSIX API for this).\n\u2022What are some differences between the POSIX \ufb01le descriptor model and C\u2019s FILE* (i.e. what function calls\nare used and which is buffered)? Does POSIX use C\u2019s FILE* internally or vice versa?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1324, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "42ca0333-0ae1-4717-8ca5-aa48833657e4": {"__data__": {"id_": "42ca0333-0ae1-4717-8ca5-aa48833657e4", "embedding": null, "metadata": {"page_label": "72", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e36849d0-c59d-42ce-8dca-b23571fb2860", "node_type": "4", "metadata": {"page_label": "72", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a80d3456541be68167ff82563977ef247b8e838b0f7bb909f5ff1100d0609c51", "class_name": "RelatedNodeInfo"}}, "text": "72 CHAPTER 3. THE C PROGRAMMING LANGUAGE\n3.12 Rapid Fire: Pointer Arithmetic\nPointer arithmetic is important! Take a deep breath and \ufb01gure out how many bytes each operation moves a\npointer. The following is a rapid \ufb01re section. We\u2019ll use the following de\ufb01nitions:\nint *int_ ;//sizeof (int)==4;\nlong *long_ ;//sizeof (long )==8;\nchar *char_ ;\nint *short_ ;//sizeof (short )==2;\nint **int_ptr ;//sizeof (int*)==8;\nHow many bytes are moved over from the following additions?\n1.int_ + 1\n2.long_ + 7\n3.short_ - 6\n4.short_ - sizeof(long)\n5.long_ - sizeof(long) + sizeof(int_)\n6.long_ - sizeof(long) / sizeof(int)\n7.(char*)(int_ptr + sizeof(long)) + sizeof(int_)\n3.12.1 Rapid Fire Solutions\n1.4\n2.56\n3.-12\n4.-16\n5.0\n6.-16\n7.72\nBibliography\n[1]Ieee standard for \ufb02oating-point arithmetic. IEEE Std 754-2008 , pages 1\u201370, Aug 2008. doi: 10.1109 /IEEESTD.\n2008.4610935.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 858, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6bb00794-0153-45d9-b27c-8439d0de0d46": {"__data__": {"id_": "6bb00794-0153-45d9-b27c-8439d0de0d46", "embedding": null, "metadata": {"page_label": "73", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3fd3611c-2a79-4be7-8fc6-a7deced046e0", "node_type": "4", "metadata": {"page_label": "73", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "96baaee09ec01ff359877ff048650dd7b53b36e7b5c0c77fe2087374e550d0cc", "class_name": "RelatedNodeInfo"}}, "text": "BIBLIOGRAPHY 73\n[2]Tom Duff. Tom duff on duff\u2019s device. URL https://www.lysator.liu.se/c/duffs-device.html .\n[3]Fortran 72. FORTRAN IV PROGRAMMER\u2019S REFERENCE MANUAL. Manual, DIGITAL EQUIPMENT COR-\nPORATION, Maynard, MASSACHUSETTS, May 1972. URL http://www.bitsavers.org/www.computer.\nmuseum.uq.edu.au/pdf/DEC-10-AFDO-D%20decsystem10%20FORTRAN%20IV%20Programmer%27s%\n20Reference%20Manual.pdf .\n[4]Apple Inc. Xnu kernel. https://github.com/apple/darwin-xnu , 2017.\n[5]ISO 1124:2005. ISO C Standard. Standard, International Organization for Standardization, Geneva, CH,\nMarch 2005. URL http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf .\n[6]B.W . Kernighan and D.M. Ritchie. The C Programming Language . Prentice-Hall software series. Prentice Hall,\n1988. ISBN 9780131103627. URL https://books.google.com/books?id=161QAAAAMAAJ .\n[7]Robert Love. Linux Kernel Development . Addison-Wesley Professional, 3rd edition, 2010. ISBN 0672329468,\n9780672329463.\n[8]Dennis M. Ritchie. The development of the c language. SIGPLAN Not. , 28(3):201\u2013208, March 1993. ISSN\n0362-1340. doi: 10.1145 /155360.155580. URL http://doi.acm.org/10.1145/155360.155580 .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1147, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0d5cd916-fd99-4b68-ab4c-99cd55bc8fc5": {"__data__": {"id_": "0d5cd916-fd99-4b68-ab4c-99cd55bc8fc5", "embedding": null, "metadata": {"page_label": "191", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "666b246d-da04-463f-a8e9-c11b622f7fc3", "node_type": "4", "metadata": {"page_label": "191", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d484d90367c921e366f31107027a9b7ef3c511bce1d38dd25c36352a729922d5", "class_name": "RelatedNodeInfo"}}, "text": "9\nVirtual Memory and Interprocess Communication\nAbbott: Now you\u2019ve got it.\nCostello: I throw the ball to Naturally .\nAbbott: You don\u2019t! You throw it to Who!\nCostello: Naturally .\nAbbott: Well, that\u2019s it - say it that way .\nCostello: That\u2019s what I said.\nAbbott and Costello on Effective Communication\nIn simple embedded systems and early computers, processes directly access memory \u2013 \u201c Address 1234\u201d cor-\nresponds to a particular byte stored in a particular part of physical memory . For example, the IBM 709 had to\nread and write directly to tape with no level of abstraction [3, P . 65 ]. Even in systems after that, it was hard to\nadopt virtual memory because virtual memory required the whole fetch cycle to be altered through hardware\n\u2013 a change many manufacturers still thought was expensive. In the PDP-10, a workaround was used by using\ndifferent registers for each process and then virtual memory was added later [1]. In modern systems, this is no\nlonger the case. Instead, each process is isolated, and there is a translation process between the address of a\nparticular CPU instruction or piece of data of a process and the actual byte of physical memory (\u201cRAM\u201d). Memory\naddresses no longer map to physical addresses The process runs inside virtual memory . Virtual memory keeps\nprocesses safe because one process cannot directly read or modify another process\u2019s memory . Virtual memory also\nallows the system to ef\ufb01ciently allocate and reallocate portions of memory to different processes. The modern\nprocess of translating memory is as follows.\n1.A process makes a memory request\n2.The circuit \ufb01rst checks the Translation Lookaside Buffer (TLB) if the address page is cached into memory . It\nskips to the reading from /writing to phase if found otherwise the request goes to the MMU.\n3.The Memory Management Unit (MMU) performs the address translation. If the translation succeeds, the\npage gets pulled from RAM \u2013 conceptually the entire page isn\u2019t loaded up. The result is cached in the TLB.\n4.The CPU performs the operation by either reading from the physical address or writing to the address.\n191", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2111, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "451ff369-0ffe-43ce-8c47-5435c31f8cc4": {"__data__": {"id_": "451ff369-0ffe-43ce-8c47-5435c31f8cc4", "embedding": null, "metadata": {"page_label": "192", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e5fe52ac-d081-419e-8b6b-b6d548f3d0cb", "node_type": "4", "metadata": {"page_label": "192", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "90f9c209946b3335b57e2a14915b10d4823ab102323bfbc7b5fc4d67e11dacf4", "class_name": "RelatedNodeInfo"}}, "text": "192 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\n9.1 Translating Addresses\nThe Memory Management Unit is part of the CPU, and it converts a virtual memory address into a physical address.\nFirst, we\u2019ll talk about what the virtual memory abstraction is and how to translate addresses\nTo illustrate, consider a 32-bit machine, meaning pointers are 32-bits. They can address 232different locations\nor 4GB of memory where one address is one byte. Imagine we had a large table for every possible address\nwhere we will store the \u2018real\u2019 i.e. physical address. Each physical address will need 4 bytes \u2013 to hold the 32-bits.\nNaturally , This scheme would require 16 billion bytes to store all of the entries. It should be painfully obvious that\nour lookup scheme would consume all of the memory that we could buy for our 4GB machine. Our lookup table\nshould be smaller than the memory we have otherwise we will have no space left for our actual programs and\noperating system data. The solution is to chunk memory into small regions called \u2018pages\u2019 and \u2018frames\u2019 and use a\nlookup table for each page.\n9.1.1 Terminology\nApage is a block of virtual memory . A typical block size on Linux is 4KiB or 212addresses, though one can \ufb01nd\nexamples of larger blocks. So rather than talking about individual bytes, we can talk about blocks of 4KiBs, each\nblock is called a page. We can also number our pages (\u201cPage 0\u201d \u201cPage 1\u201d etc). Let\u2019s do a sample calculation of\nhow many pages are there assume page size of 4KiB.\nFor a 32-bit machine,\n232address /212(address /page)=220pages.\nFor a 64-bit machine,\n264address /212(address /page)=252pages\u22481015pages.\nWe also call this a frame or sometimes called a \u2018page frame\u2019 is a block of physical memory or RAM \u2013 Random\nAccess Memory . A frame is the same number of bytes as a virtual page or 4KiB on our machine. It stores the bytes\nof interest. To access a particular byte in a frame, an MMU goes from the start of the frame and adds the offset \u2013\ndiscussed later.\nApage table is a map from a number to a particular frame. For example Page 1 might be mapped to frame 45,\npage 2 mapped to frame 30. Other frames might be currently unused or assigned to other running processes or\nused internally by the operating system. Implied from the name, imagine a page table as a table.\nPage Number Frame Number\n0\n1\n242\n30\n24\nFigure 9.1: Explicit Frame Table", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2376, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "26d9bc63-0878-463e-be6c-c08ab76d96ff": {"__data__": {"id_": "26d9bc63-0878-463e-be6c-c08ab76d96ff", "embedding": null, "metadata": {"page_label": "193", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "17da1750-e889-43c4-b7b3-35be6ee52db0", "node_type": "4", "metadata": {"page_label": "193", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ca512b4472782409bfad34bb8dfd4694e532cc8c4a71b78d2015bb5e4c5e5334", "class_name": "RelatedNodeInfo"}}, "text": "9.1. TRANSLATING ADDRESSES 193\nIn practice, we will omit the \ufb01rst column because it will always be sequentially 0, 1, 2, etc and instead we\u2019ll\nuse the offset from the start of the table as the entry number.\nNow to go through the actual calculations. We will assume that a 32-bit machine has 4KiB pages Naturally , to\naddress all the possible entries, there are 220frames. Since there are 220possible frames, we will need 20 bits to\nnumber all of the possible frames meaning Frame Number must be 2.5 bytes long. In practice, we\u2019ll round that\nup to 4 bytes and do something interesting with the rest of the bits. With 4 bytes per entry x 220entries =4 MiB\nof physical memory are required to hold the entire page table for a process.\nRemember our page table maps pages to frames, but each frame is a block of contiguous addresses. How\ndo we calculate which particular byte to use inside a particular frame? The solution is to re-use the lowest\nbits of the virtual memory address directly . For example, suppose our process is reading the following address-\nVirtualAddress = 11110000111100001111000010101010 (binary)\nSo to give an example say we have the virtual address above. How would we split it up using a one-page table\nto frame scheme?\n11110000111100001111 000010101010 Page Number\nO\nset\nFigure 9.2: Splitting Address\nWe can imagine the steps to dereference as one process. In general, it looks like the following.\nBase DirectoryPhysical Frame\nSubpage Num\nByte0 20 32\nFigure 9.3: One level dereference\nThe way to read from a particular address above is visualized below.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1573, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "77ed7a80-857a-4560-a0e8-f0cda970db00": {"__data__": {"id_": "77ed7a80-857a-4560-a0e8-f0cda970db00", "embedding": null, "metadata": {"page_label": "194", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ddaf3c7c-18e8-4213-b2c5-d99f960bef47", "node_type": "4", "metadata": {"page_label": "194", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "df90574a5ef77b0f9c85b8cafe1be3e6522c50c7ee86dffb3d92650baee04787", "class_name": "RelatedNodeInfo"}}, "text": "194 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\nBase DirectoryPhysical Frame #357\nByte0 20 32\n357 11110000111100001111 \n361 11110000111100010000 421 11110000111100001110 \n000010101010\nFigure 9.4: One level dereference example\nAnd if we were reading from it, \u2019return\u2019 that value. This sounds like a perfect solution. Take each address and\nmap it to a virtual address in sequential order. The process will believe that the address looks continuous, but the\ntop 20 bits are used to \ufb01gure out page_num , which will allow us to \ufb01nd the frame number, \ufb01nd the frame, add the\noffset \u2013 derived from the last 12 bits \u2013 and do the read or write.\nThere are other ways to split it as well. On a machine with page size 256 Bytes, then the lowest 8 bits (10101010)\nwill be used as the offset. The remaining upper bits will be the page number (111100001111000011110000).\nThis offset is treated as a binary number and is added to the start of the frame when we get it.\nWe do have a problem with 64-bit operating systems. For a 64-bit machine with 4KiB pages, each entry needs\n52 bits. Meaning we need roughly With 252entries, that\u2019s 255bytes (roughly 40 petabytes). So our page table\nis too large. In 64-bit architecture, memory addresses are sparse, so we need a mechanism to reduce the page\ntable size, given that most of the entries will never be used. We\u2019ll take about this below. There is one last piece of\nterminology that needs to be covered.\n9.1.2 Multi-level page tables\nMulti-level pages are one solution to the page table size issue for 64-bit architectures. We\u2019ll look at the simplest\nimplementation - a two-level page table. Each table is a list of pointers that point to the next level of tables, som\nsub-tables may be omitted. An example, a two-level page table for a 32-bit architecture is shown below.\n1111000011 1100001111 000010101010 \nO\nsetIndex 1\nIndex 2\nFigure 9.5: Three Way Address Split", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1907, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6a9fa445-5130-4aa2-8032-db67cc547efe": {"__data__": {"id_": "6a9fa445-5130-4aa2-8032-db67cc547efe", "embedding": null, "metadata": {"page_label": "195", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "221eeb34-7b96-4f24-82ab-7881bc01e7ea", "node_type": "4", "metadata": {"page_label": "195", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "23fadc65633ace430a6a4ba4004a0fafb17ba5f764e43171370ea4964f794f66", "class_name": "RelatedNodeInfo"}}, "text": "9.1. TRANSLATING ADDRESSES 195\nSo what is the intuition for dereferencing an address? First, the MMU takes the top-level page table and \ufb01nd\ntheIndex1 \u2019th entry . That will contain a number that will lead the MMU to the appropriate sub-table Then go to\ntheIndex2 \u2019th entry of that table. That will contain a frame number. This is the good old fashioned 4KiB RAM\nthat we were talking about earlier. Then, the MMU adds the offset and do the read or write.\nVisualizing The Dereference\nIn one diagram, the dereference looks like the following image.\nBase Directory\nSubpage T ablePhysical Frame\nSubpage Num\nFrame Num\nByte0 10 20 32\nFigure 9.6: Full page table dereference\nFollowing our example, here is what the dereference would look like.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 734, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e04a2bf7-fabc-4c4f-81b2-8f117c6c1649": {"__data__": {"id_": "e04a2bf7-fabc-4c4f-81b2-8f117c6c1649", "embedding": null, "metadata": {"page_label": "196", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7f5f8800-2f00-4524-a28f-0f0746e72ab0", "node_type": "4", "metadata": {"page_label": "196", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "94a5833a41dd3ec2627824b3e48b826a50fa337a411a45d452298bc1fecdec04", "class_name": "RelatedNodeInfo"}}, "text": "196 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\nBase Directory\nSubpage T able #173Physical Frame #241\n173\nByte0 10 20 32\n1111000011 \n126 1111000100 125 1111000010 \n241 1100001111\n374 1100010000 233 1100001110 \n000010101010\nFigure 9.7: Full page example dereference\nCalculating Size Concerns\nNow some calculations on size. Each page_table_num index is 10 bits wide because there are only 210possible\nsub-tables , so we need 10 bits to store each directory index. We\u2019ll round up to 2 bytes for the sake of reasoning.\nIf 2 bytes are used for each entry in the top-level table and there are only 210entries, we only need 2KiB to store\nthis entire \ufb01rst level page table. Each subtable will point to physical frames, and each of their entries needs to be\nthe required 4 bytes to be able to address all the frames as mentioned earlier. However, for processes with only\ntiny memory needs, we only need to specify entries for low memory addresses for the heap and program code and\nhigh memory addresses for the stack.\nThus, the total memory overhead for our multi-level page table has shrunk from 4MiB for the single-level\nimplementation to three page tables of memory or 2KiB for the top-level and 4KiB for the two intermediate\nlevels of size 10KiB. Here\u2019s why . We need at least one frame for the high-level directory and two frames for two\nsub-tables. One sub-table is necessary for the low addresses \u2013 program code, constants and possibly a tiny heap.\nThe other sub-table is for higher addresses used by the environment and stack. In practice, real programs will\nlikely need more sub-table entries, as each subtable can only reference 1024*4KiB =4MiB of address space.\nThe main point still stands. We have signi\ufb01cantly reduced the memory overhead required to perform page table\nlookups.\n9.1.3 Page Table Disadvantages\nThere are lots of problems with page tables \u2013 one of the big problems is that they are slow. For a single page table,\nour machine is now twice as slow! Two memory accesses are required. For a two-level page table, memory access\nis now three times as slow \u2013 three memory accesses are required.\nTo overcome this overhead, the MMU includes an associative cache of recently-used virtual-page-to-frame\nlookups. This cache is called the TLB (\u201ctranslation lookaside buffer\u201d). Every time a virtual address needs to be\ntranslated into a physical memory location, the TLB is queried in parallel to the page table. For most memory", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2445, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b2e4f21c-cb75-46fd-85c4-ad51674a7140": {"__data__": {"id_": "b2e4f21c-cb75-46fd-85c4-ad51674a7140", "embedding": null, "metadata": {"page_label": "197", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4164172b-ca9e-42f0-89ba-bc7e969461cf", "node_type": "4", "metadata": {"page_label": "197", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "288a43b6168e4be9a5b25e708670d8fd3a8c3788e21f92d49a880a381a9efaa9", "class_name": "RelatedNodeInfo"}}, "text": "9.1. TRANSLATING ADDRESSES 197\naccesses of most programs, there is a signi\ufb01cant chance that the TLB has cached the results. However, if a program\nhas inadequate cache coherence, the address will be missing in the TLB, meaning the MMU must use the much\nslower page table translation.\n9.1.4 MMU Algorithm\nThere is a sort of pseudocode associated with the MMU. We will assume that this is for a single-level page table.\n1.Receive address\n2.Try to translate address according to the programmed scheme\n3.If the translation fails, report an invalid address\n4.Otherwise,\n(a)If the TLB contains the physical memory , get the physical frame from the TLB and perform the read\nand write.\n(b)If the page exists in memory , check if the process has permissions to perform the operation on the page\nmeaning the process has access to the page, and it is reading from the page /writing to a page that it\nhas permission to do so.\ni.If so then do the dereference provide the address, cache the results in the TLB\nii.Otherwise, trigger a hardware interrupt. The kernel will most likely send a SIGSEGV or a\nSegmentation Violation.\n(c)If the page doesn\u2019t exist in memory , generate an Interrupt.\ni.The kernel could realize that this page could either be not allocated or on disk. If it \ufb01ts the\nmapping, allocate the page and try the operation again.\nii.Otherwise, this is invalid access and the kernel will most likely send a SIGSEGV to the process.\nHow would you alter this for a multi-level page table?\n9.1.5 Frames and Page Protections\nFrames can be shared between processes, and this is where the heart of the chapter comes into play . We can use\nthese tables to communicate with processes. In addition to storing the frame number, the page table can be used\nto store whether a process can write or only read a particular frame. Read-only frames can then be safely shared\nbetween multiple processes. For example, the C-library instruction code can be shared between all processes that\ndynamically load the code into the process memory . Each process can only read that memory . Meaning that if a\nprogram tries to write to a read-only page in memory , it will SEGFAULT . That is why sometimes memory accesses\nSEGFAULT and sometimes they don\u2019t, it all depends on if your hardware says that a program can access.\nAlso, processes can share a page with a child process using the mmap system call. mmap is an interesting call\nbecause instead of tying each virtual address to a physical frame, it ties it to something else. It is an important\ndistinction that we are talking about mmap and not memory-mapped IO in general. The mmap system call can\u2019t\nreliably be used to do other memory-mapped operations like communicate with GPUs and write pixels to the\nscreen \u2013 this is mainly hardware dependent.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2774, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c4216d6-de23-4054-83bd-868e84f849f4": {"__data__": {"id_": "0c4216d6-de23-4054-83bd-868e84f849f4", "embedding": null, "metadata": {"page_label": "198", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e0f9db8d-428c-424f-8a25-ca6c429119e0", "node_type": "4", "metadata": {"page_label": "198", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "fde4dd7963cb05c6bf2a3540b04a0391f95a742cccf883c200b2f38d5e3fc72c", "class_name": "RelatedNodeInfo"}}, "text": "198 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\nBits on Pages\nThis is heavily dependent on the chipset. We will include some bits that have historically been popular in chipsets.\n1.The read-only bit marks the page as read-only . Attempts to write to the page will cause a page fault. The\npage fault will then be handled by the Kernel. Two examples of the read-only page include sharing the C\nstandard library between multiple processes for security you wouldn\u2019t want to allow one process to modify\nthe library and Copy-On-Write where the cost of duplicating a page can be delayed until the \ufb01rst write\noccurs.\n2.The execution bit de\ufb01nes whether bytes in a page can be executed as CPU instructions. Processors may\nmerge these bits into one and deem a page either writable or executable. This bit is useful because it\nprevents stack over\ufb02ow or code injection attacks when writing user data into the heap or the stack because\nthose are not read-only and thus not executable. Further reading: background\n3.The dirty bit allows for performance optimization. A page exclusively read from can be discarded without\nsyncing to disk, since the page hasn\u2019t changed. However, if the page was written to after it\u2019s paged in, its\ndirty bit will be set, indicating that the page must be written back to the backing store. This strategy requires\nthat the backing store retain a copy of the page after it is paged into memory . When a dirty bit is omitted,\nthe backing store need only be as large as the instantaneous total size of all paged-out pages at any moment.\nWhen a dirty bit is used, at all times some pages will exist in both physical memory and the backing store.\n4.There are plenty of other bits. Take a look at your favorite architecture and see what other bits are associated!\n9.1.6 Page Faults\nA page fault may happen when a process accesses an address in a frame missing in memory . There are three types\nof Page Faults\n1.Minor If there is no mapping yet for the page, but it is a valid address. This could be memory asked for\nbysbrk(2) but not written to yet meaning that the operating system can wait for the \ufb01rst write before\nallocating space \u2013 if it was read from, the operating system could short circuit the operation to read 0. The\nOS simply makes the page, loads it into memory , and moves on.\n2.Major If the mapping to the page is exclusively on disk. The operating system will swap the page into\nmemory and swap another page out. If this happens frequently enough, your program is said to thrash the\nMMU.\n3.Invalid When a program tries to write to a non-writable memory address or read to a non-readable\nmemory address. The MMU generates an invalid fault and the OS will usually generate a SIGSEGV meaning\nsegmentation violation meaning that the program wrote outside the segment that it could write to.\n9.1.7 Link Back to IPC\nWhat does this have to do with IPC? Before, you knew that processes had isolation. One, you didn\u2019t know how\nthat isolation mapped. Two, you may not know how you can break this isolation. To break any memory level\nisolation you have two avenues. One is to ask the kernel to provide some kind of interface. The other is to ask the\nkernel to map two pages of memory to the same virtual memory area and handle all the synchronization yourself.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3287, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8311a3a7-add2-48a5-9526-704de163ff79": {"__data__": {"id_": "8311a3a7-add2-48a5-9526-704de163ff79", "embedding": null, "metadata": {"page_label": "199", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7b2ba05b-7a15-424c-ad27-c400e81550a6", "node_type": "4", "metadata": {"page_label": "199", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c33e3257d05af112aafe4ac2e8d06ae700cdcb1e7e500d47317c05599ca98708", "class_name": "RelatedNodeInfo"}}, "text": "9.2. MMAP 199\n9.2 mmap\nmmap is a trick of virtual memory of instead of mapping a page to a frame, that frame can be backed by a \ufb01le on\ndisk, or the frame can be shared among processes. We can use that to read from a \ufb01le on disk ef\ufb01ciently or sync\nchanges to the \ufb01le. One of the big optimizations is a \ufb01le may be lazily allocated to memory . Take the following\ncode for example.\nint fd = open(...) ;//File is2Pages\nchar * addr = mmap(..fd..) ;\naddr[0] = \u2019l\u2019;\nThe kernel sees that the program wants to mmap the \ufb01le into memory , so it will reserve some space in your\naddress space that is the length of the \ufb01le. That means when the program writes to addr[0] that it writes to the\n\ufb01rst byte of the \ufb01le. The kernel can do some optimizations too. Instead of loading the whole \ufb01le into memory , it\nmay only load pages at a time. A program may only access 3 or 4 pages making loading the entire \ufb01le a waste of\ntime. Page faults are so powerful because let the operating system take control of when a \ufb01le is used.\n9.2.1 mmap De\ufb01nitions\nmmap does more than take a \ufb01le and map it to memory . It is the general interface for creating shared memory\namong processes. Currently it only supports regular \ufb01les and POSIX shmem [2]. Naturally , you can read all about\nit in the reference above, which references the current working group POSIX standard. Some other options to\nnote in the page will follow.\nThe \ufb01rst option is that the flags argument of mmap can take many options.\n1.PROT_READ This means the process can read the memory . This isn\u2019t the only \ufb02ag that gives the process read\npermission, however! The underlying \ufb01le descriptor, in this case, must be opened with read privileges.\n2.PROT_WRITE This means the process can write to the memory . This has to be supplied for a process to\nwrite to a mapping. If this is supplied and PROT_NONE is also supplied, the latter wins and no writes can be\nperformed. The underlying \ufb01le descriptor, in this case, must either be opened with write privileges or a\nprivate mapping must be supplied below\n3.PROT_EXEC This means the process can execute this piece of memory . Although this is not stated in POSIX\ndocuments, this shouldn\u2019t be supplied with WRITE or NONE because that would make this invalid under\nthe NX bit or not being able to execute (respectively)\n4.PROT_NONE This means the process can\u2019t do anything with the mapping. This could be useful if you\nimplement guard pages in terms of security . If you surround critical data with many more pages that can\u2019t\nbe accessed, that decreases the chance of various attacks.\n5.MAP_SHARED This mapping will be synchronized to the underlying \ufb01le object. The \ufb01le descriptor must\u2019ve\nbeen opened with write permissions in this case.\n6.MAP_PRIVATE This mapping will only be visible to the process itself. Useful to not thrash the operating\nsystem.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2823, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3f1c05f1-8e44-4306-83b7-c9a63b6f13b8": {"__data__": {"id_": "3f1c05f1-8e44-4306-83b7-c9a63b6f13b8", "embedding": null, "metadata": {"page_label": "200", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a1614889-9620-4646-9cd9-2887e75271f7", "node_type": "4", "metadata": {"page_label": "200", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "66efdef306b627369b4a6c879ec4f06300c51ed0c321af3daea07ea94a0089b0", "class_name": "RelatedNodeInfo"}}, "text": "200 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\nRemember that once a program is done mmap ping that the program must munmap to tell the operating system\nthat it is no longer using the pages allocated, so the OS can write it back to disk and give back the addresses in\ncase another mmap needs to occur. There are accompanying calls msync that take a piece of mmap\u2019ed memory\nand sync the changes back to the \ufb01lesystem though we won\u2019t cover that in-depth. The other parameters to mmap\nare described in the annotated walkthrough below.\n9.2.2 Annotated mmap Walkthrough\nBelow is an annotated walkthrough of the example code in the man pages. Our command-line utility will take a\n\ufb01le, offset, and length to print. We can assume that these are initialized correctly and the offset +length is less\nthan the length of the \ufb01le.\noff_t offset ;\nsize_t length ;\nWe\u2019ll assume that all system calls succeed. First, we have to open the \ufb01le and get the size.\nstruct stat sb ;\nint fd = open(argv[1], O_RDONLY) ;\nfstat(fd, &sb) ;\nThen, we need to introduce another variable known as page_offset . mmap doesn\u2019t let the program pass in\nany value as an offset, it needs to be a multiple of the page size. In our case, we will round down.\noff_t page_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1) ;\nThen, we make the call to mmap, here is the order of arguments.\n1.NULL, this tells mmap we don\u2019t need any particular address to start from\n2.length +offset - page_offset, mmaps the \u201crest\u201d of the \ufb01le into memory (starting from offset)\n3.PROT_READ, we want to read the \ufb01le\n4.MAP_PRIVATE, tell the OS, we don\u2019t want to share our mapping\n5.fd, object descriptor that we refer to\n6.pa_offset, the page aligned offset to start from\nchar * addr = mmap(NULL, length + offset - page_offset, PROT_READ,\nMAP_PRIVATE, fd, page_offset) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1814, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d34314bb-13be-4ded-bea4-4b151595da5f": {"__data__": {"id_": "d34314bb-13be-4ded-bea4-4b151595da5f", "embedding": null, "metadata": {"page_label": "201", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0f1a1264-ec42-4ed5-948a-64a1883b02ee", "node_type": "4", "metadata": {"page_label": "201", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "074b4447af410f4ad5906b1cb9f00c920213d219710d02dd509e3f292e718428", "class_name": "RelatedNodeInfo"}}, "text": "9.2. MMAP 201\nNow, we can interact with the address as if it were a normal buffer. After, we have to unmap the \ufb01le and close\nthe \ufb01le descriptor to make sure other system resources are freed.\nwrite(1, addr + offset - page_offset, length) ;\nmunmap(addr, length + offset - pa_offset) ;\nclose(fd) ;\nCheck out the full listing in the man pages.\n9.2.3 MMAP Communication\nSo how would we use mmap to communicate across processes? Conceptually , it would be the same as using\nthreading. Let\u2019s go through a broken down example. First, we need to allocate some space. We can do that with\nthemmap call. We\u2019ll also allocate space for 100 integers\nint size = 100 * sizeof (int);\nvoid *addr = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED |\nMAP_ANONYMOUS, -1, 0) ;\nint *shared = addr ;\nThen, we need to fork and perform some communication. Our parent will store some values, and our child\nwill read those values.\npid_t mychild = fork() ;\nif(mychild >0){\nshared[0] = 10 ;\nshared[1] = 20 ;\n}else {\nsleep(1) ;//Check the synchronization chapter for abetter way\nprintf( \"%d\\n\", shared[1] + shared[0]) ;\n}\nNow, there is no assurance that the values will be communicated because the process used sleep , not a mutex.\nMost of the time this will work.\n#include <stdio.h >\n#include <stdlib.h >\n#include <sys/types.h >\n#include <sys/stat.h >\n#include <sys/mman.h >/*mmap ()isdefined inthis header */", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1378, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c16e524-caca-4bf9-ad43-8bce687bc1da": {"__data__": {"id_": "1c16e524-caca-4bf9-ad43-8bce687bc1da", "embedding": null, "metadata": {"page_label": "202", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9c8a1a6f-0bdb-4f4d-8081-8c911d3bf814", "node_type": "4", "metadata": {"page_label": "202", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f9b05b8cbb990697ee6d667c51cdedf8d6e6aae508740c6cb735162c413e1cd9", "class_name": "RelatedNodeInfo"}}, "text": "202 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\n#include <fcntl.h >\n#include <unistd.h >\n#include <errno.h >\n#include <string.h >\nint main() {\nint size = 100 * sizeof (int);\nvoid *addr = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED |\nMAP_ANONYMOUS, -1, 0) ;\nprintf( \"Mapped at%p\\n\", addr) ;\nint *shared = addr ;\npid_t mychild = fork() ;\nif(mychild >0){\nshared[0] = 10 ;\nshared[1] = 20 ;\n}else {\nsleep(1) ;//Wewill talk about synchronization later\nprintf( \"%d\\n\", shared[1] + shared[0]) ;\n}\nmunmap(addr,size) ;\nreturn 0;\n}\nThis piece of code allocates space for a 100 integers and creates a piece of memory that is shared between all\nprocesses. The code then forks. The parent process writes two integers to the \ufb01rst two slots. To avoid a data race,\nthe child sleeps for a second and then prints out the stored values. This is an imperfect way to protect against\ndata races. We could use a mutex across the processes mentioned in the synchronization section. But for this\nsimple example, it works \ufb01ne. Note that each process should call munmap when done using the piece of memory .\nSharing anonymous memory is an ef\ufb01cient form of inter-process communication because there is no copying,\nsystem call, or disk-access overhead - the two processes share the same physical frame of main memory . On the\nother hand, shared memory , like in a multithreading context, creates room for data races. Processes that share\nwritable memory might need to use synchronization primitives like mutexes to prevent these from happening.\n9.3 Pipes\nYou\u2019ve seen the virtual memory way of IPC, but there are more standard versions of IPC that are provided by the\nkernel. One of the big utilities is POSIX pipes. A pipe simply takes in a stream of bytes and spits out a sequence of\nbytes.\nOne of the big starting points of pipes was way back in the PDP-10 days. In those days, a write to the disk\nor even your terminal was slow as it may have to be printed out. The Unix programmers still wanted to create", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1996, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c3038e20-909c-4975-8f2e-f8d6981f0324": {"__data__": {"id_": "c3038e20-909c-4975-8f2e-f8d6981f0324", "embedding": null, "metadata": {"page_label": "203", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0fa3cadb-bdee-4e32-9bbf-6f4544a28df4", "node_type": "4", "metadata": {"page_label": "203", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f4eb827c3f664f79d973899ae97a8b8ee74bb41828b0b9360255a4be9bf42a65", "class_name": "RelatedNodeInfo"}}, "text": "9.3. PIPES 203\nsmall, portable programs that did one thing well and could be composed. As such, pipes were invented to take\nthe output of one program and feed it to the input of another program though they have other uses today \u2013 you\ncan read more At the Wikipedia page Consider if you type the following into your terminal.\n$ ls -1 | cut -d \u2019.\u2019-f1 | sort | uniq | tee dirents\nWhat does the following code do? First, it lists the current directory . The -1 means that it outputs one entry per\nline. The cutcommand then takes everything before the \ufb01rst period. sort sorts all the input lines, uniq makes\nsure all the lines are unique. Finally , teeoutputs the contents to the \ufb01le dir_contents and the terminal for your\nperusal. The important part is that bash creates 5 separate processes and connects their standard outs /stdins\nwith pipes the trail looks something like this.\n01\nls -1\n01\ncut -d'.' -f1 \n01\nsort\n01\nuniq\n01\ntee dirents\nFigure 9.8: Pipe Process Filedescriptor redirection\nThe numbers in the pipes are the \ufb01le descriptors for each process and the arrow represents the redirect or\nwhere the output of the pipe is going. A POSIX pipe is almost like its real counterpart - a program can stuff bytes\ndown one end and they will appear at the other end in the same order. Unlike real pipes, however, the \ufb02ow is\nalways in the same direction, one \ufb01le descriptor is used for reading and the other for writing. The pipe system\ncall is used to create a pipe. These \ufb01le descriptors can be used with read andwrite . A common method of using\npipes is to create the pipe before forking to communicate with a child process\nint filedes[2] ;\npipe (filedes) ;\npid_t child = fork() ;\nif(child >0){/*Imust bethe parent */\nchar buffer[80] ;\nint bytesread = read(filedes[0], buffer, sizeof (buffer)) ;\n//dosomething with the bytes read\n}else {\nwrite(filedes[1], \"done \", 4) ;\n}\nThere are two \ufb01le descriptors that pipe creates. filedes[0] contains the read end. filedes[1] contains\nthe write end. How your friendly neighborhood TAs remember it is one can read before they can write, or reading\ncomes before writing . You can groan all you want at it, but it is helpful to remember what is the read end and what\nis the write end.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2218, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7508c5f0-c125-4c7d-8958-2077c3110e1f": {"__data__": {"id_": "7508c5f0-c125-4c7d-8958-2077c3110e1f", "embedding": null, "metadata": {"page_label": "204", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "86b27ff7-96bf-45fd-a18e-4c5a531270cd", "node_type": "4", "metadata": {"page_label": "204", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4543c92a26d1034c334442a46fbdbee6d7b3cc2add8076341607b02ec51ebf15", "class_name": "RelatedNodeInfo"}}, "text": "204 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\nOne can use pipes inside of the same process, but there tends to be no added bene\ufb01t. Here\u2019s an example\nprogram that sends a message to itself.\n#include <unistd.h >\n#include <stdlib.h >\n#include <stdio.h >\nint main() {\nint fh[2] ;\npipe(fh) ;\nFILE *reader = fdopen(fh[0], \"r\");\nFILE *writer = fdopen(fh[1], \"w\");\n//Hurrah now Ican use printf\nprintf( \"Writing ...\\ n\");\nfprintf(writer, \"%d%d%d\\n\", 10, 20, 30) ;\nfflush(writer) ;\nprintf( \"Reading ...\\ n\");\nint results[3] ;\nint ok = fscanf(reader, \"%d%d%d\", results, results + 1, results +\n2);\nprintf( \"%dvalues parsed :%d%d%d\\n\", ok, results[0], results[1],\nresults[2]) ;\nreturn 0;\n}\nThe problem with using a pipe in this fashion is that writing to a pipe can block meaning the pipe only has a\nlimited buffering capacity . The maximum size of the buffer is system-dependent; typical values from 4KiB up to\n128KiB though they can be changed.\nint main() {\nint fh[2] ;\npipe(fh) ;\nint b = 0 ;\n#define MESG \"............................... \"\nwhile (1) {\nprintf( \"%d\\n\",b);\nwrite(fh[1], MESG, sizeof (MESG))\nb+=sizeof (MESG) ;\n}\nreturn 0;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1142, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aa507699-fdd4-444d-9652-69e50dd48c78": {"__data__": {"id_": "aa507699-fdd4-444d-9652-69e50dd48c78", "embedding": null, "metadata": {"page_label": "205", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4a967455-ff90-443b-aac0-f253d5cad787", "node_type": "4", "metadata": {"page_label": "205", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a0c6bc09eb30b602eec292fbcba2abb5e0a80e3c4464a085b1e35e95eb948c58", "class_name": "RelatedNodeInfo"}}, "text": "9.3. PIPES 205\n9.3.1 Pipe Gotchas\nHere\u2019s a complete example that doesn\u2019t work! The child reads one byte at a time from the pipe and prints it out -\nbut we never see the message! Can you see why?\n#include <stdio.h >\n#include <stdlib.h >\n#include <unistd.h >\n#include <signal.h >\nint main() {\nint fd[2] ;\npipe(fd) ;\n//You must read from fd[0] and write from fd[1]\nprintf( \"Reading from %d,writing to%d\\n\", fd[0], fd[1]) ;\npid_t p = fork() ;\nif(p>0){\n/*Ihave achild ,therefore Iamthe parent */\nwrite(fd[1], \"HiChild !\",9);\n/*don\u2019tforget your child */\nwait(NULL) ;\n}else {\nchar buf;\nint bytesread ;\n//read one byte atatime .\nwhile ((bytesread = read(fd[0], &buf, 1)) >0){\nputchar(buf) ;\n}\n}\nreturn 0;\n}\nThe parent sends the bytes H,i,(space),C...! into the pipe. The child starts reading the pipe one byte at a\ntime. In the above case, the child process will read and print each character. However, it never leaves the while\nloop! When there are no characters left to read it simply blocks and waits for more unless All the writers close\ntheir ends Another solution could also exit the loop by checking for an end-of-message marker,\nwhile ((bytesread = read(fd[0], &buf, 1)) >0){\nputchar(buf) ;\nif(buf == \u2019!\u2019)break ;/*End ofmessage */\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1232, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "00e5ffb9-21cc-463c-b548-34d571d5095c": {"__data__": {"id_": "00e5ffb9-21cc-463c-b548-34d571d5095c", "embedding": null, "metadata": {"page_label": "206", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "47bafb77-7ede-4031-88a9-d1a15f1b4174", "node_type": "4", "metadata": {"page_label": "206", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c747ce690cc86182d103fba824b8f3436801007dbdfbc820c04748e4ae945f07", "class_name": "RelatedNodeInfo"}}, "text": "206 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\nWe know that when a process tries to read from a pipe where there are still writers, the process blocks. If no\npipe has no writers, read returns 0. If a process tries to write with some reader\u2019s read goes through, or fails \u2013\npartially or completely \u2013 if the pipe is full. Why happens when a process tries to write when there are no readers\nleft?\nIf all file descriptors referring to the read end of a pipe have been closed,\nthen a write(2) will cause a SIGPIPE signal to be generated for the calling process.\nTip: Notice only the writer (not a reader) can use this signal. To inform the reader that a writer is closing\ntheir end of the pipe, a program could write your special byte (e.g. 0xff) or a message ( \"Bye!\" )\nHere\u2019s an example of catching this signal that fails! Can you see why?\n#include <stdio.h >\n#include <stdio.h >\n#include <unistd.h >\n#include <signal.h >\nvoid no_one_listening( int signal) {\nwrite(1, \"Noone islistening !\\n\", 21) ;\n}\nint main() {\nsignal(SIGPIPE, no_one_listening) ;\nint filedes[2] ;\npipe(filedes) ;\npid_t child = fork() ;\nif(child >0){\n/*This process isthe parent .Close the listening end ofthe pipe\n*/\nclose(filedes[0]) ;\n}else {\n/*Child writes messages tothe pipe */\nwrite(filedes[1], \"One\", 3) ;\nsleep(2) ;\n//Will this write generate SIGPIPE ?\nwrite(filedes[1], \"Two\", 3) ;\nwrite(1, \"Done \\n\", 5) ;\n}\nreturn 0;\n}\nThe mistake in the above code is that there is still a reader for the pipe! The child still has the pipe\u2019s \ufb01rst \ufb01le\ndescriptor open and remember the speci\ufb01cation? All readers must be closed\nWhen forking, It is common practice to close the unnecessary (unused) end of each pipe in the child and parent\nprocess. For example, the parent might close the reading end and the child might close the writing end.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1814, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "77dc5ea3-67f1-46c5-8b25-18654893767b": {"__data__": {"id_": "77dc5ea3-67f1-46c5-8b25-18654893767b", "embedding": null, "metadata": {"page_label": "207", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6bb9f562-08b4-482c-879b-f5204c24863c", "node_type": "4", "metadata": {"page_label": "207", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d1134e3fb42078302abaa3e82c71735deccaf885e0d553aed197979c32fe13f2", "class_name": "RelatedNodeInfo"}}, "text": "9.3. PIPES 207\nThe last addendum is that a program can set the \ufb01le descriptor to return when there is no one listening instead\nof SIGPIPE because by default SIGPIPE terminates your program. The reason that this is default behavior is it\nmakes the pipe example above work. Consider this useless use of cat\n$cat /dev/urandom | head -n 20\nWhich grabs 20 lines of input from urandom. head will terminate after 20 newline characters have been read.\nWhat about cat?catneeds to receive a SIGPIPE informing it that the program tried to write to a pipe that no\none is listening on.\n9.3.2 Other pipe facts\nA pipe gets \ufb01lled up when the writer writes too much to the pipe without the reader reading any of it. When the\npipes become full, all writes fail until a read occurs. Even then, a write may partially fail if the pipe has a little bit\nof space left but not enough for the entire message. Usually , two things are done to avoid this. Either increase the\nsize of the pipe. Or more commonly , \ufb01x your program design so that the pipe is constantly being read from.\nAs hinted at before, Pipe writes are atomic up to the size of the pipe. Meaning that if two processes try to\nwrite to the same pipe, the kernel has internal mutexes with the pipe that it will lock, do the write, and return.\nThe only gotcha is when the pipe is about to become full. If two processes are trying to write and the pipe can\nonly satisfy a partial write, that pipe write is not atomic \u2013 be careful about that!\nUnnamed pipes live in memory and are a simple and ef\ufb01cient form of inter-process communication (IPC) that\nis useful for streaming data and simple messages. Once all processes have closed, the pipe resources are freed.\nIt is also common design for a pipe to be one way \u2013 meaning one process should do the writing and one process\ndo the reading. Otherwise, the child would attempt to read its data intended for the parent (and vice versa)!\n9.3.3 Pipes and Dup\nOften, you\u2019ll want to use pipe2 in combination with dup. Take for example the simple program in the command\nline.\n$ ls -1 | cut -f1 -d.\nThis command takes the output of ls -1 which lists the content of the current directory on one line each and\npipes it to cut. Cut take a delimiter, in this case, a dot, and a \ufb01eld position, in our case 1, and outputs per line the\nnth \ufb01eld by each delimiter. At a high level, this grabs the \ufb01le names without the extension of our current directory .\nUnderneath the hood, this is how bash does it internally .\n#define _GNU_SOURCE\n#include <stdio.h >\n#include <fcntl.h >", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2539, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "79e79cc2-8e5c-4d49-bd0a-7d96b1ea98b1": {"__data__": {"id_": "79e79cc2-8e5c-4d49-bd0a-7d96b1ea98b1", "embedding": null, "metadata": {"page_label": "208", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "020c9962-814c-4544-b47d-bd5e088dc0d6", "node_type": "4", "metadata": {"page_label": "208", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "1ede4c6f73e097c2f86b293365f7f6ac0e434401d2d2d4ecd387ceea3724a188", "class_name": "RelatedNodeInfo"}}, "text": "208 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\n#include <unistd.h >\n#include <stdlib.h >\nint main() {\nint pipe_fds[2] ;\n//Call with the O_CLOEXEC flag toprevent any commands from\nblocking\npipe2(pipe_fds, O_CLOEXEC) ;\n//Remember for pipe_fds ,the program read then write (reading is0\nand writing is1)\nif(!fork()) {\n//Child\n//Make the stdout ofthe process ,the write end\ndup2(pipe_fds[1], 1) ;\n//Exec !Don\u2019tforget the cast\nexeclp( \"ls\",\"ls\",\"-1\", (char *)NULL) ;\nexit(-1) ;\n}\n//Same here ,except the stdin ofthe process isthe read end\ndup2(pipe_fds[0], 0) ;\n//Same deal here\nexeclp( \"cut\",\"cut\",\"-f1\",\"-d.\", (char *)NULL) ;\nexit(-1) ;\nreturn 0;\n}\nThe results of the two programs should be the same. Remember as you encounter more complicated examples\nof piping processes up, a program needs to close all unused ends of pipes otherwise the program will deadlock\nwaiting for your processes to \ufb01nish.\n9.3.4 Pipe Conveniences\nIf the program already has a \ufb01le descriptor, it can \u2018wrap\u2019 it yourself into a FILE pointer using fdopen .\n#include <sys/types.h >\n#include <sys/stat.h >\n#include <fcntl.h >", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1106, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b1daa9c1-6268-484b-ba91-072c936296b6": {"__data__": {"id_": "b1daa9c1-6268-484b-ba91-072c936296b6", "embedding": null, "metadata": {"page_label": "209", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3589c68e-a936-4f7c-a72f-b52d267396ae", "node_type": "4", "metadata": {"page_label": "209", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3573095b1a5cac6967702a0f7e8ca9d4c9bcca8368610fbefe476ac81a409030", "class_name": "RelatedNodeInfo"}}, "text": "9.3. PIPES 209\nint main() {\nchar *name= \"Fred \";\nint score = 123 ;\nint filedes = open( \"mydata .txt\",\"w\", O_CREAT, S_IWUSR | S_IRUSR) ;\nFILE *f = fdopen(filedes, \"w\");\nfprintf(f, \"Name :%sScore :%d\\n\", name, score) ;\nfclose(f) ;\nFor writing to \ufb01les, this is unnecessary . Use fopen which does the same as open andfdopen . However for\npipes, we already have a \ufb01le descriptor, so this is a great time to use fdopen\nHere\u2019s a complete example using pipes that almost works! Can you spot the error? Hint: The parent never\nprints anything!\n#include <unistd.h >\n#include <stdlib.h >\n#include <stdio.h >\nint main() {\nint fh[2] ;\npipe(fh) ;\nFILE *reader = fdopen(fh[0], \"r\");\nFILE *writer = fdopen(fh[1], \"w\");\npid_t p = fork() ;\nif(p>0){\nint score ;\nfscanf(reader, \"Score %d\", &score) ;\nprintf( \"The child says the score is%d\\n\", score) ;\n}else {\nfprintf(writer, \"Score %d\", 10 + 10) ;\nfflush(writer) ;\n}\nreturn 0;\n}\nNote the unnamed pipe resource will disappear once both the child and parent have exited. In the above\nexample, the child will send the bytes and the parent will receive the bytes from the pipe. However, no end-of-line\ncharacter is ever sent, so fscanf will continue to ask for bytes because it is waiting for the end of the line i.e. it\nwill wait forever! The \ufb01x is to ensure we send a newline character so that fscanf will return.\nchange: fprintf(writer, \"Score %d\", 10 + 10) ;\nto: fprintf(writer, \"Score %d\\n\", 10 + 10) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1433, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "407468c5-c892-4e1d-8488-10b04bb5cc28": {"__data__": {"id_": "407468c5-c892-4e1d-8488-10b04bb5cc28", "embedding": null, "metadata": {"page_label": "210", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cc07f000-f142-4a45-a1c6-3c973f3ab86d", "node_type": "4", "metadata": {"page_label": "210", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b6e0d140ae1f3cda52b2fc274d77dc852d5d40c84f13d3265e621362a3062a4b", "class_name": "RelatedNodeInfo"}}, "text": "210 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\nIf you want your bytes to be sent to the pipe immediately , you\u2019ll need to f\ufb02ush! Remember back to the\nintroduction section that shows the difference between terminal vs non-terminal outputs of stdout.\nEven though we have a section on it, it is highly not recommended to use the \ufb01le descriptor API for\nnon-seekable \ufb01les . The reason being is that while we get conveniences we also get annoyances like the buffering\nexample we mentioned, caching, etc. The basic C library motto is that any device a program can properly fseek\nor move to an arbitrary position, it should be able to fdopen . Files satisfy this behavior, shared memory also,\nterminals, etc. When it comes to pipes, sockets, epoll objects, etc, don\u2019t do it.\n9.4 Named Pipes\nAn alternative to unnamed pipes is named pipes created using mkfifo . From the command line: mkfifo From C:\nint mkfifo(const char *pathname, mode_t mode);\nYou give it the pathname and the operation mode, it will be ready to go! Named pipes take up virtually no\nspace on a \ufb01le system. This means the actual contents of the pipe aren\u2019t printed to the \ufb01le and read from that\nsame \ufb01le. What the operating system tells you when you have a named pipe is that it will create an unnamed pipe\nthat refers to the named pipe, and that\u2019s it! There is no additional magic. This is for programming convenience if\nprocesses are started without forking meaning that there would be no way to get the \ufb01le descriptor to the child\nprocess for an unnamed pipe.\n9.4.1 Hanging Named Pipes\nA named pipe mkfifo is a pipe that a program calls open(2) on with read and /or write permissions. This is\nuseful if you want to have a pipe between two processes without one processing having to fork the other process.\nThere are some gotchas with named pipes. There is more down below, but we\u2019ll introduce it here for a simple\nexample. Reads and writes hang on Named Pipes until there is at least one reader and one writer, take this.\n1$ mkfifo fifo\n1$echo Hello >fifo\n#This will hang until the following command isrun onanother\nterminal oranother process\n2$cat fifo\nHello\nAnyopen is called on a named pipe the kernel blocks until another process calls the opposite open. Meaning,\necho calls open(.., O_RDONLY) but that blocks until cat calls open(.., O_WRONLY) , then the programs are\nallowed to continue.\n9.4.2 Race condition with named pipes\nWhat is wrong with the following program?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2450, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b45ca332-fa0a-4457-bc18-1ea1396ad35d": {"__data__": {"id_": "b45ca332-fa0a-4457-bc18-1ea1396ad35d", "embedding": null, "metadata": {"page_label": "211", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3e31bb1e-7bca-4f6b-ba14-043a85d9b35f", "node_type": "4", "metadata": {"page_label": "211", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "98d71c1a26eb4300df0f4196ef1145c2086d238dfc854c6a637e61dffb053d3c", "class_name": "RelatedNodeInfo"}}, "text": "9.5. FILES 211\n//Program 1\nint main() {\nint fd = open( \"fifo \", O_RDWR | O_TRUNC) ;\nwrite(fd, \"Hello !\", 6) ;\nclose(fd) ;\nreturn 0;\n}\n//Program 2\nint main() {\nchar buffer[7] ;\nint fd = open( \"fifo \", O_RDONLY) ;\nread(fd, buffer, 6) ;\nbuffer[6] = \u2019\\0\u2019;\nprintf( \"%s\\n\", buffer) ;\nreturn 0;\n}\nThis may never print hello because of a race condition. Since a program opened the pipe in the \ufb01rst process\nunder both permissions, open won\u2019t wait for a reader because the program told the operating system that it is a\nreader! Sometimes it looks like it works because the execution of the code looks something like this.\nTable 9.1: Fine Pipe Access Pattern\nProcess 1 Process 2\nTime 1 open(O_RDWR) & write()\nTime 2 open(O_RDONLY) & read()\nTime 3 close() & exit()\nTime 4 print() & exit()\nBut here is an invalid series of operations that cause a race condition.\nTable 9.2: Pipe Race Condition\nProcess 1 Process 2\nTime 1 open(O_RDWR) & write()\nTime 2 close() & exit()\nTime 3 open(O_RDONLY) (Blocks Inde\ufb01nitely)\n9.5 Files\nOn Linux, there are two abstractions with \ufb01les. The \ufb01rst is the Linux fdlevel abstraction.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1098, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8c3f08ff-0645-46d8-b39f-a201d280897b": {"__data__": {"id_": "8c3f08ff-0645-46d8-b39f-a201d280897b", "embedding": null, "metadata": {"page_label": "212", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cf35a497-039f-4925-b96b-0853163d220e", "node_type": "4", "metadata": {"page_label": "212", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "695bb83812e856b38714f9ab051b91dad54c5cee8fbca585b49071c4ab4408d9", "class_name": "RelatedNodeInfo"}}, "text": "212 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\n\u2022open takes a path to a \ufb01le and creates a \ufb01le descriptor entry in the process table. If the \ufb01le is inaccessible, it\nerrors out.\n\u2022read takes a certain number of bytes that the kernel has received and reads them into a user-space buffer.\nIf the \ufb01le is not open in read mode, this will break.\n\u2022write outputs a certain number of bytes to a \ufb01le descriptor. If the \ufb01le is not open in write mode, this will\nbreak. This may be buffered internally .\n\u2022close removes a \ufb01le descriptor from a process\u2019 \ufb01le descriptors. This always succeeds for a valid \ufb01le\ndescriptor.\n\u2022lseek takes a \ufb01le descriptor and moves it to a certain position. It can fail if the seek is out of bounds.\n\u2022fcntl is the catch-all function for \ufb01le descriptors. Set \ufb01le locks, read, write, edit permissions, etc.\nThe Linux interface is powerful and expressive, but sometimes we need portability for example if we are\nwriting for a Macintosh or windows. This is where C\u2019s abstraction comes into play . On different operating systems,\nC uses the low-level functions to create a wrapper around \ufb01les used everywhere, meaning that C on Linux uses\nthe above calls.\n\u2022fopen opens a \ufb01le and returns an object. null is returned if the program doesn\u2019t have permission for the\n\ufb01le.\n\u2022fread reads a certain number of bytes from a \ufb01le. An error is returned if already at the end of the \ufb01le when\nwhich the program must call feof() to check if the program attempted to read past the end of the \ufb01le.\n\u2022fgetc/fgets Get a char or a string from a \ufb01le\n\u2022fscanf Read a format string from the \ufb01le\n\u2022fwrite Write some objects to a \ufb01le\n\u2022fprintf Write a formatted string to a \ufb01le\n\u2022fclose Close a \ufb01le handle\n\u2022fflush Take any buffered changes and \ufb02ush them to a \ufb01le\n\u2022feof Returns true if you are at the end of a \ufb01le\n\u2022ferror Returns true if an error occured reading, writing or seeking.\n\u2022setvbuf Sets the buffering (None,Line or Full) and the memory used for buffering\nBut programs don\u2019t get the expressiveness that Linux gives with system calls. A program can convert back\nand forth between them with int fileno(FILE* stream) andFILE* fdopen(int fd...) . Also, C \ufb01les are\nbuffered meaning that their contents may be written to the backing after the call returns. You can change that\nwith C options.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2282, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "db6a0687-1441-437f-995e-6c4eb8eb2f1c": {"__data__": {"id_": "db6a0687-1441-437f-995e-6c4eb8eb2f1c", "embedding": null, "metadata": {"page_label": "213", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3973cf5e-04b2-4f24-8bf1-86bfd34c0766", "node_type": "4", "metadata": {"page_label": "213", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e7cbbcfb8c59c587c9b0a3c55b1f7b58904530a0507e8f485e8d9fa4a6a5e46d", "class_name": "RelatedNodeInfo"}}, "text": "9.5. FILES 213\n9.5.1 Determining File Length\nFor \ufb01les less than the size of a long, using fseek and ftell is a simple way to accomplish this. Move to the end of\nthe \ufb01le and \ufb01nd out the current position.\nfseek(f, 0, SEEK_END) ;\nlong pos = ftell(f) ;\nThis tells us the current position in the \ufb01le in bytes - i.e. the length of the \ufb01le!\nfseek can also be used to set the absolute position.\nfseek(f, 0, SEEK_SET) ;//Move tothe start ofthe file\nfseek(f, posn, SEEK_SET) ;//Move to\u2019posn \u2019inthe file .\nAll future reads and writes in the parent or child processes will honor this position. Note writing or reading\nfrom the \ufb01le will change the current position. See the man pages for fseek and ftell for more information.\n9.5.2 Use stat instead\nThis only works on some architectures and compilers That quirk is that longs only need to be 4 Bytes big meaning\nthat the maximum size that ftell can return is a little under 2 Gibibytes. Nowadays, our \ufb01les could be hundreds\nof gibibytes or even terabytes on a distributed \ufb01le system. What should we do instead? Use stat ! We will cover\nstat in a later part but here is some code that will tell a program the size of the \ufb01le\nstruct stat buf ;\nif(stat(filename, &buf) == -1) {\nreturn -1;\n}\nreturn (ssize_t)buf.st_size ;\nbuf.st_size is of type off_t which is big enough for large \ufb01les.\n9.5.3 Gotchas with \ufb01les\nWhat happens when \ufb01le streams are closed by two different processes? Closing a \ufb01le stream is unique to each\nprocess. Other processes can continue to use their \ufb01le handles. Remember, everything is copied over when a child\nis created, even the relative positions of the \ufb01les. As you might have observed with using fork , there is a quirk\nof the implementation of \ufb01les and their caches on Ubuntu that will rewind a \ufb01le descriptor once a \ufb01le has been\nclosed. As such, make sure to close before forking or at least don\u2019t trigger a cache inconsistency which is much\nharder.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1911, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "10e12f1c-8b48-49d4-ab6a-56bc06fa4f41": {"__data__": {"id_": "10e12f1c-8b48-49d4-ab6a-56bc06fa4f41", "embedding": null, "metadata": {"page_label": "214", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "76c870a1-9718-401d-a4b8-31c12741fb34", "node_type": "4", "metadata": {"page_label": "214", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "901e44fc4d8c0d632ac8a337ad66bb7da6aaa0acb6781471631fb1744867c927", "class_name": "RelatedNodeInfo"}}, "text": "214 CHAPTER 9. VIRTUAL MEMORY AND INTERPROCESS COMMUNICATION\n9.6 IPC Alternatives\nOkay so now you have a list of tools in your toolbox to tackle communicating between processes, so what should\nyou use?\nThere is no hard answer, though this is the most interesting question. Generally , we have retained pipes for\nlegacy reasons. This means that we only use them to redirect stdin, stdout, and stderr for the collection of logs\nand similar programs. You may \ufb01nd processes trying to communicate with unnamed or named pipes as well. Most\nof the time you won\u2019t be dealing with this interaction directly though.\nFiles are used almost all the time as a form of IPC. Hadoop is a great example where processes will write to\nappend-only tables and then other processes will read from those tables. We generally use \ufb01les under a few cases.\nOne case is if we want to save the intermediate results of an operation to a \ufb01le for future use. Another case is if\nputting it in memory would cause an out of memory error. On Linux, \ufb01le operations are generally pretty cheap, so\nmost programmers use it for larger intermediate storage.\nmmap is used for two scenarios. One is a linear ornear-linear read through of the \ufb01le. Meaning, a\nprogram reads the \ufb01le front to back or back to front. The key is that the program doesn\u2019t jump around too much.\nJumping around too much causes thrashing and loses all the bene\ufb01ts of using mmap. The other usage of mmap is\nfor direct memory inter-process communication. This means that a program can store structures in a piece of\nmmap\u2019ed memory and share them between two processes. Python and Ruby use this mapping all the time to\nutilize copy on write semantics.\n9.7 Topics\n1.Virtual Memory\n2.Page Table\n3.MMU /TLB\n4.Address Translation\n5.Page Faults\n6.Frames /Pages\n7.Single-level vs multi-level page table\n8.Calculating offsets for multi-level page table\n9.Pipes\n10.Pipe read write ends\n11.Writing to a zero reader pipe\n12.Reading from a zero writer pipe\n13.Named pipe and Unnamed Pipes\n14.Buffer Size /Atomicity\n15.Scheduling Algorithms\n16.Measures of Ef\ufb01ciency", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2078, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4e85057-d88d-4b01-80b1-d21bfc22595d": {"__data__": {"id_": "e4e85057-d88d-4b01-80b1-d21bfc22595d", "embedding": null, "metadata": {"page_label": "215", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a931dbc2-698d-468d-a59a-ac3ef6a6ed5d", "node_type": "4", "metadata": {"page_label": "215", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "0f0860fd6a353ae4f2a49c5c2ee275c4d3e70fdb6f8ad5512b770888b2701e52", "class_name": "RelatedNodeInfo"}}, "text": "9.8. QUESTIONS 215\n9.8 Questions\n1.What is virtual memory?\n2.What are the following and what is their purpose?\n(a)Translation Lookaside Buffer\n(b)Physical Address\n(c)Memory Management Unit. Multilevel page table. Frame number. Page number and page offset.\n(d)The dirty bit\n(e)The NX Bit\n3.What is a page table? How about a physical frame? Does a page always need to point to a physical frame?\n4.What is a page fault? What are the types? When does it result in a SEGFAULT?\n5.What are the advantages to a single-level page table? Disadvantages? How about a multi-level table?\n6.What does a multi-leveled table look like in memory?\n7.How do you determine how many bits are used in the page offset?\n8.Given a 64-bit address space, 4kb pages and frames, and a 3 level page table, how many bits are the Virtual\npage number 1, VPN2, VPN3 and the offset?\n9.What is a pipe? How do we create pipes?\n10.When is SIGPIPE delivered to a process?\n11.Under what conditions will calling read() on a pipe block? Under what conditions will read() immediately\nreturn 0\n12.What is the difference between a named pipe and an unnamed pipe?\n13.Is a pipe thread-safe?\n14.Write a function that uses fseek and ftell to replace the middle character of a \ufb01le with an \u2019X\u2019\n15.Write a function that creates a pipe and uses write to send 5 bytes, \"HELLO\" to the pipe. Return the read \ufb01le\ndescriptor of the pipe.\n16.What happens when you mmap a \ufb01le?\n17.Why is getting the \ufb01le size with ftell not recommended? How should you do it instead?\nBibliography\n[1]Dec pdp-10 ka10 control panel. URL http://www.ricomputermuseum.org/Home/interesting_\ncomputer_items/dec-pdp-ka10 .\n[2]mmap, Jul 2018. URL http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html .\n[3]International Business Machines Corporation (IBM). IBM 709 Data Processing System Reference Manual . Inter-\nnational Business Machines Corporation (IBM). URL http://archive.computerhistory.org/resources/\ntext/Fortran/102653991.05.01.acc.pdf .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1974, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7780dfff-26aa-423f-80db-7ecfcd68c66a": {"__data__": {"id_": "7780dfff-26aa-423f-80db-7ecfcd68c66a", "embedding": null, "metadata": {"page_label": "98", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "beba3d6a-0c00-41ad-8245-0795732d0820", "node_type": "4", "metadata": {"page_label": "98", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c300d80bc72d10a5f95187514f9146b4908742d42a3a99734b49df7ed4fcb3e4", "class_name": "RelatedNodeInfo"}}, "text": "5\nMemory Allocators\nMemory memory everywhere but not an allocation to be made\nA fragmented heap\n5.1 Introduction\nMemory allocation is important! Allocating and deallocating heap memory is one of the most common operations\nin any application. The heap at the system level is contiguous series of addresses that the program can expand or\ncontract and use as its accord [2]. In POSIX, this is called the system break. We use sbrk to move the system\nbreak. Most programs don\u2019t interact directly with this call, they use a memory allocation system around it to\nhandle chunking up and keeping track of which memory is allocated and which is freed.\nWe will mainly be looking into simple allocators. Just know that there are other ways of dividing up memory\nlike with mmap or other allocation schemes and methods like jemalloc .\n5.2 C Memory Allocation API\n\u2022malloc(size_t bytes) is a C library call and is used to reserve a contiguous block of memory that may be\nuninitialized [4, P . 348 ]. Unlike stack memory , the memory remains allocated until free is called with the\nsame pointer. If malloc can either return a pointer to at least that much free space requested or NULL . That\nmeans that malloc can return NULL even if there is some space. Robust programs should check the return\nvalue. If your code assumes malloc succeeds, and it does not, then your program will likely crash (segfault)\nwhen it tries to write to address 0. Also, malloc leaves garbage in memory because of performance \u2013 check\nyour code to make sure that a program all program values are initialized.\n\u2022realloc(void *space, size_t bytes) allows a program to resize an existing memory allocation that\nwas previously allocated on the heap (via malloc, calloc, or realloc) [4, P . 349 ]. The most common use of\nrealloc is to resize memory used to hold an array of values. There are two gotchas with realloc. One, a new\npointer may be returned. Two, it can fail. A naive but readable version of realloc is suggested below with\nsample usage.\n98", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2004, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0d7ae8b6-5030-4348-9273-a1ce4400ca20": {"__data__": {"id_": "0d7ae8b6-5030-4348-9273-a1ce4400ca20", "embedding": null, "metadata": {"page_label": "99", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "422d5eba-01e0-463b-9950-66defc80145d", "node_type": "4", "metadata": {"page_label": "99", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6e721a23529c3d78412f26f3ef975081d08c3aa074f85c368bd0f7fe567cc444", "class_name": "RelatedNodeInfo"}}, "text": "5.2. C MEMORY ALLOCATION API 99\nvoid * realloc( void * ptr, size_t newsize) {\n//Simple implementation always reserves more memory\n//and has noerror checking\nvoid *result = malloc(newsize) ;\nsize_t oldsize = ... //(depends onallocator \u2019sinternal data\nstructure )\nif(ptr) memcpy(result, ptr, newsize <oldsize ? newsize :\noldsize) ;\nfree(ptr) ;\nreturn result ;\n}\nint main() {\n//1\nint *array = malloc( sizeof (int) * 2) ;\narray[0] = 10 ;array[1] = 20 ;\n//Oops need abigger array -souse realloc ..\narray = realloc(array, 3 * sizeof (int));\narray[2] = 30 ;\n}\nThe above code is fragile. If realloc fails then the program leaks memory . Robust code checks for the\nreturn value and only reassigns the original pointer if not NULL.\nint main() {\n//1\nint *array = malloc( sizeof (int) * 2) ;\narray[0] = 10 ;array[1] = 20 ;\nvoid *tmp = realloc(array, 3 * sizeof (int));\nif(tmp == NULL) {\n//Nothing todohere .\n}else if(tmp == array) {\n//realloc returned same space\narray[2] = 30 ;\n}else {\n//realloc returned different space\narray = tmp ;\narray[2] = 30 ;\n}\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1043, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "919e7b9b-909f-4dbd-9884-f26c86cc0e60": {"__data__": {"id_": "919e7b9b-909f-4dbd-9884-f26c86cc0e60", "embedding": null, "metadata": {"page_label": "100", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5b4fd09f-cf8a-40d7-a32b-4c05b37fb621", "node_type": "4", "metadata": {"page_label": "100", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d713fc46398b5e67ad437b0219ab575f1921a9663e42cfd667b5e6f2046e1ee4", "class_name": "RelatedNodeInfo"}}, "text": "100 CHAPTER 5. MEMORY ALLOCATORS\n\u2022calloc(size_t nmemb, size_t size) initializes memory contents to zero and also takes two arguments:\nthe number of items and the size in bytes of each item. An advanced discussion of these limitations is\nin this article. Programmers often use calloc rather than explicitly calling memset after malloc , to set\nthe memory contents to zero because certain performance considerations are taken into account. Note\ncalloc(x,y) is identical to calloc(y,x) , but you should follow the conventions of the manual. A naive\nimplementation of calloc is below.\nvoid *calloc(size_t n, size_t size) {\nsize_t total = n * size ;//Does not check for overflow !\nvoid *result = malloc(total) ;\nif(!result) return NULL ;\n//Ifwe\u2019reusing new memory pages\n//allocated from the system bycalling sbrk\n//then they will bezero sozero -ing out isunnecessary ,\n//Wewill benon-robust and memset either way.\nreturn memset(result, 0, total) ;\n}\n\u2022free takes a pointer to the start of a piece of memory and makes it available for use in subsequent calls to\nthe other allocation functions. This is important because we don\u2019t want every process in our address space\nto take an enormous amount of memory . Once we are done using memory , we stop using it with \u2018free\u2018. A\nsimple usage is below.\nint *ptr = malloc( sizeof (*ptr)) ;\ndo_something(ptr) ;\nfree(ptr) ;\nIf a program uses a piece of memory after it is freed - that is unde\ufb01ned behavior.\n5.2.1 Heaps and sbrk\nThe heap is part of the process memory and varies in size. Heap memory allocation is performed by the C library\nwhen a program calls malloc (calloc ,realloc ) and free . By calling sbrk the C library can increase the size of\nthe heap as your program demands more heap memory . As the heap and stack need to grow, we put them at\nopposite ends of the address space. Stacks don\u2019t grow like a heap, new parts of the stack are allocated for new\nthreads. For typical architectures, the heap will grow upwards and the stack grows downwards.\nNowadays, Modern operating system memory allocators no longer need sbrk . Instead, they can request\nindependent regions of virtual memory and maintain multiple memory regions. For example, gibibyte requests\nmay be placed in a different memory region than small allocation requests. However, this detail is an unwanted\ncomplexity .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2324, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fd255e85-c96f-4be8-8510-b9972ab07405": {"__data__": {"id_": "fd255e85-c96f-4be8-8510-b9972ab07405", "embedding": null, "metadata": {"page_label": "101", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "90cd8423-ad69-4429-b027-53fad49f1557", "node_type": "4", "metadata": {"page_label": "101", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8f8b05e6ad700fb353357d0311438bdc40f8c7ce3ec254ba23dddaad722deef9", "class_name": "RelatedNodeInfo"}}, "text": "5.3. INTRO TO ALLOCATING 101\nPrograms don\u2019t need to call brk orsbrk typically , though calling sbrk(0) can be interesting because it tells a\nprogram where your heap currently ends. Instead programs use malloc ,calloc ,realloc andfree which are\npart of the C library . The internal implementation of these functions may call sbrk when additional heap memory\nis required.\nvoid *top_of_heap = sbrk(0) ;\nmalloc(16384) ;\nvoid *top_of_heap2 = sbrk(0) ;\nprintf( \"The top ofheap went from %pto%p\\n\", top_of_heap,\ntop_of_heap2) ;\n//Example output :The top ofheap went from 0x4000 to0xa000\nNote that the memory that was newly obtained by the operating system must be zeroed out. If the operating\nsystem left the contents of physical RAM as-is, it might be possible for one process to learn about the memory of\nanother process that had previously used the memory . This would be a security leak. Unfortunately , this means\nthat for malloc requests before any memory has been freed is often zero. This is unfortunate because many\nprogrammers mistakenly write C programs that assume allocated memory will always be zero.\nchar * ptr = malloc(300) ;\n//contents isprobably zero because weget brand new memory\n//sobeginner programs appear towork !\n//strcpy (ptr,\"Some data \");//work with the data\nfree(ptr) ;\n//later\nchar *ptr2 = malloc(300) ;//Contents might now contain existing data\nand isprobably not zero\n5.3 Intro to Allocating\nLet\u2019s try to write Malloc. Here is our \ufb01rst attempt at it \u2013 the naive version.\nvoid * malloc(size_t size)\n{\n//Ask the system for more bytes byextending the heap space .\n//sbrk returns -1onfailure\nvoid *p = sbrk(size) ;\nif(p == ( void *) -1) return NULL ;//Nospace left\nreturn p;\n}\nvoid free() {/*Donothing */}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1726, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c1bd448e-09ff-4285-84ee-a49053f29bae": {"__data__": {"id_": "c1bd448e-09ff-4285-84ee-a49053f29bae", "embedding": null, "metadata": {"page_label": "102", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2f24ccb9-6097-4d2b-ba05-cf6a835d6cf8", "node_type": "4", "metadata": {"page_label": "102", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b75eafaeb65eb85934c1034ad60099a401afd157939b238de5be135996aeae3d", "class_name": "RelatedNodeInfo"}}, "text": "102 CHAPTER 5. MEMORY ALLOCATORS\nAbove is the simplest implementation of malloc, there are a few drawbacks though.\n\u2022System calls are slow compared to library calls. We should reserve a large amount of memory and only\noccasionally ask for more from the system.\n\u2022No reuse of freed memory . Our program never re-uses heap memory - it keeps asking for a bigger heap.\nIf this allocator was used in a typical program, the process would quickly exhaust all available memory .\nInstead, we need an allocator that can ef\ufb01ciently use heap space and only ask for more memory when necessary .\nSome programs use this type of allocator. Consider a video game allocating objects to load the next scene. It is\nconsiderably faster to do the above and throw the entire block of memory away than it is to do the following\nplacement strategies.\n5.3.1 Placement Strategies\nDuring program execution, memory is allocated and deallocated, so there will be a gap in the heap memory that\ncan be re-used for future memory requests. The memory allocator needs to keep track of which parts of the heap\nare currently allocated and which are parts are available. Suppose our current heap size is 64K. Let\u2019s say that our\nheap looks like the following table.\n16KiB\nFree10KiB\nAllocated1KiB\nFree1KiB\nAllocated30KiB\nFree4KiB\nAllocated2KiB\nFree\nFigure 5.1: Empty heap blocks\nIf a new malloc request for 2KiB is executed ( malloc(2048) ), where should malloc reserve the memory? It\ncould use the last 2KiB hole, which happens to be the perfect size! Or it could split one of the other two free holes.\nThese choices represent different placement strategies. Whichever hole is chosen, the allocator will need to split\nthe hole into two. The newly allocated space, which will be returned to the program and a smaller hole if there is\nspare space left over. A perfect-\ufb01t strategy \ufb01nds the smallest hole that is of suf\ufb01cient size (at least 2KiB):\n16KiB\nFree10KiB\nAllocated1KiB\nFree1KiB\nAllocated30KiB\nFree4KiB\nAllocated2KiB\nFree\nFigure 5.2: Best \ufb01t \ufb01nds an exact match", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2024, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "48a36d01-fbba-4ee0-a779-8002a3745055": {"__data__": {"id_": "48a36d01-fbba-4ee0-a779-8002a3745055", "embedding": null, "metadata": {"page_label": "103", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b01ffb6e-6570-4e73-97f9-ea92357b20a0", "node_type": "4", "metadata": {"page_label": "103", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "65c6b306381b57fa7d3c783a3fc7e791b3c19b0d1aec82e8527f06b74232f4c2", "class_name": "RelatedNodeInfo"}}, "text": "5.3. INTRO TO ALLOCATING 103\nA worst-\ufb01t strategy \ufb01nds the largest hole that is of suf\ufb01cient size so break the 30KiB hole into two:\n16KiB\nFree10KiB\nAllocated1KiB\nFree1KiB\nAllocated30KiB\nFree4KiB\nAllocated2KiB\nFree\n2KiB\nFree28KiB\nFree\nFigure 5.3: Worst \ufb01t \ufb01nds the worst match\nA \ufb01rst-\ufb01t strategy \ufb01nds the \ufb01rst available hole that is of suf\ufb01cient size so break the 16KiB hole into two. We\ndon\u2019t even have to look through the entire heap!\n16KiB\nFree10KiB\nAllocated1KiB\nFree\n2KiB\nFree14KiB\nFree\nFigure 5.4: First \ufb01t \ufb01nds the \ufb01rst match\nOne thing to keep in mind is those placement strategies don\u2019t need to replace the block. For example, our \ufb01rst\n\ufb01t allocator could\u2019ve returned the original block unbroken. Notice that this would lead to about 14KiB of space to\nbe unused by the user and the allocator. We call this internal fragmentation.\nIn contrast, external fragmentation is that even though we have enough memory in the heap, it may be divided\nup in a way so a continuous block of that size is unavailable. In our previous example, of the 64KiB of heap\nmemory , 17KiB is allocated, and 47KiB is free. However, the largest available block is only 30KiB because our\navailable unallocated heap memory is fragmented into smaller pieces.\n5.3.2 Placement Strategy Pros and Cons\nThe challenges of writing a heap allocator are", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1318, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "999607f1-8b17-4060-8e8c-20ef8efcaa5f": {"__data__": {"id_": "999607f1-8b17-4060-8e8c-20ef8efcaa5f", "embedding": null, "metadata": {"page_label": "104", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "80efb101-c438-4a56-9570-247a51f2d5b5", "node_type": "4", "metadata": {"page_label": "104", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "677ee5b5e1304a5b268ac93c1d3d355b689846aff5f108cc04c9ed2c9e941e39", "class_name": "RelatedNodeInfo"}}, "text": "104 CHAPTER 5. MEMORY ALLOCATORS\n\u2022Need to minimize fragmentation (i.e. maximize memory utilization)\n\u2022Need high performance\n\u2022Fiddly implementation \u2013 lots of pointer manipulation using linked lists and pointer arithmetic.\n\u2022Both fragmentation and performance depend on the application allocation pro\ufb01le, which can be evaluated\nbut not predicted and in practice, under-speci\ufb01c usage conditions, a special-purpose allocator can often\nout-perform a general-purpose implementation.\n\u2022The allocator doesn\u2019t know the program\u2019s memory allocation requests in advance. Even if we did, this is the\nKnapsack problem which is known to be NP-hard!\nDifferent strategies affect the fragmentation of heap memory in non-obvious ways, which only are discovered\nby mathematical analysis or careful simulations under real-world conditions (for example simulating the memory\nallocation requests of a database or webserver).\nFirst, we will have a more mathematical, one-shot approach to each of these algorithms [3]. The paper\ndescribes a scenario where you have a certain number of bins and a certain number of allocations, and you are\ntrying to \ufb01t the allocations in as few bins as possible, hence using as little memory as possible. The paper discusses\ntheoretical implications and puts a nice limit on the ratios in the long run between the ideal memory usage and\nthe actual memory usage. For those who are interested, the paper concludes that actual memory usage over ideal\nmemory usage as the number of bins increases \u2013 the bins can have any distribution \u2013 is about 1.7 for First-Fit and\nlower bounded by 1.7 for best \ufb01t. The problem with this analysis is that few real-world applications need this\ntype of one-shot allocation. Video game object allocations will typically designate a different subheap for each\nlevel and \ufb01ll up that subheap if they need a quick memory allocation scheme that they can throw away .\nIn practice, we\u2019ll be using the result from a more rigorous survey conducted in 2005 [7]. The survey makes\nsure to note that memory allocation is a moving target. A good allocation scheme to one program may not be a\ngood allocation scheme for another program. Programs don\u2019t uniformly follow the distribution of allocations. The\nsurvey talks about all the allocation schemes that we have introduced as well as a few extra ones. Here are some\nsummarized takeaways\n1.Best \ufb01t may have problems when a block is chosen that is almost the right size, and the remaining space is\nsplit so small that a program probably won\u2019t use it. A way to get around this could be to set a threshold for\nsplitting. This small splitting isn\u2019t observed as frequently under a regular workload. Also, the worst-case\nbehavior of Best-Fit is bad, but it doesn\u2019t usually happen [p. 43 ].\n2.The survey also talks about an important distinction of First-Fit. There are multiple notions of \ufb01rst. First\ncould be ordered in terms of the time of \u2018free\u2018\u2019ing, or it could be ordered through the addresses of the start\nof the block, or it could be ordered by the time of last free \u2013 \ufb01rst being least recently used. The survey didn\u2019t\ngo too in-depth into the performance of each but did make a note that address-ordered and Least Recently\nUsed (LRU) lists ended up with better performance than the most recently used \ufb01rst.\n3.The survey concludes by \ufb01rst saying that under simulated random (assuming uniform at random) workloads,\nbest \ufb01t and \ufb01rst \ufb01t do as well. Even in practice, both best and address ordered \ufb01rst \ufb01t do about as equally as\nwell with a splitting threshold and coalescing. The reasons why aren\u2019t entirely known.\nSome additional notes we make\n1.Best \ufb01t may take less time than a full heap scan. When a block of perfect size or perfect size within a\nthreshold is found, that can be returned, depending on what edge-case policy you have.\n2.Worst \ufb01t follows this as well. Your heap could be represented with the max-heap data structure and each\nallocation call could simply pop the top off, re-heapify , and possibly insert a split memory block. Using\nFibonacci heaps, however, could be extremely inef\ufb01cient.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4075, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "97b9fb50-6fd7-4374-88c7-3b3dc47578d1": {"__data__": {"id_": "97b9fb50-6fd7-4374-88c7-3b3dc47578d1", "embedding": null, "metadata": {"page_label": "105", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b23e1269-93f4-4c88-b3b1-37058eafacf2", "node_type": "4", "metadata": {"page_label": "105", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "45d88005a037d9e479c858e334f08144487e0fe980508d6f21700293603251d2", "class_name": "RelatedNodeInfo"}}, "text": "5.4. MEMORY ALLOCATOR TUTORIAL 105\n3.First-Fit needs to have a block order. Most of the time programmers will default to linked lists which is\na \ufb01ne choice. There aren\u2019t too many improvements you can make with a least recently used and most\nrecently used linked list policy , but with address ordered linked lists you can speed up insertion from O(n)\nto O(log(n)) by using a randomized skip-list in conjunction with your singly-linked list. An insert would use\nthe skip list as shortcuts to \ufb01nd the right place to insert the block and removal would go through the list as\nnormal.\n4.There are many placement strategies that we haven\u2019t talked about, one is next-\ufb01t which is \ufb01rst \ufb01t on the\nnext \ufb01t block. This adds deterministic randomness \u2013 pardon the oxymoron. You won\u2019t be expected to know\nthis algorithm, know as you are implementing a memory allocator as part of a machine problem, there are\nmore than these.\n5.4 Memory Allocator Tutorial\nA memory allocator needs to keep track of which bytes are currently allocated and which are available for use.\nThis section introduces the implementation and conceptual details of building an allocator, or the actual code that\nimplements malloc andfree .\nConceptually , we are thinking about creating linked lists and lists of blocks! Please enjoy the following ASCII\nart. bt is short for boundary tag.\nFree\nSpaceMetaUsed\nSpaceFree\nSpacefree()\nTagMeta TagMeta Tag\nFigure 5.5: 3 Adjacent Memory blocks\nWe will have implicit pointers in our next block, meaning that we can get from one block to another using\naddition. This is in contrast to an explicit metadata *next \ufb01eld in our meta block.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1631, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc44d2dd-aef1-4b43-9cc6-59d130ca6d93": {"__data__": {"id_": "fc44d2dd-aef1-4b43-9cc6-59d130ca6d93", "embedding": null, "metadata": {"page_label": "106", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "83632113-3b93-4dbe-8baa-5492636c0cad", "node_type": "4", "metadata": {"page_label": "106", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "78caad2ad7b1456710cdee866936ddd6a94d255a4a182a1b4ab9b39230419d38", "class_name": "RelatedNodeInfo"}}, "text": "106 CHAPTER 5. MEMORY ALLOCATORS\nBT agUsable\nSpaceMetadatachar* p\np+sizeof(meta)+p->size + sizeof(BT ag)p + sizeof(meta)\np+sizeof(meta)+p->size \nFigure 5.6: Malloc addition\nOne can grab the next block by \ufb01nding the end of the current one. That is what we mean by \u201cimplicit list\u201d.\nThe actual spacing may be different. The metadata can contain different things. A minimal metadata\nimplementation would simply have the size of the block.\nSince we write integers and pointers into memory that we already control, we can later consistently hop from\none address to the next. This internal information represents some overhead. Meaning even if we had requested\n1024 KiB of contiguous memory from the system, we an allocation of that size will fail.\nOur heap memory is a list of blocks where each block is either allocated or unallocated. Thus there is\nconceptually a list of free blocks, but it is implicit in the form of block size information that we store as part of\neach block. Let\u2019s think of it in terms of a simple implementation.\ntypedef struct {\nsize_t block_size ;\nchar data[0] ;\n}block ;\nblock *p = sbrk(100) ;\np->size = 100 - sizeof (*p) - sizeof (BTag) ;\n//Other block allocations\nWe could navigate from one block to the next block by adding the block\u2019s size.\np + sizeof (metadata) + p- >block_size + sizeof (BTag)\nMake sure to get your casting right! Otherwise, the program will move an extreme amount of bytes over.\nThe calling program never sees these values. They are internal to the implementation of the memory allocator.\nAs an example, suppose your allocator is asked to reserve 80 bytes ( malloc(80) ) and requires 8 bytes of internal", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1647, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "69d174a5-e926-43c1-b75e-d94e330792d3": {"__data__": {"id_": "69d174a5-e926-43c1-b75e-d94e330792d3", "embedding": null, "metadata": {"page_label": "107", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8ab14ae7-3e5a-47ff-87cc-29d655c0f217", "node_type": "4", "metadata": {"page_label": "107", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "37820b8d406430f340825088e02b6795b99dcb587bd22a404c9d6dc464ffdb69", "class_name": "RelatedNodeInfo"}}, "text": "5.4. MEMORY ALLOCATOR TUTORIAL 107\nheader data. The allocator would need to \ufb01nd an unallocated space of at least 88 bytes. After updating the heap\ndata it would return a pointer to the block. However, the returned pointer points to the usable space, not the\ninternal data! Instead, we would return the start of the block +8 bytes. In the implementation, remember that\npointer arithmetic depends on type. For example, p += 8 adds 8 * sizeof(p) , not necessarily 8 bytes!\n5.4.1 Implementing a Memory Allocator\nThe simplest implementation uses First-Fit. Start at the \ufb01rst block, assuming it exists, and iterate until a block\nthat represents an unallocated space of suf\ufb01cient size is found, or we\u2019ve checked all the blocks. If no suitable\nblock is found, it\u2019s time to call sbrk() again to suf\ufb01ciently extend the size of the heap. For this class, we will try\nto serve every memory request until the operating system tells us we are going to run out of heap space. Other\napplications may limit themselves to a certain heap size and cause requests to intermittently fail. Besides, a fast\nimplementation might extend it a signi\ufb01cant amount so that we will not need to request more heap memory soon.\nWhen a free block is found, it may be larger than the space we need. If so, we will create two entries in our\nimplicit list. The \ufb01rst entry is the allocated block, the second entry is the remaining space. There are ways to do\nthis if the program wants to keep the overhead small. We recommend \ufb01rst for going with readability .\ntypedef struct {\nsize_t block_size ;\nint is_free ;\nchar data[0] ;\n}block ;\nblock *p = sbrk(100) ;\np->size = 100 - sizeof (*p) - sizeof (boundary_tag) ;\n//Other block allocations\nIf the program wants certain bits to hold different pieces of information, use bit \ufb01elds!\ntypedef struct {\nunsigned int block_size : 7 ;\nunsigned int is_free : 1 ;\n}size_free ;\ntypedef struct {\nsize_free info ;\nchar data[0] ;\n}block ;\nThe compiler will handle the shifting. After setting up your \ufb01elds then it becomes simply looping through\neach of the blocks and checking the appropriate \ufb01elds\nHere is a visual representation of what happens. If we assume that we have a block that looks like this, we\nwant to spit if the allocation is let\u2019s say 16 bytes The split we\u2019ll have to do is the following.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2297, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4fc31d55-0109-4f4c-96d7-6d6d45537ae7": {"__data__": {"id_": "4fc31d55-0109-4f4c-96d7-6d6d45537ae7", "embedding": null, "metadata": {"page_label": "108", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b1c36591-ecdc-469b-acee-2323ddd22057", "node_type": "4", "metadata": {"page_label": "108", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e5738402c7454ba917f351d670f0522e950857715fda61268a57878c7b894b73", "class_name": "RelatedNodeInfo"}}, "text": "108 CHAPTER 5. MEMORY ALLOCATORS\nBTag\n4BSpace\n40BMeta\n8B\nBTag\n4BMeta\n8BBTag\n4BMeta\n8B0x0 0x34\n0x34 0x0\nSpace\n16BSpace\n12B0x1C\nFigure 5.7: Malloc split\nThis is before alignment concerns as well.\n5.4.2 Alignment and rounding up considerations\nMany architectures expect multibyte primitives to be aligned to some multiple of 2 (4, 16, etc). For example, it\u2019s\ncommon to require 4-byte types to be aligned to 4-byte boundaries and 8-byte types on 8-byte boundaries. If\nmulti-byte primitives are stored on an unreasonable boundary , the performance can be signi\ufb01cantly impacted\nbecause it may require an additional memory read. On some architectures the penalty is even greater - the\nprogram will crash with a bus error. Most of you have experienced this in your architecture classes if there was no\nmemory protection.\nAsmalloc does not know how the user will use the allocated memory , the pointer returned to the program\nneeds to be aligned for the worst case, which is architecture-dependent.\nFrom glibc documentation, the glibc malloc uses the following heuristic [1]\nThe block that malloc gives you is guaranteed to be aligned so that it can hold any type of data. On\nGNU systems, the address is always a multiple of eight on most systems and a multiple of 16 on 64-bit\nsystems.\" For example, if you need to calculate how many 16 byte units are required, don\u2019t forget to\nround up.\nThis is what the math would look like in C.\nint s = (requested_bytes + tag_overhead_bytes + 15) / 16\nThe additional constant ensures incomplete units are rounded up. Note, real code is more likely to symbol\nsizes e.g. sizeof(x) - 1 , rather than coding numerical constant 15. Here\u2019s a great article on memory alignment,\nif you are further interested\nAnother added effect could be internal fragmentation happens when the given block is larger than their\nallocation size. Let\u2019s say that we have a free block of size 16B (not including metadata). If they allocate 7 bytes,", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1949, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3ddb8602-8d83-4149-bb79-8b931417e4f8": {"__data__": {"id_": "3ddb8602-8d83-4149-bb79-8b931417e4f8", "embedding": null, "metadata": {"page_label": "109", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8b61f980-b631-4fa1-bcb3-4545ef71f0e2", "node_type": "4", "metadata": {"page_label": "109", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4abb2809de058ec19569fc203ffb3bf900e1c4ed2383f8f76985c2e72abeed8c", "class_name": "RelatedNodeInfo"}}, "text": "5.4. MEMORY ALLOCATOR TUTORIAL 109\nthe allocator may want to round up to 16B and return the entire block. This gets sinister when implementing\ncoalescing and splitting. If the allocator doesn\u2019t implement either, it may end up returning a block of size 64B for\na 7B allocation! There is a lotof overhead for that allocation which is what we are trying to avoid.\n5.4.3 Implementing free\nWhen free is called we need to re-apply the offset to get back to the \u2018real\u2019 start of the block \u2013 to where we stored\nthe size information. A naive implementation would simply mark the block as unused. If we are storing the block\nallocation status in a bit\ufb01eld, then we need to clear the bit:\np->info.is_free = 0 ;\nHowever, we have a bit more work to do. If the current block and the next block (if it exists) are both free we\nneed to coalesce these blocks into a single block. Similarly , we also need to check the previous block, too. If that\nexists and represents an unallocated memory , then we need to coalesce the blocks into a single large block.\nTo be able to coalesce a free block with a previous free block we will also need to \ufb01nd the previous block, so\nwe store the block\u2019s size at the end of the block, too. These are called \u201cboundary tags\u201d [5]. These are Knuth\u2019s\nsolution to the coalescing problem both ways. As the blocks are contiguous, the end of one block sits right next to\nthe start of the next block. So the current block (apart from the \ufb01rst one) can look a few bytes further back to\nlook up the size of the previous block. With this information, the allocator can now jump backward!\nTake for example a double coalesce. If we wanted to free the middle block we need to turn the surrounding\nblocks into one big blocks\nFree\nSpaceMetaUsed\nSpaceFree\nSpacefree()\nT ag Meta T ag Meta T ag\nOld Free\nSpace\nMeta T ag\nNew Free SpaceOld\nT agOld\nMetaOld Free\nSpaceOld\nMetaOld\nT agOld Free\nSpace\nFigure 5.8: Free double coalesce", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1921, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8693f4f8-51f1-4936-af4a-9aec63cbf336": {"__data__": {"id_": "8693f4f8-51f1-4936-af4a-9aec63cbf336", "embedding": null, "metadata": {"page_label": "110", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "62807149-20bb-4ea0-88a9-b388296a678b", "node_type": "4", "metadata": {"page_label": "110", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "477ebebf63c26dda1e96dc7eb387d33e4ab7f8c4fa1ea1d4e475c6a1ca3f48e3", "class_name": "RelatedNodeInfo"}}, "text": "110 CHAPTER 5. MEMORY ALLOCATORS\n5.4.4 Performance\nWith the above description, it\u2019s possible to build a memory allocator. Its main advantage is simplicity - at least\nsimple compared to other allocators! Allocating memory is a worst-case linear time operation \u2013 search linked lists\nfor a suf\ufb01ciently large free block. De-allocation is constant time. No more than 3 blocks will need to coalesce into\na single block, and using a most recently used block scheme only one linked list entry .\nUsing this allocator it is possible to experiment with different placement strategies. For example, the allocator\ncould start searching from the last deallocated block. If the allocator stores pointers to blocks, it needs to update\nthe pointers so that they always remain valid.\n5.4.5 Explicit Free Lists Allocators\nBetter performance can be achieved by implementing an explicit doubly-linked list of free nodes. In that case,\nwe can immediately traverse to the next free block and the previous free block. This can reduce the search time\nbecause the linked list only includes unallocated blocks. A second advantage is that we now have some control\nover the ordering of the linked list. For example, when a block is deallocated, we could choose to insert it into the\nbeginning of the linked list rather than always between its neighbors. We may update our struct to look like this\ntypedef struct {\nsize_t info ;\nstruct block *next ;\nchar data[0] ;\n}block ;\nHere is what that would look like along with our implicit linked list\nFree\nSpaceMetaUsed\nSpaceFree\nSpaceTag Meta Tag Meta Tag\nFigure 5.9: Free list\nWhere do we store the pointers of our linked list? A simple trick is to realize that the block itself is not being\nused and store the next and previous pointers as part of the block, though you have to ensure that the free blocks\nare always suf\ufb01ciently large to hold two pointers. We still need to implement Boundary Tags, so we can correctly\nfree blocks and coalesce them with their two neighbors. Consequently , explicit free lists require more code and\ncomplexity . With explicitly linked lists a fast and simple \u2018Find-First\u2019 algorithm is used to \ufb01nd the \ufb01rst suf\ufb01ciently\nlarge link. However, since the link order can be modi\ufb01ed, this corresponds to different placement strategies. If the\nlinks are maintained from largest to smallest, then this produces a \u2018Worst-Fit\u2019 placement strategy .\nThere are edge cases though, consider how to maintain your free list if also double coalescing. We\u2019ve included\na \ufb01gure with a common mistake.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2526, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "29a972bf-47cb-4a45-8421-07873bb6cb4e": {"__data__": {"id_": "29a972bf-47cb-4a45-8421-07873bb6cb4e", "embedding": null, "metadata": {"page_label": "111", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4239e245-38c5-48bf-8c5e-5ab54771505a", "node_type": "4", "metadata": {"page_label": "111", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ce2171cf74a6bc04337d2f292fa8297d9ea8c5a4208532973d4f3f1c0c995081", "class_name": "RelatedNodeInfo"}}, "text": "5.5. CASE STUDY: BUDDY ALLOCATOR, AN EXAMPLE OF A SEGREGATED LIST 111\nFree\nSpaceMetaUsed\nSpaceFree\nSpaceTag Meta Tag Meta Tag\nMeta Tagfree()\nMeta Tag\nFigure 5.10: Free list good and bad coalesce\nWe recommend when trying to implement malloc that you draw out all the cases conceptually and then write\nthe code.\nExplicit linked list insertion policy\nThe newly deallocated block can be inserted easily into two possible positions: at the beginning or in address\norder. Inserting at the beginning creates a LIFO (last-in, \ufb01rst-out) policy . The most recently deallocated spaces\nwill be reused. Studies suggest fragmentation is worse than using address order [7].\nInserting in address order (\u201c Address ordered policy\u201d) inserts deallocated blocks so that the blocks are visited\nin increasing address order. This policy required more time to free a block because the boundary tags (size data)\nmust be used to \ufb01nd the next and previous unallocated blocks. However, there is less fragmentation.\n5.5 Case Study: Buddy Allocator, an example of a segregated\nlist\nA segregated allocator is one that divides the heap into different areas that are handled by different sub-allocators\ndependent on the size of the allocation request. Sizes are grouped into powers of two and each size is handled by\na different sub-allocator and each size maintains its free list.\nA well-known allocator of this type is the buddy allocator [6, P . 85 ]. We\u2019ll discuss the binary buddy allocator\nwhich splits allocation into blocks of size 2n;n=1,2,3, ...times some base unit number of bytes, but others also\nexist like Fibonacci split where the allocation is rounded up to the next Fibonacci number. The basic concept is", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1687, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "40f6b157-58dd-4879-8d02-6cddca160578": {"__data__": {"id_": "40f6b157-58dd-4879-8d02-6cddca160578", "embedding": null, "metadata": {"page_label": "112", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5dc95019-dd8a-4163-ba49-8a86f9bab2be", "node_type": "4", "metadata": {"page_label": "112", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a988af7ab2f5eb484dd40a129e216a74031a58d0872c71e8c19245ec0e07d32d", "class_name": "RelatedNodeInfo"}}, "text": "112 CHAPTER 5. MEMORY ALLOCATORS\nsimple: If there are no free blocks of size 2n, go to the next level and steal that block and split it into two. If two\nneighboring blocks of the same size become unallocated, they can coalesce together into a single large block of\ntwice the size.\nBuddy allocators are fast because the neighboring blocks to coalesce with can be calculated from the deallocated\nblock\u2019s address, rather than traversing the size tags. Ultimate performance often requires a small amount of\nassembler code to use a specialized CPU instruction to \ufb01nd the lowest non-zero bit.\nThe main disadvantage of the Buddy allocator is that they suffer from internal fragmentation because allocations\nare rounded up to the nearest block size. For example, a 68-byte allocation will require a 128-byte block.\n5.6 Case Study: SLUB Allocator, Slab allocation\nThe SLUB allocator is a slab allocator that serves different needs for the Linux kernel SLUB. Imagine you are\ncreating an allocator for the kernel, what are your requirements? Here is a hypothetical shortlist.\n1.First and foremost is you want a low memory footprint to have the kernel be able to be installed on all types\nof hardware: embedded, desktop, supercomputer, etc.\n2.Then, you want the actual memory to be as contiguous as possible to make use of caching. Every time a\nsystem call is performed, the kernel\u2019s pages need to get loaded into memory . This means that if they are all\ncontiguous, the processor will be able to cache them more ef\ufb01ciently\n3.Lastly , you want your allocations to be fast.\nEnter the SLUB allocator kmalloc . The SLUB allocator is a segregated list allocator with minimal splitting and\ncoalescing. The difference here is that the segregated list focuses on more realistic allocation sizes, instead of\npowers of two. SLUB also focuses on a low overall memory footprint while keeping pages in the cache. There are\nblocks of different sizes and the kernel rounds up each allocation request to the lowest block size that satis\ufb01es it.\nOne of the big differences between this allocator and the others is that it usually conforms to page sizes. We\u2019ll talk\nabout virtual memory and pages in another chapter, but the kernel will be working with direct memory pages in\nspans of 4Kib or 4096 Bytes.\n5.7 Further Reading\nGuiding questions\n\u2022Is malloc\u2019ed memory initialized? How about calloc\u2019ed or realloc\u2019ed memory?\n\u2022Does realloc accept, as its argument, the number of elements or space (in bytes)?\n\u2022Why may the allocation functions error?\nSee the man page or the appendix of the book 17.18.1!\n\u2022Slab Allocation\n\u2022Buddy Memory Allocation", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2608, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bb1c3834-e822-46a2-9654-67ed0c7a0650": {"__data__": {"id_": "bb1c3834-e822-46a2-9654-67ed0c7a0650", "embedding": null, "metadata": {"page_label": "113", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b210da89-1cc5-4301-8579-b769944ca6c7", "node_type": "4", "metadata": {"page_label": "113", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "1a6e01b44a6a0a458c3947e64aa5094c763213f3503e782566768cc001d8148e", "class_name": "RelatedNodeInfo"}}, "text": "5.8. TOPICS 113\n5.8 Topics\n\u2022Best Fit\n\u2022Worst Fit\n\u2022First Fit\n\u2022Buddy Allocator\n\u2022Internal Fragmentation\n\u2022External Fragmentation\n\u2022sbrk\n\u2022Natural Alignment\n\u2022Boundary Tag\n\u2022Coalescing\n\u2022Splitting\n\u2022Slab Allocation /Memory Pool\n5.9 Questions /Exercises\n\u2022What is Internal Fragmentation? When does it become an issue?\n\u2022What is External Fragmentation? When does it become an issue?\n\u2022What is a Best Fit placement strategy? How is it with External Fragmentation? Time Complexity?\n\u2022What is a Worst Fit placement strategy? Is it any better with External Fragmentation? Time Complexity?\n\u2022What is the First Fit Placement strategy? It\u2019s a little bit better with Fragmentation, right? Expected Time\nComplexity?\n\u2022Let\u2019s say that we are using a buddy allocator with a new slab of 64kb. How does it go about allocating\n1.5kb?\n\u2022When does the 5 line sbrk implementation of malloc have a use?\n\u2022What is natural alignment?\n\u2022What is Coalescing /Splitting? How do they increase /decrease fragmentation? When can you coalesce or\nsplit?\n\u2022How do boundary tags work? How can they be used to coalesce or split?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1071, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0aeeecfd-2c76-41fc-adbd-6544fc936760": {"__data__": {"id_": "0aeeecfd-2c76-41fc-adbd-6544fc936760", "embedding": null, "metadata": {"page_label": "114", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "835380c0-696a-46f4-ae60-27ff7743de58", "node_type": "4", "metadata": {"page_label": "114", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f7cb9baaf6e62bab9a8770634434e2fb8907a2cca2d2d069defe4b284b2abfb1", "class_name": "RelatedNodeInfo"}}, "text": "114 CHAPTER 5. MEMORY ALLOCATORS\nBibliography\n[1]Virtual memory allocation and paging, May 2001. URL https://ftp.gnu.org/old-gnu/Manuals/\nglibc-2.2.3/html_chapter/libc_3.html .\n[2]Overview of malloc, Mar 2018. URL https://sourceware.org/glibc/wiki/MallocInternals .\n[3]M. R. Garey , R. L. Graham, and J. D. Ullman. Worst-case analysis of memory allocation algorithms. In\nProceedings of the Fourth Annual ACM Symposium on Theory of Computing , STOC \u201972, pages 143\u2013150, New York,\nNY , USA, 1972. ACM. doi: 10.1145 /800152.804907. URL http://doi.acm.org/10.1145/800152.804907 .\n[4]Larry Jones. Wg14 n1539 committee draft iso /iec 9899: 201x, 2010.\n[5]D.E. Knuth. The Art of Computer Programming: Fundamental Algorithms . Number v. 1-2 in Addison-Wesley\nseries in computer science and information processing. Addison-Wesley , 1973. ISBN 9780201038217. URL\nhttps://books.google.com/books?id=dC05RwAACAAJ .\n[6]C.P . Rangan, V . Raman, and R. Ramanujam. Foundations of Software Technology and Theoretical Computer\nScience: 19th Conference, Chennai, India, December 13-15, 1999 Proceedings . FOUNDATIONS OF SOFTWARE\nTECHNOLOGY AND THEORETICAL COMPUTER SCIENCE. Springer, 1999. ISBN 9783540668367. URL\nhttps://books.google.com/books?id=0uHME7EfjQEC .\n[7]Paul R. Wilson, Mark S. Johnstone, Michael Neely , and David Boles. Dynamic storage allocation: A survey\nand critical review. In Henry G. Baler, editor, Memory Management , pages 1\u2013116, Berlin, Heidelberg, 1995.\nSpringer Berlin Heidelberg. ISBN 978-3-540-45511-0.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1508, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ad0dd0eb-f04b-4d4e-8a81-cfdb1c644f8a": {"__data__": {"id_": "ad0dd0eb-f04b-4d4e-8a81-cfdb1c644f8a", "embedding": null, "metadata": {"page_label": "225", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d19893bb-b70c-41e9-b28f-e963217d0772", "node_type": "4", "metadata": {"page_label": "225", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "74f28f0a8079c61d36f3d555fbab2d0400ea25f7fc474d4c273c6d4f123585eb", "class_name": "RelatedNodeInfo"}}, "text": "11\nNetworking\nThe Web as I envisaged it, we have not seen it yet. The future is still\nso much bigger than the past\nTim Berners-Lee\nNetworking has become arguably the most important use of computers in the past 10-20 years. Most of us\nnowadays can\u2019t stand a place without WiFi or any connectivity , so it is crucial as programmers that you have\nan understanding of networking and how to program to communicate across networks. Although it may sound\ncomplicated, POSIX has de\ufb01ned nice standards that make connecting to the outside world easy . POSIX also lets\nyou peer underneath the hood and optimize all the little parts of each connection to write highly performant\nprograms.\nAs an addendum that you\u2019ll read more about in the next chapter, we will be strict in our notation for sizes.\nThat means that when we refer to the SI pre\ufb01xes of Kilo-, Mega-, etc, then we are always referring to a power\nof 10. A kilobyte is one thousand bytes, a megabyte is a thousand kilobytes and so on. If we need to refer to\n1024 bytes, we will use the more accurate term Kibibyte. Mibibyte and Gibibyte are the analogs of Megabyte\nand Gigabyte respectively . We make this distinction to make sure that we aren\u2019t off by 24. The reasons for this\nmisnomer will be explained in the \ufb01lesystems chapter.\n11.1 The OSI Model\nThe Open Source Interconnection 7 layer model (OSI Model) is a sequence of segments that de\ufb01ne standards for\nboth infrastructure and protocols for forms of radio communication, in our case the Internet. The 7 layer model is\nas follows\n1.Layer 1: The Physical Layer. These are the actual waves that carry the bauds across the wire. As an aside,\nbits don\u2019t cross the wire because in most mediums you can alter two characteristics of a wave \u2013 the amplitude\nand the frequency \u2013 and get more bits per clock cycle.\n2.Layer 2: The Link Layer. This is how each of the agents reacts to certain events (error detection, noisy\nchannels, etc). This is where Ethernet and WiFi live.\n3.Layer 3: The Network Layer. This is the heart of the Internet. The bottom two protocols deal with\ncommunication between two different computers that are directly connected. This layer deals with routing\npackets from one endpoint to another.\n225", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2215, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "28c34bd1-c5f6-4ddf-a984-7031ef7e6141": {"__data__": {"id_": "28c34bd1-c5f6-4ddf-a984-7031ef7e6141", "embedding": null, "metadata": {"page_label": "226", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "534eec77-5499-42ab-a7cc-6e08916763ae", "node_type": "4", "metadata": {"page_label": "226", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a7a48ea9df4b6b4f661561c60c6955ff58e378f5600c51bb7c004d63c23f9ffb", "class_name": "RelatedNodeInfo"}}, "text": "226 CHAPTER 11. NETWORKING\n4.Layer 4: The Transport Layer. This layer speci\ufb01es how the slices of data are received. The bottom three\nlayers make no guarantee about the order that packets are received and what happens when a packet is\ndropped. Using different protocols, this layer can.\n5.Layer 5: The Session Layer. This layer makes sure that if a connection in the previous layers is dropped, a\nnew connection in the lower layers can be established, and it looks like nothing happened to the end-user.\n6.Layer 6: The Presentation Layer. This layer deals with encryption, compression, and data translation. For\nexample, portability between different operating systems like translating newlines to windows newlines.\n7.Layer 7: The Application Layer. HTTP and FTP are both de\ufb01ned at this level. This is typically where we\nde\ufb01ne protocols across the Internet. As programmers, we only go lower when we think we can create\nalgorithms that are more suited to our needs than all of the below.\nThis book won\u2019t cover networking in depth. We will focus on some aspects of layers 3, 4, and 7 because they\nare essential to know if you are going to be doing something with the Internet, which at some point in your\ncareer you will be. As for another de\ufb01nition, a protocol is a set of speci\ufb01cations put forward by the Internet\nEngineering Task Force that govern how implementers of a protocol have their program or circuit behave under\nspeci\ufb01c circumstances.\n11.2 Layer 3: The Internet Protocol\nThe following is a short introduction to internet protocol (IP), the primary way to send datagrams of information\nfrom one machine to another. \u201cIP4\u201d, or more precisely , IPv4 is version 4 of the Internet Protocol that describes\nhow to send packets of information across a network from one machine to another. Even as of 2018, IPv4 still\ndominates Internet traf\ufb01c, but google reports that 24 countries now supply 15% of their traf\ufb01c through IPv6 [2].\nA signi\ufb01cant limitation of IPv4 is that source and destination addresses are limited to 32 bits. IPv4 was designed\nat a time when the idea of 4 billion devices connected to the same network was unthinkable or at least not worth\nmaking the packet size larger. IPv4 addresses are written typically in a sequence of four octets delimited by periods\n\"255.255.255.0\" for example.\nEach IPv4 datagram includes a small header - typically 20 octets, that includes a source and destination\naddress. Conceptually the source and destination addresses can be split into two: a network number the upper\nbits and lower bits represent a particular host number on that network.\nA newer packet protocol IPv6 solves many of the limitations of IPv4 like making routing tables simpler and\n128-bit addresses. However, little web traf\ufb01c is IPv6 based on comparison as of 2018 [2]We write IPv6 addresses\nin a sequence of eight, four hexadecimal delimiters like \"1F45:0000:0000:0000:0000:0000:0000:0000\". Since\nthat can get unruly , we can omit the zeros \"1F45::\". A machine can have an IPv6 address and an IPv4 address.\nThere are special IP Addresses. One such in IPv4 is 127.0.0.1 , IPv6 as 0:0:0:0:0:0:0:1 or::1also known\nas localhost. Packets sent to 127.0.0.1 will never leave the machine; the address is speci\ufb01ed to be the same\nmachine. There are a lot of others that are denoted by certain octets being zeros or 255, the maximum value. You\nwon\u2019t need to know all the terminology , keep in mind that the actual number of IP addresses that a machine can\nhave globally over the Internet is smaller than the number of \u201craw\u201d addresses. This book covers how IP deals with\nrouting, fragmenting, and reassembling upper-level protocols. A more in-depth aside follows.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3671, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f994cd55-5e3d-4866-a09c-724b2e5c8911": {"__data__": {"id_": "f994cd55-5e3d-4866-a09c-724b2e5c8911", "embedding": null, "metadata": {"page_label": "227", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ea20ea8f-b79c-43f6-8de4-4a863a9d5c36", "node_type": "4", "metadata": {"page_label": "227", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "dfbf045610564afcecd98a425d1a88b212451b74d801a3a11ba20347f315d53b", "class_name": "RelatedNodeInfo"}}, "text": "11.2. LAYER 3: THE INTERNET PROTOCOL 227\n11.2.1 What\u2019s the deal with IPv6?\n0 32\nSource Address\nDestination AddressVersion Tra c Class Flow Label\nPayload Length Hop Limit Next Header4 12 16 24\nFigure 11.1: IPv6 Datagram divisibility\nOne of the big features of IPv6 is the address space. The world ran out of IP addresses a while ago and has been\nusing hacks to get around that. With IPv6 there are enough internal and external addresses so even if we discover\nalien civilizations, we probably won\u2019t run out. The other bene\ufb01t is that these addresses are leased not bought,\nmeaning that if something drastic happens in let\u2019s say the Internet of things and there needs to be a change in the\nblock addressing scheme, it can be done.\nAnother big feature is security through IPsec. IPv4 was designed with little to no security in mind. As such,\nnow there is a key exchange similar to TLS in higher layers that allows you to encrypt communication.\nAnother feature is simpli\ufb01ed processing. To make the Internet fast, IPv4 and IPv6 headers are veri\ufb01ed in\nhardware. That means that all header options are processed in circuits as they come in. The problem is that as the\nIPv4 spec grew to include a copious amount of headers, the hardware had to become more and more advanced to\nsupport those headers. IPv6 reorders the headers so that packets can be dropped and routed with fewer hardware\ncycles. In the case of the Internet, every cycle matters when trying to route the world\u2019s traf\ufb01c.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1476, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "af858b52-7aca-42fd-93cd-72c1bbd520e8": {"__data__": {"id_": "af858b52-7aca-42fd-93cd-72c1bbd520e8", "embedding": null, "metadata": {"page_label": "228", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "421728b7-8c71-49b4-b01c-db40d671cc7e", "node_type": "4", "metadata": {"page_label": "228", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "139f7cc388d524a97aec077b759ec3e8283bca7624d6a0e7044f6590a6be3ddb", "class_name": "RelatedNodeInfo"}}, "text": "228 CHAPTER 11. NETWORKING\n11.2.2 What\u2019s My Address?\nTo obtain a linked list of IP addresses of the current machine use getifaddrs which will return a linked list of\nIPv4 and IPv6 IP addresses among other interfaces as well. We can examine each entry and use getnameinfo\nto print the host\u2019s IP address. The ifaddrs struct includes the family but does not include the sizeof the struct.\nTherefore we need to manually determine the struct sized based on the family .\n(family == AF_INET) ? sizeof (struct sockaddr_in) : sizeof (struct\nsockaddr_in6)\nThe complete code is shown below.\nint required_family = AF_INET ;//Change toAF_INET6 for IPv6\nstruct ifaddrs *myaddrs, *ifa ;\ngetifaddrs(&myaddrs) ;\nchar host[256], port[256] ;\nfor (ifa = myaddrs ;ifa != NULL ;ifa = ifa- >ifa_next) {\nint family = ifa- >ifa_addr- >sa_family ;\nif(family == required_family && ifa- >ifa_addr) {\nint ret = getnameinfo(ifa- >ifa_addr,\n(family == AF_INET) ? sizeof (struct sockaddr_in) :\nsizeof (struct sockaddr_in6),\nhost, sizeof (host), port, sizeof (port)\n, NI_NUMERICHOST | NI_NUMERICSERV)\nif(0 == ret) {\nputs(host) ;\n}\n}\n}\nTo get your IP Address from the command line use ifconfig or Windows\u2019 ipconfig .\nHowever, this command generates a lot of output for each interface, so we can \ufb01lter the output using grep.\nifconfig | grep inet\nExample output:\ninet6 fe80::1%lo0 prefixlen 64 scopeid 0x1\ninet 127.0.0.1 netmask 0xff000000\ninet6 ::1 prefixlen 128\ninet6 fe80::7256:81ff:fe9a:9141%en1 prefixlen 64 scopeid 0x5\ninet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1550, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "593dc5f5-1409-4e84-87bb-d3211cdadbbc": {"__data__": {"id_": "593dc5f5-1409-4e84-87bb-d3211cdadbbc", "embedding": null, "metadata": {"page_label": "229", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4bb40782-9d07-4fd6-9471-5594a5ece7f9", "node_type": "4", "metadata": {"page_label": "229", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c16a2091614dbe612467e2d96a9cb710505d8136e389f333f6fa64b97dd83ba6", "class_name": "RelatedNodeInfo"}}, "text": "11.2. LAYER 3: THE INTERNET PROTOCOL 229\nTo grab the IP Address of a remote website, The function getaddrinfo can convert a human-readable domain\nname (e.g. www.illinois.edu ) into an IPv4 and IPv6 address. It will return a linked-list of addrinfo structs:\nstruct addrinfo {\nint ai_flags ;\nint ai_family ;\nint ai_socktype ;\nint ai_protocol ;\nsocklen_t ai_addrlen ;\nstruct sockaddr *ai_addr ;\nchar *ai_canonname ;\nstruct addrinfo *ai_next ;\n};\nFor example, suppose you wanted to \ufb01nd out the numeric IPv4 address of a web server at www.bbc.com . We do\nthis in two stages. First, use getaddrinfo to build a linked-list of possible connections. Secondly , use getnameinfo\nto convert the binary address of one of those into a readable form.\n#include <stdio.h >\n#include <stdlib.h >\n#include <sys/types.h >\n#include <sys/socket.h >\n#include <netdb.h >\nstruct addrinfo hints, *infoptr ;//Sononeed touse memset global\nvariables\nint main() {\nhints.ai_family = AF_INET ;//AF_INET means IPv4 only addresses\n//Get the machine addresses\nint result = getaddrinfo( \"www.bbc.com\", NULL, &hints, &infoptr) ;\nif(result) {\nfprintf(stderr, \"getaddrinfo :%s\\n\", gai_strerror(result)) ;\nexit(1) ;\n}\nstruct addrinfo *p ;\nchar host[256] ;\nfor(p = infoptr ;p != NULL ;p = p- >ai_next) {\n//Get the name for all returned addresses\ngetnameinfo(p- >ai_addr, p- >ai_addrlen, host, sizeof (host), NULL, 0,\nNI_NUMERICHOST) ;\nputs(host) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1405, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a53494d2-18bc-4974-b11d-b5bc346bf6ae": {"__data__": {"id_": "a53494d2-18bc-4974-b11d-b5bc346bf6ae", "embedding": null, "metadata": {"page_label": "230", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9d9790f9-0c0d-4abd-a9b2-cac5867c3cb2", "node_type": "4", "metadata": {"page_label": "230", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6c1b768abffaef863cc51335964ecec186feba984bea9605874a06b66ecd66f4", "class_name": "RelatedNodeInfo"}}, "text": "230 CHAPTER 11. NETWORKING\n}\nfreeaddrinfo(infoptr) ;\nreturn 0;\n}\nPossible output.\n212.58.244.70\n212.58.244.71\nOne can specify IPv4 or IPv6 with AF_UNSPEC . Just replace the ai_family attribute in the above code with the\nfollowing.\nhints.ai_family = AF_UNSPEC\nIf you are wondering how the computer maps hostnames to addresses, we will talk about that in Layer 7.\nSpoiler: It is a service called DNS. Before we move onto the next section, it is important to note that a single\nwebsite can have multiple IP addresses. This may be to be ef\ufb01cient with machines. If Google or Facebook has a\nsingle server routing allof their incoming requests to other computers, they\u2019d have to spend massive amounts of\nmoney on that computer or data center. Instead, they can give different regions different IP addresses and have a\ncomputer pick. It isn\u2019t bad to access a website through the non-preferred IP address. The page may load slower.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 922, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8d8e919b-5563-4849-94c3-397b166476a2": {"__data__": {"id_": "8d8e919b-5563-4849-94c3-397b166476a2", "embedding": null, "metadata": {"page_label": "231", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a7a1fac0-f06c-46c7-a259-40c3a0447dc9", "node_type": "4", "metadata": {"page_label": "231", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d25aab84b86160c2b8d8ee96512151e6800761d59609f4dd00c2da051bd1e3a1", "class_name": "RelatedNodeInfo"}}, "text": "11.3. LAYER 4: TCP AND CLIENT 231\n11.3 Layer 4: TCP and Client\n0 16 32\nReserved\nOptions PaddingChecksum Urgent PointerWindowSource Port Destination Port\nSequence Number\nOsetAcknowledgment Number\nFlags\nFigure 11.2: Extra: TCP Header Speci\ufb01cation\nMost services on the Internet today use TCP because it ef\ufb01ciently hides the complexity of the lower, packet-level\nnature of the Internet. TCP or Transport Control Protocol is a connection-based protocol that is built on top of IPv4\nand IPv6 and therefore can be described as \u201cTCP /IP\u201d or \u201cTCP over IP\u201d. TCP creates a pipe between two machines\nand abstracts away the low-level packet-nature of the Internet. Thus, under most conditions, bytes sent over a\nTCP connection delivered and uncorrupted. High performance and error-prone code won\u2019t even assume that!\nTCP has many features that set it apart from the other transport protocol UDP .\n1.Ports With IP , you are only allowed to send packets to a machine. If you want one machine to handle multiple\n\ufb02ows of data, you have to do it manually with IP . TCP gives the programmer a set of virtual sockets. Clients\nspecify the socket that you want the packet sent to and the TCP protocol makes sure that applications that\nare waiting for packets on that port receive that. A process can listen for incoming packets on a particular\nport. However, only processes with super-user (root) access can listen on ports less than 1024. Any process\ncan listen on ports 1024 or higher. A frequently used port is number 80. It is used for unencrypted HTTP\nrequests or web pages. For example, if a web browser connects to http://www.bbc.com/ then it will be\nconnecting to port 80.\n2.Retransmission Packets can get dropped due to network errors or congestion. As such, they need to be\nretransmitted. At the same time, the retransmission shouldn\u2019t cause packets more packets to be dropped.\nThis needs to balance the tradeoff between \ufb02ooding the network and speed.\n3.Out of order packets. Packets may get routed more favorably due to various reasons in IP . If a later packet\narrives before another packet, the protocol should detect and reorder them.\n4.Duplicate packets. Packets can arrive twice. Packets can arrive twice. As such, a protocol needs to be able\nto differentiate between two packets given a sequence number subject to over\ufb02ow.\n5.Error correction. There is a TCP checksum that handles bit errors. This is rarely used though.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2413, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8baf1cec-3823-47a6-9915-5eb8b2a531a7": {"__data__": {"id_": "8baf1cec-3823-47a6-9915-5eb8b2a531a7", "embedding": null, "metadata": {"page_label": "232", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0513a6ff-37d1-49e2-996f-e00190978814", "node_type": "4", "metadata": {"page_label": "232", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "fe75da84bb2f72acc0bb46f725dd17f00fed5ec2415e0811b266dec6e224454c", "class_name": "RelatedNodeInfo"}}, "text": "232 CHAPTER 11. NETWORKING\n6.Flow Control. Flow control is performed on the receiver side. This may be done so that a slow receiver\ndoesn\u2019t get overwhelmed with packets. Servers that handle 10000 or 10 million concurrent connections\nmay need to tell receivers to slow down but remain connected due to load. There is also the problem of\nmaking sure the local network\u2019s traf\ufb01c is stable.\n7.Congestion control. Congestion control is performed on the sender\u2019s side. Congestion control is to avoid a\nsender from \ufb02ooding the network with too many packets. This is important to make sure that each TCP\nconnection is treated fairly . Meaning that two connections leaving a computer to google and youtube receive\nthe same bandwidth and ping as each other. One can easily de\ufb01ne a protocol that takes all the bandwidth\nand leaves other protocols in the dust, but this tends to be malicious because many times limiting a computer\nto a single TCP connection will yield the same result.\n8.Connection-Oriented /life cycle oriented. You can imagine a TCP connection as a series of bytes sent through\na pipe. There is a \u201clifecycle\u201d to a TCP connection though. TCP handles setting up the connection through\nSYN SYN-ACK ACK. This means the client will send a SYNchronization packet that tells TCP what starting\nsequence to start on. Then the receiver will send a SYN-ACK message acknowledging the synchronization\nnumber. Then the client will ACKnowledge that with one last packet. The connection is now open for both\nreading and writing on both ends TCP will send data and the receiver of the data will acknowledge that it\nreceived a packet. Then every so often if a packet is not sent, TCP will trade zero-length packets to make\nsure the connection is still alive. At any point, the client and server can send a FIN packet meaning that\nthe server will not transmit. This packet can be altered with bits that only close the read or write end of a\nparticular connection. When all ends are closed then the connection is over.\nTCP doesn\u2019t provide many things, though.\n1.Security . Connecting to an IP address claiming to be a certain website does not verify the claim (like in\nTLS). You could be sending packets to a malicious computer.\n2.Encryption. Anybody can listen in on plain TCP . The packets in transport are in plain text. Important things\nlike your passwords could easily be skimmed by onlookers.\n3.Session Reconnection. If a TCP connection dies then a whole new one must be created, and the transmission\nhas to be started over again. This is handled by a higher protocol.\n4.Delimiting Requests. TCP is naturally connection-oriented. Applications that are communicating over TCP\nneed to \ufb01nd a unique way of telling each other that this request or response is over. HTTP delimits the\nheader through two carriage returns and uses either a length \ufb01eld or one keeps listening until the connection\ncloses\n11.3.1 Note on network orders\nIntegers can be represented in the least signi\ufb01cant byte \ufb01rst or most signi\ufb01cant byte \ufb01rst. Either approach\nis reasonable as long as the machine itself is internally consistent. For network communications, we need to\nstandardize on the agreed format.\nhtons(xyz) returns the 16-bit unsigned integer \u2018short\u2019 value xyz in network byte order. htonl(xyz) returns\nthe 32-bit unsigned integer \u2018long\u2019 value xyz in network byte order. Any longer integers need to have the computers\nspecify the order.\nThese functions are read as \u2018host to network\u2019. The inverse functions ( ntohs ,ntohl ) convert network ordered\nbyte values to host-ordered ordering. So, is host-ordering little-endian or big-endian? The answer is - it depends", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3634, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e9fee898-bac3-4c9b-9ccf-697f55c4b76c": {"__data__": {"id_": "e9fee898-bac3-4c9b-9ccf-697f55c4b76c", "embedding": null, "metadata": {"page_label": "233", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d163693a-db12-4f49-80f4-20720b5d771a", "node_type": "4", "metadata": {"page_label": "233", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b3518e43eab28da79593ced41d7f2cd1870925d28696baac92d3a68ef478f87c", "class_name": "RelatedNodeInfo"}}, "text": "11.3. LAYER 4: TCP AND CLIENT 233\non your machine! It depends on the actual architecture of the host running the code. If the architecture happens\nto be the same as network ordering then the functions return identical integers. For x86 machines, the host and\nnetwork order are different.\nUnless agreed otherwise, whenever you read or write the low-level C network structures, i.e. port and\naddress information, remember to use the above functions to ensure correct conversion to /from a machine format.\nOtherwise, the displayed or speci\ufb01ed value may be incorrect.\nThis doesn\u2019t apply to protocols that negotiate the endianness before-hand. If two computers are CPU bound by\nconverting the messages between network orders \u2013 this happens with RPCs in high-performance systems \u2013 it may\nbe worth it to negotiate if they are on similar endianness to send in little-endian order.\nWhy is network order de\ufb01ned to be big-endian? The simple answer is that RFC1700 says so [5]. If you want\nmore information, we\u2019ll cite the famous article located that argued for a particular version [3]. The most important\npart is that it is standard. What happens when we don\u2019t have one standard? We have 4 different USB plug types\n(Regular, Micro, Mini, and USB-C) that don\u2019t interact well with each other. Include relevant XKCD here Standards.\n11.3.2 TCP Client\nThere are three basic system calls to connect to a remote machine.\n1.int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);\nThegetaddrinfo call if successful, creates a linked-list of addrinfo structs and sets the given pointer to\npoint to the \ufb01rst one.\nAlso, you can use the hints struct to only grab certain entries like certain IP protocols, etc. The addrinfo\nstructure that is passed into getaddrinfo to de\ufb01ne the kind of connection you\u2019d like. For example, to\nspecify stream-based protocols over IPv6, you can use the following snippet.\nstruct addrinfo hints ;\nmemset(&hints, 0, sizeof (hints)) ;\nhints.ai_family = AF_INET6 ;//Only want IPv6 (use AF_INET for IPv4 )\nhints.ai_socktype = SOCK_STREAM ;//Only want stream -based\nconnection\nThe other modes for \u2018family\u2018 are AF_INET4 andAF_UNSPEC which mean IPv4 and unspeci\ufb01ed respectively .\nThis could be useful if you are searching for a service that you aren\u2019t entirely sure which IP version. Naturally ,\nyou get the version in the \ufb01eld back if you speci\ufb01ed UNSPEC.\nError handling with getaddrinfo is a little different. The return value isthe error code. To convert to a\nhuman-readable error use gai_strerror to get the equivalent short English error text.\nint result = getaddrinfo(...) ;\nif(result) {\nconst char *mesg = gai_strerror(result) ;\n...\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2694, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "393fd87b-db4d-4079-ade3-bd64d9a629e5": {"__data__": {"id_": "393fd87b-db4d-4079-ade3-bd64d9a629e5", "embedding": null, "metadata": {"page_label": "234", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "04e90bd5-78b8-4576-baad-68fca27cb845", "node_type": "4", "metadata": {"page_label": "234", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "833432ac3dc805669bd111011fc2bb67753942a44c977874ee59a0628970668d", "class_name": "RelatedNodeInfo"}}, "text": "234 CHAPTER 11. NETWORKING\n2.int socket(int domain, int socket_type, int protocol);\nThe socket call creates a network socket and returns a descriptor that can be used with read andwrite . In\nthis sense, it is the network analog of open that opens a \ufb01le stream \u2013 except that we haven\u2019t connected the\nsocket to anything yet!\nSockets are created with a domain AF_INET forIPv4 orAF_INET6 forIPv6 ,socket_type is whether to\nuse UDP , TCP , or other some other socket type, the protocol is an optional choice of protocol con\ufb01guration\nfor our examples this we can leave this as 0 for default. This call creates a socket object in the kernel with\nwhich one can communicate with the outside world /network. You can use the result of getaddressinfo\nto \ufb01ll in the socket parameters, or provide them manually .\nThe socket call returns an integer - a \ufb01le descriptor - and, for TCP clients, you can use it as a regular \ufb01le\ndescriptor. You can use read andwrite to receive or send packets.\nTCP sockets are similar to pipes and are often used in situations that require IPC. We don\u2019t mention it\nin the previous chapters because it is overkill using a device suited for networks to simply communicate\nbetween processes on a single thread.\n3.connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\nFinally , the connect call attempts the connection to the remote machine. We pass the original socket\ndescriptor and also the socket address information which is stored inside the addrinfo structure. There are\ndifferent kinds of socket address structures that can require more memory . So in addition to passing the\npointer, the size of the structure is also passed. To help identify errors and mistakes it is good practice to\ncheck the return value of all networking calls, including connect\n//Pull out the socket address info from the addrinfo struct :\nconnect(sockfd, p- >ai_addr, p- >ai_addrlen)\n4.(Optional) To clean up code call freeaddrinfo(struct addrinfo *ai) on the \ufb01rst level addrinfo struct.\nThere is an old function gethostbyname is deprecated. It\u2019s the old way convert a hostname into an IP address.\nThe port address still needs to be manually set using htons function. It\u2019s much easier to write code to support\nIPv4 AND IPv6 using the newer getaddrinfo\nThis is all that is needed to create a simple TCP client. However, network communications offer many different\nlevels of abstraction and several attributes and options that can be set at each level. For example, we haven\u2019t\ntalked about setsockopt which can manipulate options for the socket. You can also mess around with lower\nprotocols as the kernel provides primitives that contribute to this. Note that you need to be root to create a raw\nsocket. Also, you need to have a lot of \u201cset up\u201d or starter code, be prepared to have your datagrams be dropped\ndue to bad form as well. For more information see this guide.\n11.3.3 Sending some data\nOnce we have a successful connection we can read or write like any old \ufb01le descriptor. Keep in mind if you are\nconnected to a website, you want to conform to the HTTP protocol speci\ufb01cation to get any sort of meaningful\nresults back. There are libraries to do this. Usually , you don\u2019t connect at the socket level. The number of bytes\nread or written may be smaller than expected. Thus, it is important to check the return value of read and write .\nA simple HTTP client that sends a request to a compliant URL is below. First, we\u2019ll start with the boring stuff and\nthe parsing code.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3484, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9bcf0375-2f27-4609-a9ed-c32d6ecea9d2": {"__data__": {"id_": "9bcf0375-2f27-4609-a9ed-c32d6ecea9d2", "embedding": null, "metadata": {"page_label": "235", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "51aad2c8-e317-409c-acc2-6c68a59b386d", "node_type": "4", "metadata": {"page_label": "235", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "1e6ae59d02f8ed5e69d607ee58fbf8fde68b5b02775613a29681b98c3a0a54db", "class_name": "RelatedNodeInfo"}}, "text": "11.3. LAYER 4: TCP AND CLIENT 235\ntypedef struct _host_info {\nchar *hostname ;\nchar *port ;\nchar *resource ;\n}host_info ;\nhost_info *get_info( char *uri) {\n//... Parses the URI/URL\n}\nvoid free_info(host_info *info) {\n//... Frees any info\n}\nint main( int argc, char *argv[]) {\nif(argc != 2) {\nfprintf(stderr, \"Usage :%shttp ://hostname [:port ]/path \\n\", *argv) ;\nreturn 1;\n}\nchar *uri = argv[1] ;\nhost_info *info = get_info(uri) ;\nhost_info *temp = send_request(info) ;\nreturn 0;\n}\nThe code that sends the request is below. The \ufb01rst thing that we have to do is connect to an address.\nstruct addrinfo current, *result ;\nmemset(&current, 0, sizeof (struct addrinfo)) ;\ncurrent.ai_family = AF_INET ;\ncurrent.ai_socktype = SOCK_STREAM ;\ngetaddrinfo(info- >hostname, info- >port, &current, &result) ;\nconnect(sock_fd, result- >ai_addr, result- >ai_addrlen)\nfreeaddrinfo(result) ;\nThe next piece of code sends the request. Here is what each header means.\n1.\"GET %s HTTP /1.0\" This is the request verb interpolated with the path. This means to perform the GET\nverb on the path using the HTTP /1.0 method.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1097, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4fdf45c8-d8c6-4a47-afcb-dabb3f624306": {"__data__": {"id_": "4fdf45c8-d8c6-4a47-afcb-dabb3f624306", "embedding": null, "metadata": {"page_label": "236", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "355a0b1d-e050-4e4e-8118-e13795aecd31", "node_type": "4", "metadata": {"page_label": "236", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "451a6591f37799782496c895fc1c6ddb1f8d96f084cc41ca542fc4a9e52e189b", "class_name": "RelatedNodeInfo"}}, "text": "236 CHAPTER 11. NETWORKING\n2.\"Connection: close\" Means that as soon as the request is over, please close the connection. This line won\u2019t\nbe used for any other connections. This is a little redundant given that HTTP 1.0 doesn\u2019t allow you to send\nmultiple requests, but it is better to be explicit given there are non-conformant technologies.\n3.\"Accept: * /*\" This means that the client is willing to accept anything.\nA more robust piece of code would also check if the write fails or if the call was interrupted.\nchar *buffer ;\nasprintf(&buffer,\n\"GET %sHTTP /1.0\\ r\\n\"\n\"Connection :close \\r\\n\"\n\"Accept :*/*\\ r\\n\\r\\n\",\ninfo- >resource) ;\nwrite(sock_fd, buffer, strlen(buffer)) ;\nfree(buffer) ;\nThe last piece of code is the driver code that sends the request. Feel free to use the following code if you\nwant to open the \ufb01le descriptor as a FILE object for convenience functions. Just be careful not to forget to set the\nbuffering to zero otherwise you may double buffer the input, which would lead to performance problems.\nvoid send_request(host_info *info) {\nint sock_fd = socket(AF_INET, SOCK_STREAM, 0) ;\n//Re-use address isalittle overkill here because weare making a\n//Listen only server and wedon\u2019texpect spoofed requests .\nint optval = 1 ;\nint retval = setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &optval,\nsizeof (optval)) ;\nif(retval == -1) {\nperror( \"setsockopt \");\nexit(1) ;\n}\n//Connect using code snippet\n//Send the get request\n//Open soyou can use getline\nFILE *sock_file = fdopen(sock_fd, \"r+\");\nsetvbuf(sock_file, NULL, _IONBF, 0) ;\nret = handle_okay(sock_file) ;\nfclose(sock_file) ;\nclose(sock_fd) ;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1616, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2f6dff31-e8f9-4543-bfe4-79aecbf87d39": {"__data__": {"id_": "2f6dff31-e8f9-4543-bfe4-79aecbf87d39", "embedding": null, "metadata": {"page_label": "237", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2aa3f0ba-12df-4f3a-ac5a-6dc7763d04cd", "node_type": "4", "metadata": {"page_label": "237", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ebfcb5425e74a6f174c05b69dff38b3285eeb8e0fe89624ec86816f3904e53e9", "class_name": "RelatedNodeInfo"}}, "text": "11.4. LAYER 4: TCP SERVER 237\nThe example above demonstrates a request to the server using the HyperText Transfer Protocol. In general,\nthere are six parts\n1.The method. GET , POST , etc.\n2.The resource. \u201c /\u201d \u201c/index.html\u201d \u201c /image.png\u201d\n3.The protocol \u201cHTTP /1.0\u201d\n4.A new line ( rn). Requests always have a carriage return.\n5.Any other knobs or switch parameters\n6.The actual body of the request delimited by two new lines. The body of the request is either if the size is\nspeci\ufb01ed or until the receiver closes their connection.\nThe server\u2019s \ufb01rst response line describes the HTTP version used and whether the request is successful using a\n3 digit response code.\nHTTP/1.1 200 OK\nIf the client had requested a non-existent path, e.g. GET /nosuchfile.html HTTP/1.0 Then the \ufb01rst line\nincludes the response code is the well-known 404response code.\nHTTP/1.1 404 Not Found\nFor more information, RFC 7231 has the most current speci\ufb01cations on the most common HTTP method today\n[4].\n11.4 Layer 4: TCP Server\nThe four system calls required to create a minimal TCP server are socket ,bind ,listen , and accept . Each has\na speci\ufb01c purpose and should be called in roughly the above order\n1.int socket(int domain, int socket_type, int protocol)\nTo create an endpoint for networking communication. A new socket by itself is stores bytes. Though we\u2019ve\nspeci\ufb01ed either a packet or stream-based connections, it is unbound to a particular network interface or\nport. Instead, socket returns a network descriptor that can be used with later calls to bind, listen and accept.\nAs one gotcha, these sockets must be declared passive. Passive server sockets wait for another host to\nconnect. Instead, they wait for incoming connections. Additionally , server sockets remain open when the\npeer disconnects. Instead, the client communicates with a separate active socket on the server that is speci\ufb01c\nto that connection.\nSince a TCP connection is de\ufb01ned by the sender address and port along with a receiver address and port,\na particular server port there can be one passive server socket but multiple active sockets. One for each\ncurrently open connection. The server\u2019s operating system maintains a lookup table that associates a unique\ntuple with active sockets so that incoming packets can be correctly routed to the correct socket.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2309, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24253d98-a89b-4f85-bd8c-89782a193bcd": {"__data__": {"id_": "24253d98-a89b-4f85-bd8c-89782a193bcd", "embedding": null, "metadata": {"page_label": "238", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ffb92656-4510-4f1d-a9a8-6daf413e70ec", "node_type": "4", "metadata": {"page_label": "238", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d901a005cbb9548d3e36d111e292738bb7af5a7c12e069a940238454d43953c1", "class_name": "RelatedNodeInfo"}}, "text": "238 CHAPTER 11. NETWORKING\n2.int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\nThebind call associates an abstract socket with an actual network interface and port. It is possible to call\nbind on a TCP client. The port information used by bind can be set manually (many older IPv4-only C code\nexamples do this), or be created using getaddrinfo .\nBy default, a port is released after some time when the server socket is closed. Instead, the port enters a\n\u201cTIMED-WAIT\u201d state. This can lead to signi\ufb01cant confusion during development because the timeout can\nmake valid networking code appear to fail.\nTo be able to immediately reuse a port, specify SO_REUSEPORT before binding to the port.\nint optval = 1 ;\nsetsockopt(sfd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof (optval)) ;\nbind(...) ;\nHere\u2019s an extended stackover\ufb02ow introductory discussion of SO_REUSEPORT .\n3.int listen(int sockfd, int backlog);\nThelisten call speci\ufb01es the queue size for the number of incoming, unhandled connections. There are the\nconnections unassigned to a \ufb01le descriptor by accept . Typical values for a high-performance server are 128\nor more.\n4.int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\nOnce the server socket has been initialized the server calls accept to wait for new connections. Unlike\nsocket bind andlisten , this call will block, unless the nonblocking option has been set. If there are no\nnew connections, this call will block and only return when a new client connects. The returned TCP socket\nis associated with a particular tuple (client IP, client port, server IP, server port) and will\nbe used for all future incoming and outgoing TCP packets that match this tuple.\nNote the accept call returns a new \ufb01le descriptor. This \ufb01le descriptor is speci\ufb01c to a particular client. It is\na common programming mistake to use the original server socket descriptor for the server I /O and then\nwonder why networking code has failed.\nTheaccept system call can optionally provide information about the remote client, by passing in a sockaddr\nstruct. Different protocols have different variants of the struct sockaddr , which are different sizes. The\nsimplest struct to use is the sockaddr_storage which is suf\ufb01ciently large to represent all possible types of\nsockaddr. Notice that C does not have any model of inheritance. Therefore we need to explicitly cast our\nstruct to the \u2018base type\u2019 struct sockaddr.\nstruct sockaddr_storage clientaddr ;\nsocklen_t clientaddrsize = sizeof (clientaddr) ;\nint client_id = accept(passive_socket,\n(struct sockaddr *) &clientaddr,\n&clientaddrsize) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2603, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "23e3e992-2796-422d-b59b-12b7a933c4a3": {"__data__": {"id_": "23e3e992-2796-422d-b59b-12b7a933c4a3", "embedding": null, "metadata": {"page_label": "239", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "991644ea-d5cb-43ab-9a3f-f18e7b808f76", "node_type": "4", "metadata": {"page_label": "239", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "fa5516e6fd148e029a211b40ede1c9e439daaffb41895bd8b396f3ec91f8cac9", "class_name": "RelatedNodeInfo"}}, "text": "11.4. LAYER 4: TCP SERVER 239\nWe\u2019ve already seen getaddrinfo that can build a linked list of addrinfo entries and each one of these\ncan include socket con\ufb01guration data. What if we wanted to turn socket data into IP and port addresses?\nEnter getnameinfo that can be used to convert local or remote socket information into a domain name\nor numeric IP . Similarly , the port number can be represented as a service name. For example, port 80 is\ncommonly used as the incoming connection port for incoming HTTP requests. In the example below, we\nrequest numeric versions for the client IP address and client port number.\nsocklen_t clientaddrsize = sizeof (clientaddr) ;\nint client_id = accept(sock_id, ( struct sockaddr *) &clientaddr,\n&clientaddrsize) ;\nchar host[NI_MAXHOST], port[NI_MAXSERV] ;\ngetnameinfo(( struct sockaddr *) &clientaddr,\nclientaddrsize, host, sizeof (host), port, sizeof (port),\nNI_NUMERICHOST | NI_NUMERICSERV) ;\nOne can use the macros NI_MAXHOST to denote the maximum length of a hostname, and NI_MAXSERV to\ndenote the maximum length of a port. NI_NUMERICHOST gets the hostname as a numeric IP address and\nsimilarly for NI_NUMERICSERV although the port is usually numeric, to begin with. The Open BSD man\npages have more information\n5.int close(int fd) andint shutdown(int fd, int how)\nUse the shutdown call when you no longer need to read any more data from the socket, write more data,\nor have \ufb01nished doing both. When you call shutdown on socket on the read and /or write ends, that\ninformation is also sent to the other end of the connection. If you shut down the socket for further writing\nat the server end, then a moment later, a blocked read call could return 0 to indicate that no more bytes\nare expected. Similarly , a write to a TCP connection that has been shut down for reading will generate a\nSIGPIPE\nUseclose when your process no longer needs the socket \ufb01le descriptor.\nIf you fork -ed after creating a socket \ufb01le descriptor, all processes need to close the socket before the socket\nresources can be reused. If you shut down a socket for further read, all processes are affected because\nyou\u2019ve changed the socket, not the \ufb01le descriptor. Well written code will shutdown a socket before calling\nclose it.\nThere are a few gotchas to creating a server.\n\u2022Using the socket descriptor of the passive server socket (described above)\n\u2022Not specifying SOCK_STREAM requirement for getaddrinfo\n\u2022Not being able to reuse an existing port.\n\u2022Not initializing the unused struct entries\n\u2022Thebind call will fail if the port is currently in use. Ports are per machine \u2013 not per process or user. In other\nwords, you cannot use port 1234 while another process is using that port. Worse, ports are by default \u2018tied\nup\u2019 after a process has \ufb01nished.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2758, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fbfcd7a6-967d-4c74-bf2a-b2ca457349c0": {"__data__": {"id_": "fbfcd7a6-967d-4c74-bf2a-b2ca457349c0", "embedding": null, "metadata": {"page_label": "240", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "26739b1e-9b08-4610-bd98-2c3d1e56b1df", "node_type": "4", "metadata": {"page_label": "240", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "dd9e8cf9f9eb2bcc2b2ccdc04192b0467ff7ee3613092a177e5c674b28c8cae9", "class_name": "RelatedNodeInfo"}}, "text": "240 CHAPTER 11. NETWORKING\n11.4.1 Example Server\nA working simple server example is shown below. Note: this example is incomplete. For example, the socket \ufb01le\ndescriptor remains open and memory created by getaddrinfo remains allocated. First, we get the address info\nfor our current machine.\nstruct addrinfo hints, *result ;\nmemset(&hints, 0, sizeof (struct addrinfo)) ;\nhints.ai_family = AF_INET ;\nhints.ai_socktype = SOCK_STREAM ;\nhints.ai_flags = AI_PASSIVE ;\nint s = getaddrinfo(NULL, \"1234 \", &hints, &result) ;\nif(s != 0) {\nfprintf(stderr, \"getaddrinfo :%s\\n\", gai_strerror(s)) ;\nexit(1) ;\n}\nThen we set up the socket, bind it, and listen.\nint sock_fd = socket(AF_INET, SOCK_STREAM, 0) ;\n//Bind and listen\nif(bind(sock_fd, result- >ai_addr, result- >ai_addrlen) != 0) {\nperror( \"bind ()\");\nexit(1) ;\n}\nif(listen(sock_fd, 10) != 0) {\nperror( \"listen ()\");\nexit(1) ;\n}\nWe are \ufb01nally ready to listen for connections, so we\u2019ll tell the user and accept our \ufb01rst client.\nstruct sockaddr_in *result_addr = ( struct sockaddr_in *)\nresult- >ai_addr ;\nprintf( \"Listening onfile descriptor %d,port %d\\n\", sock_fd,\nntohs(result_addr- >sin_port)) ;\n//Waiting for connections like apassive socket\nprintf( \"Waiting for connection ...\\ n\");\nint client_fd = accept(sock_fd, NULL, NULL) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1276, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a63a7445-23b5-4364-bef9-b25d6175d40b": {"__data__": {"id_": "a63a7445-23b5-4364-bef9-b25d6175d40b", "embedding": null, "metadata": {"page_label": "241", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3d64891d-cbfb-479a-acc5-7c2439671a15", "node_type": "4", "metadata": {"page_label": "241", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "5d8b53fe882e51229f737d6dc87a13090608ac6a885506e85dbabdf8c61d709e", "class_name": "RelatedNodeInfo"}}, "text": "11.4. LAYER 4: TCP SERVER 241\nprintf( \"Connection made :client_fd =%d\\n\", client_fd) ;\nAfter that, we can treat the new \ufb01le descriptor as a stream of bytes much like a pipe.\nchar buffer[1000] ;\n//Could get interrupted\nint len = read(client_fd, buffer, sizeof (buffer) - 1) ;\nbuffer[len] = \u2019\\0\u2019;\nprintf( \"Read %dchars \\n\", len) ;\nprintf( \"===\\ n\");\nprintf( \"%s\\n\", buffer) ;\n[language =C]\n11.4.2 Sorry To Interrupt\nOne concept that we need to make clear is that you need to handle interrupts in your networking code. That\nmeans that the sockets or accepted \ufb01le descriptors that you read to or write to may have their calls interrupted \u2013\nmost of the time you will get an interrupt or two. In reality , any of your system calls could get interrupted. The\nreason we bring this up now is that you are usually waiting for the network. Which is an order of magnitude\nslower than processes. Meaning a higher probability of getting interrupted.\nHow would you handle interrupts? Let\u2019s try a quick example.\nwhile bytes_read isn \u2019tcount {\nbytes_read +=read (fd,buf,count );\niferror isEINTR {\ncontinue ;\n}else {\nbreak ;\n}\n}\nWe can assure you that the following code experience errors . Can you see why? On the surface, it does restart a\ncall after a read or write. But what else happens when the error is EINTR? Are the contents of the buffer correct?\nWhat other problems can you spot?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1372, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "80660fb5-3b2a-4a58-b318-213b8803fae8": {"__data__": {"id_": "80660fb5-3b2a-4a58-b318-213b8803fae8", "embedding": null, "metadata": {"page_label": "242", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "adb98f3b-d644-4796-86d1-fdcd0a21d197", "node_type": "4", "metadata": {"page_label": "242", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "53b15e01665899dd2772312fdf45529845d8416da49c570db22f24c6308d1f19", "class_name": "RelatedNodeInfo"}}, "text": "242 CHAPTER 11. NETWORKING\n11.5 Layer 4: UDP\nUDP is a connectionless protocol that is built on top of IPv4 and IPv6. It\u2019s simple to use. Decide the destination\naddress and port and send your data packet! However, the network makes no guarantee about whether the\npackets will arrive. Packets may be dropped if the network is congested. Packets may be duplicated or arrive out\nof order.\nA typical use case for UDP is when receiving up to date data is more important than receiving all of the data.\nFor example, a game may send continuous updates of player positions. A streaming video signal may send picture\nupdates using UDP\n11.5.1 UDP Attributes\n\u2022Unreliable Datagram Protocol Packets sent through UDP may be dropped on their way to the destination.\nThis can especially be confusing because if you only test on your loop-back device \u2013 this is localhost or\n127.0.0.1 for most users \u2013 then packets will seldom be lost because no network packets are sent.\n\u2022Simple The UDP protocol is supposed to have much less \ufb02uff than TCP . Meaning that for TCP there are a lot\nof con\ufb01gurable parameters and a lot of edge cases in the implementation. UDP is \ufb01re and forget.\n\u2022Stateless /Transaction The UDP protocol is stateless. This makes the protocol more simple and lets the\nprotocol represent simple transactions like requesting or responding to queries. There is also less overhead\nto sending a UDP message because there is no three-way handshake.\n\u2022Manual Flow /Congestion Control You have to manually manage the \ufb02ow and congestion control which is\na double-edged sword. On one hand, you have full control over everything. On the other hand, TCP has\ndecades of optimization, meaning your protocol for its use cases needs to be more ef\ufb01cient that to be more\nbene\ufb01cial to use it.\n\u2022Multicast This is one thing that you can only do with UDP . This means that you can send a message to every\npeer connected to a particular router that is part of a particular group.\nThe full gory description is available at the original RFC [1].\nWhile it may seem that you never want to use UDP for situations that you don\u2019t want to lose data, a lot of\nprotocols base their communication based on UDP that requires complete data. Take a look at the Trivial File\nTransfer Protocol that reliably transmits a \ufb01le over the wire using UDP only . Of course, there is more con\ufb01guration\ninvolved, but choosing between UDP over TCP involves more than the above factors.\n11.5.2 UDP Client\nUDP Clients are pretty versatile below is a simple client that sends a packet to a server speci\ufb01ed through the\ncommand line. Note that this client sends a packet and doesn\u2019t wait for an acknowledgment. It \ufb01res and forgets.\nThe example below also uses gethostbyname because some legacy functionality still works pretty well for setting\nup a client.\nstruct sockaddr_in addr ;\nmemset(&addr, 0, sizeof (addr)) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2853, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a1afa5c9-b630-41d4-a131-4ebfd857c431": {"__data__": {"id_": "a1afa5c9-b630-41d4-a131-4ebfd857c431", "embedding": null, "metadata": {"page_label": "243", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b36374c6-dd3c-47d9-b0c4-e1da34b314ac", "node_type": "4", "metadata": {"page_label": "243", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "272d146f68fd06e47920941deb46ea47412daba465967628448ed1790825a9e7", "class_name": "RelatedNodeInfo"}}, "text": "11.5. LAYER 4: UDP 243\naddr.sin_family = AF_INET ;\naddr.sin_port = htons((uint16_t)port) ;\nstruct hostent *serv = gethostbyname(hostname) ;\nThe previous code grabs an entry hostent that matches by hostname. Even though this isn\u2019t portable, it\ngets the job done. First is to connect to it and make it reusable \u2013 the same as a TCP socket. Note that we pass\nSOCK_DGRAM instead of SOCK_STREAM .\nint sockfd = socket(AF_INET, SOCK_DGRAM, 0) ;\nint optval = 1 ;\nsetsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof (optval)) ;\nThen, we can copy over our hostent struct into the sockaddr_in struct. Full de\ufb01nitions are provided in the\nman pages so it is safe to copy them over.\nmemcpy(&addr.sin_addr.s_addr, serv- >h_addr, serv- >h_length) ;\nThen a \ufb01nal useful part of UDP is that we can time out receiving a packet as opposed to TCP because UDP isn\u2019t\nconnection-oriented. The snippet to do that is below.\nstruct timeval tv ;\ntv.tv_sec = 0 ;\ntv.tv_usec = SOCKET_TIMEOUT ;\nsetsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof (tv)) ;\nNow, the socket is connected and ready to use. We can use sendto to send a packet. We should also check\nthe return value. Note that we won\u2019t get an error if the packet isn\u2019t delivered because that is a part of the UDP\nprotocol. We will, however, get error codes for invalid structs, bad addresses, etc.\nchar *to_send = \"Hello !\"\nint send_ret = sendto(sock_fd, //Socket\nto_send, //Data\nstrlen(to_send), //Length ofdata\n0,//Flags\n(struct sockaddr *)&ipaddr, //Address\nsizeof (ipaddr)) ;//How long the address is\nThe above code simply sends \u201cHello\u201d through a UDP . There is no idea of if the packet arrives, is processed, etc.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1658, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b3cb46e9-82c7-4e43-92ee-b723a886cb76": {"__data__": {"id_": "b3cb46e9-82c7-4e43-92ee-b723a886cb76", "embedding": null, "metadata": {"page_label": "244", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c496cf3f-db7c-4676-96e3-985300013278", "node_type": "4", "metadata": {"page_label": "244", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f8547aabd7c2fb2302bbbc96232309c278beb9c3462c64f38bf2addcdd6b53fa", "class_name": "RelatedNodeInfo"}}, "text": "244 CHAPTER 11. NETWORKING\n11.5.3 UDP Server\nThere are a variety of function calls available to send UDP sockets. We will use the newer getaddrinfo to help set\nup a socket structure. Remember that UDP is a simple packet-based (\u2018datagram\u2019) protocol. There is no connection\nto set up between the two hosts. First, initialize the hints addrinfo struct to request an IPv6, passive datagram\nsocket.\nmemset(&hints, 0, sizeof (hints)) ;\nhints.ai_family = AF_INET6 ;\nhints.ai_socktype = SOCK_DGRAM ;\nhints.ai_flags = AI_PASSIVE ;\nNext, use getaddrinfo to specify the port number. We don\u2019t need to specify a host as we are creating a server\nsocket, not sending a packet to a remote host. Be careful not to send \u201clocalhost\u201d or any other synonym for the\nloop-back address. We may end up trying to passively listen to ourselves and resulting in bind errors.\ngetaddrinfo(NULL, \"300\", &hints, &res) ;\nsockfd = socket(res- >ai_family, res- >ai_socktype, res- >ai_protocol) ;\nbind(sockfd, res- >ai_addr, res- >ai_addrlen) ;\nThe port number is less than 1024, so the program will need root privileges. We could have also speci\ufb01ed a\nservice name instead of a numeric port value.\nSo far, the calls have been similar to a TCP server. For a stream-based service, we would call listen and\naccept. For our UDP-server, the program can start waiting for the arrival of a packet.\nstruct sockaddr_storage addr ;\nint addrlen = sizeof (addr) ;\n//ssize_t recvfrom (int socket ,void *buffer ,size_t buflen ,int flags ,\nstruct sockaddr *addr ,socklen_t *address_len );\nbyte_count = recvfrom(sockfd, buf, sizeof (buf), 0, &addr, &addrlen) ;\nThe addr struct will hold the sender (source) information about the arriving packet. Note the sockaddr_storage\ntype is suf\ufb01ciently large enough to hold all possible types of socket addresses \u2013 IPv4, IPv6 or any other Internet\nProtocol. The full UDP server code is below.\n#include <string.h >\n#include <stdio.h >\n#include <stdlib.h >", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1940, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "01a131bf-931b-41c0-b9a8-d0b787b60b1b": {"__data__": {"id_": "01a131bf-931b-41c0-b9a8-d0b787b60b1b", "embedding": null, "metadata": {"page_label": "245", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3936185a-e789-4c20-9a73-0436893c3cf5", "node_type": "4", "metadata": {"page_label": "245", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c98ea071f96aca425353a7ec5bbb2820ba117d7345ebe49ae7a1610c06cabad5", "class_name": "RelatedNodeInfo"}}, "text": "11.5. LAYER 4: UDP 245\n#include <sys/types.h >\n#include <sys/socket.h >\n#include <netdb.h >\n#include <unistd.h >\n#include <arpa/inet.h >\nint main( int argc, char **argv) {\nstruct addrinfo hints, *res ;\nmemset(&hints, 0, sizeof (hints)) ;\nhints.ai_family = AF_INET6 ;//INET for IPv4\nhints.ai_socktype = SOCK_DGRAM ;\nhints.ai_flags = AI_PASSIVE ;\ngetaddrinfo(NULL, \"300\", &hints, &res) ;\nint sockfd = socket(res- >ai_family, res- >ai_socktype,\nres- >ai_protocol) ;\nif(bind(sockfd, res- >ai_addr, res- >ai_addrlen) != 0) {\nperror( \"bind ()\");\nexit(1) ;\n}\nstruct sockaddr_storage addr ;\nint addrlen = sizeof (addr) ;\nwhile (1){\nchar buf[1024] ;\nssize_t byte_count = recvfrom(sockfd, buf, sizeof (buf), 0, &addr,\n&addrlen) ;\nbuf[byte_count] = \u2019\\0\u2019;\nprintf( \"Read %dchars \\n\", byte_count) ;\nprintf( \"===\\ n\");\nprintf( \"%s\\n\", buf) ;\n}\nreturn 0;\n}\nNote that if you perform a partial read from a packet, the rest of that data is discarded. One call to recvfrom is\none packet. To make sure that you have enough space, use 64 KiB as storage space.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1037, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0e7b9a01-5615-4c29-944c-6006634acbe7": {"__data__": {"id_": "0e7b9a01-5615-4c29-944c-6006634acbe7", "embedding": null, "metadata": {"page_label": "246", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d489f49e-eb06-4d55-bedc-9fcde8ebfa8b", "node_type": "4", "metadata": {"page_label": "246", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f869d353d06ce6e5baf5370b8628ae806efce209e0aa0a93126a7361e7e82834", "class_name": "RelatedNodeInfo"}}, "text": "246 CHAPTER 11. NETWORKING\n11.6 Layer 7: HTTP\nLayer 7 of the OSI layer deals with application-level interfaces. Meaning that you can ignore everything below\nthis layer and treat the Internet as a way of communicating with another computer than can be secure and the\nsession may reconnect. Common layer 7 protocols are the following\n1.HTTP(S) - Hypertext Transfer Protocol. Sends arbitrary data and executes remote actions on a web server.\nThe S standards for secure where the TCP connection uses the TLS protocol to ensure that the communication\ncan\u2019t be read easily by an onlooker.\n2.FTP - File Transfer Protocol. Transfers a \ufb01le from one computer to another\n3.TFTP - Trivial File Transfer Protocol. Same as above but using UDP .\n4.DNS - Domain Name Service. Translates hostnames to IP addresses\n5.SMTP - Simple Mail Transfer Protocol. Allows one to send plain text emails to an email server\n6.SSH - Secure SHell. Allows one computer to connect to another computer and execute commands remotely .\n7.Bitcoin - Decentralized cryptocurrency\n8.BitTorrent - Peer to peer \ufb01le sharing protocol\n9.NTP - Network Time Protocol. This protocol helps keep your computer\u2019s clock synced with the outside world\n11.6.1 What\u2019s my name?\nRemember when we were talking before about converting a website to an IP address? A system called \u201cDNS\u201d\n(Domain Name Service) is used. If the IP address is missing form a machine\u2019s cache then it sends a UDP packet to\na local DNS server. This server may query other upstream DNS servers.\nDNS by itself is fast but insecure. DNS requests are unencrypted and susceptible to \u2018man-in-the-middle\u2019 attacks.\nFor example, a coffee shop internet connection could easily subvert your DNS requests and send back different IP\naddresses for a particular domain. The way this is usually subverted is that after the IP address is obtained then a\nconnection is usually made over HTTPS. HTTPS uses what is called the TLS (formerly known as SSL) to secure\ntransmissions and verify that the hostname is recognized by a Certi\ufb01cate Authority . Certi\ufb01cate Authorities often\nget hacked so be careful of equating a green lock to secure. Even with this added layer of security , the united\nstates government has recently issued a request for everyone to upgrade their DNS to DNSSec which includes\nadditional security-focused technologies to verify with high probability that an IP address is truly associated with\na hostname.\nDigression aside, DNS works like this in a nutshell\n1.Send a UDP packet to your DNS server\n2.If that DNS server has the packet cached return the result\n3.If not, ask higher-level DNS servers for the answer. Cache and send the result\n4.If either packet is not answered from within a guessed timeout, resend the request.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2737, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "89b7b66a-1610-4e8b-ab23-afb22c3a0b82": {"__data__": {"id_": "89b7b66a-1610-4e8b-ab23-afb22c3a0b82", "embedding": null, "metadata": {"page_label": "247", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1167e740-3499-4055-80d8-2b1e36c0db47", "node_type": "4", "metadata": {"page_label": "247", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "458982a0f22be57e264e96f9ada140dc8f07d1a66b7bb433210a61de9f2cd24f", "class_name": "RelatedNodeInfo"}}, "text": "11.7. NON-BLOCKING IO 247\nIf you want the full bits and pieces, feel free to look at the Wikipedia page. In essence, there is a hierarchy\nof DNS servers. First, there is the dot hierarchy . This hierarchy \ufb01rst resolves top-level domains .edu .gov etc.\nNext, it resolves the next level i.e. illinois.edu . Then the local resolvers can resolve any number of URLs.\nFor example, the Illinois DNS server handles both cs.illinois.edu andcs341.cs.illinois.edu . There is a\nlimit on how many subdomains you can have, but this is often used to route requests to different servers to avoid\nhaving to buy many high performant servers to route requests.\n11.7 Non-Blocking IO\nWhen you call read() if the data is unavailable, it will wait until the data is ready before the function returns.\nWhen you\u2019re reading data from a disk, that delay is short, but when you\u2019re reading from a slow network connection,\nrequests take a long time. And the data may never arrive, leading to an unexpected close.\nPOSIX lets you set a \ufb02ag on a \ufb01le descriptor such that any call to read() on that \ufb01le descriptor will return\nimmediately , whether it has \ufb01nished or not. With your \ufb01le descriptor in this mode, your call to read() will start\nthe read operation, and while it\u2019s working you can do other useful work. This is called \u201cnon-blocking\u201d mode since\nthe call to read() doesn\u2019t block.\nTo set a \ufb01le descriptor to be non-blocking.\n//fdismyfile descriptor\nint flags = fcntl(fd, F_GETFL, 0) ;\nfcntl(fd, F_SETFL, flags | O_NONBLOCK) ;\nFor a socket, you can create it in non-blocking mode by adding SOCK_NONBLOCK to the second argument to\nsocket() :\nfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0) ;\nWhen a \ufb01le is in non-blocking mode and you call read() , it will return immediately with whatever bytes are\navailable. Say 100 bytes have arrived from the server at the other end of your socket and you call read(fd, buf, 150) .\n\u2018read\u2018 will return immediately with a value of 100, meaning it read 100 of the 150 bytes you asked for. Say you\ntried to read the remaining data with a call to read(fd, buf+100, 50) , but the last 50 bytes still hadn\u2019t arrived\nyet.read() would return -1 and set the global error variable errno to either EAGAIN orEWOULDBLOCK . That\u2019s the\nsystem\u2019s way of telling you the data isn\u2019t ready yet.\nwrite() also works in non-blocking mode. Say you want to send 40,000 bytes to a remote server using a\nsocket. The system can only send so many bytes at a time. In non-blocking mode, write(fd, buf, 40000)\nwould return the number of bytes it was able to send immediately , or about 23,000. If you called write() right\naway again, it would return -1 and set errno to EAGAIN orEWOULDBLOCK . That\u2019s the system\u2019s way of telling you\nthat it\u2019s still busy sending the last chunk of data and isn\u2019t ready to send more yet.\nThere are a few ways to check that your IO has arrived. Let\u2019s see how to do it using select and epoll . The \ufb01rst\ninterface we have is select. It isn\u2019t preferred by many in the POSIX community if they have an alternative to it,\nand in most cases there is an alternative to it.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3076, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8390c7ad-db5d-42ab-85fd-fb64a86090a9": {"__data__": {"id_": "8390c7ad-db5d-42ab-85fd-fb64a86090a9", "embedding": null, "metadata": {"page_label": "248", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5d2fa64f-63ad-4567-937f-80cd736792cb", "node_type": "4", "metadata": {"page_label": "248", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ac2fab64b8bdf2786fb895e35f8ff8f911bb3bcad03f4f9be444e357cfebc884", "class_name": "RelatedNodeInfo"}}, "text": "248 CHAPTER 11. NETWORKING\nint select( int nfds,\nfd_set *readfds,\nfd_set *writefds,\nfd_set *exceptfds,\nstruct timeval *timeout) ;\nGiven three sets of \ufb01le descriptors, select() will wait for any of those \ufb01le descriptors to become \u2018ready\u2019.\n1.readfds - a \ufb01le descriptor in readfds is ready when there is data that can be read or EOF has been reached.\n2.writefds - a \ufb01le descriptor in writefds is ready when a call to write() will succeed.\n3.exceptfds - system-speci\ufb01c, not well-de\ufb01ned. Just pass NULL for this.\nselect() returns the total number of ready \ufb01le descriptors. If none of them become ready during the time\nde\ufb01ned by timeout , it will return 0. After select() returns, the caller will need to loop through the \ufb01le descriptors\nin readfds and /or writefds to see which ones are ready . As readfds and writefds act as both input and output\nparameters, when select() indicates that there are ready \ufb01le descriptors, it would have overwritten them to\nre\ufb02ect only the ready \ufb01le descriptors. Unless the caller intends to call select() only once, it would be a good\nidea to save a copy of readfds and writefds before calling it. Here is a comprehensive snippet.\nfd_set readfds, writefds ;\nFD_ZERO(&readfds) ;\nFD_ZERO(&writefds) ;\nfor (int i=0;i<read_fd_count ;i++)\nFD_SET(my_read_fds[i], &readfds) ;\nfor (int i=0;i<write_fd_count ;i++)\nFD_SET(my_write_fds[i], &writefds) ;\nstruct timeval timeout ;\ntimeout.tv_sec = 3 ;\ntimeout.tv_usec = 0 ;\nint num_ready = select(FD_SETSIZE, &readfds, &writefds, NULL, &timeout) ;\nif(num_ready <0){\nperror( \"error inselect ()\");\n}else if(num_ready == 0) {\nprintf( \"timeout \\n\");\n}else {\nfor (int i=0;i<read_fd_count ;i++)\nif(FD_ISSET(my_read_fds[i], &readfds))\nprintf( \"fd%disready for reading \\n\", my_read_fds[i]) ;\nfor (int i=0;i<write_fd_count ;i++)\nif(FD_ISSET(my_write_fds[i], &writefds))\nprintf( \"fd%disready for writing \\n\", my_write_fds[i]) ;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1883, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f006e955-5ac8-4f98-b1ca-e7e4c1ea1c2d": {"__data__": {"id_": "f006e955-5ac8-4f98-b1ca-e7e4c1ea1c2d", "embedding": null, "metadata": {"page_label": "249", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "61ca1e37-ff76-487d-89b5-0e104b4f162f", "node_type": "4", "metadata": {"page_label": "249", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "5c38d32a7337d78915a9cb733c30cecbec39554a4f87b033c9277e834888cbca", "class_name": "RelatedNodeInfo"}}, "text": "11.7. NON-BLOCKING IO 249\nFor more information on select() The problem with select and why a lot of users don\u2019t use this or poll is that\nselect must linearly go through each of the objects. If at any point in going through the objects, the previous\nobjects change state, select must restart. This is highly inef\ufb01cient if we have a large number of \ufb01le descriptors in\neach of our sets. There is an alternative, that isn\u2019t much better.\n11.7.1 epoll\nepoll is not part of POSIX, but it is supported by Linux. It is a more ef\ufb01cient way to wait for many \ufb01le descriptors.\nIt will tell you exactly which descriptors are ready . It even gives you a way to store a small amount of data\nwith each descriptor, like an array index or a pointer, making it easier to access your data associated with that\ndescriptor.\nFirst, you must create a special \ufb01le descriptor with epoll_create(). You won\u2019t read or write to this \ufb01le descriptor.\nYou\u2019ll pass it to the other epoll_xxx functions and call close() on it at the end.\nint epfd = epoll_create(1) ;\nFor each \ufb01le descriptor that you want to monitor with epoll, you\u2019ll need to add it to the epoll data structures\nusing epoll_ctl() with the EPOLL_CTL_ADD option. You can add any number of \ufb01le descriptors to it.\nstruct epoll_event event ;\nevent.events = EPOLLOUT ;//EPOLLIN ==read ,EPOLLOUT ==write\nevent.data.ptr = mypointer ;\nepoll_ctl(epfd, EPOLL_CTL_ADD, mypointer- >fd, &event)\nTo wait for some of the \ufb01le descriptors to become ready , use epoll_wait(). The epoll_event struct that it \ufb01lls\nout will contain the data you provided in event.data when you added this \ufb01le descriptor. This makes it easy for\nyou to look up your data associated with this \ufb01le descriptor.\nint num_ready = epoll_wait(epfd, &event, 1, timeout_milliseconds) ;\nif(num_ready >0){\nMyData *mypointer = (MyData*) event.data.ptr ;\nprintf( \"ready towrite on%d\\n\", mypointer- >fd);\n}\nSay you were waiting to write data to a \ufb01le descriptor, but now you want to wait to read data from it. Just use\nepoll_ctl() with the EPOLL_CTL_MOD option to change the type of operation you\u2019re monitoring.\nevent.events = EPOLLOUT ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2111, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b152d274-605e-4e2d-84eb-5ab56cf61540": {"__data__": {"id_": "b152d274-605e-4e2d-84eb-5ab56cf61540", "embedding": null, "metadata": {"page_label": "250", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "45f1e8bc-cd76-454a-9209-6481d61aaf2f", "node_type": "4", "metadata": {"page_label": "250", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "df4cd0fe5783b7498d555783978786b6d1e6770c9a1fea259e76b474d42afb80", "class_name": "RelatedNodeInfo"}}, "text": "250 CHAPTER 11. NETWORKING\nevent.data.ptr = mypointer ;\nepoll_ctl(epfd, EPOLL_CTL_MOD, mypointer- >fd, &event) ;\nTo unsubscribe one \ufb01le descriptor from epoll while leaving others active, use epoll_ctl() with the EPOLL_CTL_DEL\noption.\nepoll_ctl(epfd, EPOLL_CTL_DEL, mypointer- >fd, NULL) ;\nTo shut down an epoll instance, close its \ufb01le descriptor.\nclose(epfd) ;\nAlso to non-blocking read() andwrite() , any calls to connect() on a non-blocking socket will also be\nnon-blocking. To wait for the connection to complete, use select() or epoll to wait for the socket to be writable.\nThere are reasons to use epoll over select but due to interface, there are fundamental problems with doing so.\nBlogpost about select being broken\n11.7.2 Epoll Example\nLet\u2019s break down the epoll code in the man page. We\u2019ll assume that we have a prepared TCP server socket\nint listen_sock . The \ufb01rst thing we have to do is create the epoll device.\nepollfd = epoll_create1(0) ;\nif(epollfd == -1) {\nperror( \"epoll_create1 \");\nexit(EXIT_FAILURE) ;\n}\nThe next step is to add the listen socket in level triggered mode.\n//This file object will be\u2018read \u2018from (connect istechnically aread\noperation )\nev.events = EPOLLIN ;\nev.data.fd = listen_sock ;\n//Add the socket inwith all the other fds.Everything isafile\ndescriptor\nif(epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\nperror( \"epoll_ctl :listen_sock \");", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1389, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fe1108ab-fe1a-438f-8cd5-07474c5960c7": {"__data__": {"id_": "fe1108ab-fe1a-438f-8cd5-07474c5960c7", "embedding": null, "metadata": {"page_label": "251", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9124a20b-faf2-4a4e-b484-4be817e719e3", "node_type": "4", "metadata": {"page_label": "251", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "65a6746b20a992c81c3f58f124ab7752b29cb17c54ecbe918b5180ca38ba79fd", "class_name": "RelatedNodeInfo"}}, "text": "11.7. NON-BLOCKING IO 251\nexit(EXIT_FAILURE) ;\n}\nThen in a loop, we wait and see if epoll has any events.\nstruct epoll_event ev, events[MAX_EVENTS] ;\nnfds = epoll_wait(epollfd, events, MAX_EVENTS, -1) ;\nif(nfds == -1) {\nperror( \"epoll_wait \");\nexit(EXIT_FAILURE) ;\n}\nIf we get an event on a client socket, that means that the client has data ready to be read, and we perform that\noperation. Otherwise, we need to update our epoll structure with a new client.\nif(events[n].data.fd == listen_sock) {\nint conn_sock = accept(listen_sock, ( struct sockaddr *) &addr,\n&addrlen) ;\n//Must set tonon-blocking\nsetnonblocking(conn_sock) ;\n//Wewill read from this file ,and weonly want toreturn once\n//wehave something toread from .Wedon\u2019twant tokeep getting\n//reminded ifthere isstill data left (edge triggered )\nev.events = EPOLLIN | EPOLLET ;\nev.data.fd = conn_sock ;\nepoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, &ev)\n}\nThe function above is missing some error checking for brevity as well. Note that this code is performant\nbecause we added the server socket in level-triggered mode and we add each of the client \ufb01le descriptors in\nedge-triggered. Edge triggered mode leaves more calculations on the part of the application \u2013 the application\nmust keep reading or writing until the \ufb01le descriptor is out of bytes \u2013 but it prevents starvation. A more ef\ufb01cient\nimplementation would also add the listening socket in edge-triggered to clear out the backlog of connections as\nwell.\nPlease read through most of man 7 epoll before starting to program. There are a lot of gotchas. Some of the\nmore common ones will be detailed below.\n11.7.3 Assorted Epoll Gotchas\nThere are several problems with using epoll. Here we will detail a few.\n1.There are two modes. Level triggered and edge-triggered. Level triggered means that while the \ufb01le descriptor", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1829, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d07c65fc-95a1-40f4-a865-36f8045c68f8": {"__data__": {"id_": "d07c65fc-95a1-40f4-a865-36f8045c68f8", "embedding": null, "metadata": {"page_label": "252", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f36f125b-1496-4cd6-9a71-ce3fae0223fd", "node_type": "4", "metadata": {"page_label": "252", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b5851c1a915d82b6d9b3347c27aadd18f73a1db301b34228b68aae72aa335543", "class_name": "RelatedNodeInfo"}}, "text": "252 CHAPTER 11. NETWORKING\nhas events on it, it will be returned by epoll when calling the ctl function. In edge-triggered, the caller will\nonly get the \ufb01le descriptor once it goes from zero events to an event. This means if you forget to read, write,\naccept etc on the \ufb01le descriptor until you get a EWOULDBLOCK, that \ufb01le descriptor will be dropped.\n2.If at any point you duplicate a \ufb01le descriptor and add it to epoll, you will get an event from that \ufb01le descriptor\nand the duplicated one.\n3.You can add an epoll object to epoll. Edge triggered and level-triggered modes are the same because ctl will\nreset the state to zero events\n4.Depending on the conditions, you may get a \ufb01le descriptor that was closed from Epoll. This isn\u2019t a bug. The\nreason that this happens is epoll works on the kernel object level, not the \ufb01le descriptor level. If the kernel\nobject lives longer and the right \ufb02ags are set, a process could get a closed \ufb01le descriptor. This also means\nthat if you close the \ufb01le descriptor, there is no way to remove the kernel object.\n5.Epoll has the EPOLLONESHOT \ufb02ag which will remove a \ufb01le descriptor after it has been returned in epoll_wait\n6.Epoll using level-triggered mode could starve certain \ufb01le descriptors because it is unknown how much data\nthe application will read from each descriptor.\nRead more at man 7 epoll or check out a better version called kqueue in the appendix.\n11.8 Remote Procedure Calls\nRPC or Remote Procedure Call is the idea that we can execute a procedure on a different machine. In practice,\nthe procedure may execute on the same machine. However, it may be in a different context. For example, the\noperation under a different user with different permissions and different lifecycles.\nAn example of this is you may send a remote procedure call to a docker daemon to change the state of the\ncontainer. Not every application needs to have access to the entire system machine, but they should have access\nto containers that they\u2019ve created.\n11.8.1 Privilege Separation\nThe remote code will execute under a different user and with different privileges from the caller. In practice, the\nremote call may execute with more or fewer privileges than the caller. This in principle can be used to improve\nthe security of a system by ensuring components operate with the least privilege. Unfortunately , security concerns\nneed to be carefully assessed to ensure that RPC mechanisms cannot be subverted to perform unwanted actions.\nFor example, an RPC implementation may implicitly trust any connected client to perform any action, rather than\na subset of actions on a subset of the data.\n11.8.2 Stub Code and Marshaling\nThe stub code is the necessary code to hide the complexity of performing a remote procedure call. One of the roles\nof the stub code is to marshal the necessary data into a format that can be sent as a byte stream to a remote server.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2885, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5978a372-0d7b-4eae-bc52-80ab6a639828": {"__data__": {"id_": "5978a372-0d7b-4eae-bc52-80ab6a639828", "embedding": null, "metadata": {"page_label": "253", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b52adccf-20ac-4702-83b4-4427290b3b6e", "node_type": "4", "metadata": {"page_label": "253", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6a0f6b9ef46ee4674309a4389c4205ac238566e33af9e86990e43b547f7d0929", "class_name": "RelatedNodeInfo"}}, "text": "11.8. REMOTE PROCEDURE CALLS 253\n//Onthe outside ,\u2019getHiscore \u2019looks like anormal function call\n//Onthe inside ,the stub code performs all ofthe work tosend and\nreceive data toand from the remote machine .\nint getHighScore( char * game) {\n//Marshal the request into asequence ofbytes :\nchar * buffer ;\nasprintf(&buffer, \"getHiscore (%s)!\", name) ;\n//Send down the wire (wedonot send the zero byte ;the \u2019!\u2019\nsignifies the end ofthe message )\nwrite(fd, buffer, strlen(buffer) ) ;\n//Wait for the server tosend aresponse\nssize_t bytesread = read(fd, buffer, sizeof (buffer)) ;\n//Example :unmarshal the bytes received back from text into anint\nbuffer[bytesread] = 0 ;//Turn the result into aCstring\nint score= atoi(buffer) ;\nfree(buffer) ;\nreturn score ;\n}\nUsing a string format may be a little inef\ufb01cient. A good example of this marshaling is Golang\u2019s gRPC or Google\nRPC. There is a version in C as well if you want to check that out.\nThe server stub code will receive the request, unmarshal the request into a valid in-memory data call the\nunderlying implementation and send the result back to the caller. Often the underlying library will do this for you.\nTo implement RPC you need to decide and document which conventions you will use to serialize the data into\na byte sequence. Even a simple integer has several common choices.\n1.Signed or unsigned?\n2.ASCII, Unicode Text Format 8, some other encoding?\n3.Fixed number of bytes or variable depending on the magnitude.\n4.Little or Big endian binary format if using binary?\nTo marshal a struct, decide which \ufb01elds need to be serialized. It may be unnecessary to send all data items.\nFor example, some items may be irrelevant to the speci\ufb01c RPC or can be re-computed by the server from the other\ndata items present.\nTo marshal a linked list, it is unnecessary to send the link pointers, stream the values. As part of unmarshaling,\nthe server can recreate a linked list structure from the byte sequence.\nBy starting at the head node /vertex, a simple tree can be recursively visited to create a serialized version of\nthe data. A cyclic graph will usually require additional memory to ensure that each edge and vertex is processed\nexactly once.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2187, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "16952eee-7490-43c4-9896-815f12f07593": {"__data__": {"id_": "16952eee-7490-43c4-9896-815f12f07593", "embedding": null, "metadata": {"page_label": "254", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "16543eeb-ac14-4029-8648-f26aa526e10f", "node_type": "4", "metadata": {"page_label": "254", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "fe97bb0ea6e856534f45c747c9008da8e185f929b2b30938c08f528adbfa13a4", "class_name": "RelatedNodeInfo"}}, "text": "254 CHAPTER 11. NETWORKING\n11.8.3 Interface Description Language\nWriting stub code by hand is painful, tedious, error-prone, dif\ufb01cult to maintain and dif\ufb01cult to reverse engineer\nthe wire protocol from the implemented code. A better approach is to specify the data objects, messages, and\nservices to automatically generate the client and server code. A modern example of an Interface Description\nLanguage is Google\u2019s Protocol Buffer .proto \ufb01les.\nEven then, Remote Procedure Calls are signi\ufb01cantly slower (10x to 100x) and more complex than local calls.\nAn RPC must marshal data into a wire-compatible format. This may require multiple passes through the data\nstructure, temporary memory allocation, and transformation of the data representation.\nRobust RPC stub code must intelligently handle network failures and versioning. For example, a server may\nhave to process requests from clients that are still running an early version of the stub code.\nA secure RPC will need to implement additional security checks including authentication and authorization,\nvalidate data and encrypt communication between the client and host. A lot of the time, the RPC system can do\nthis ef\ufb01ciently for you. Consider if you have both an RPC client and server on the same machine. Starting up a\nthrift or Google RPC server could validate and route the request to a local socket which wouldn\u2019t be sent over the\nnetwork.\n11.8.4 Transferring Structured Data\nLet\u2019s examine three methods of transferring data using 3 different formats - JSON, XML, and Google Protocol\nBuffers. JSON and XML are text-based protocols. Examples of JSON and XML messages are below.\n<ticket ><price\ncurrency= \u2019dollar \u2019>10</price ><vendor >travelocity </vendor ></ticket >\n{\u2019currency \u2019:\u2019dollar \u2019,\u2019vendor \u2019:\u2019travelocity \u2019,\u2019price \u2019:\u201910\u2019}\nGoogle Protocol Buffers is an open-source ef\ufb01cient binary protocol that places a strong emphasis on high\nthroughput with low CPU overhead and minimal memory copying. This means client and server stub code in\nmultiple languages can be generated from the .proto speci\ufb01cation \ufb01le to marshal data to and from a binary stream.\nGoogle Protocol Buffers reduces the versioning problem by ignoring unknown \ufb01elds that are present in a\nmessage. See the introduction to Protocol Buffers for more information.\nThe general chain is to abstract away the actual business logic and the various marshaling code. If your\napplication ever becomes CPU bound parsing XML, JSON or YAML, switch to protocol buffers!\n11.9 Topics\n\u2022IPv4 vs IPv6\n\u2022TCP vs UDP", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2518, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "64c51607-5fe3-458d-8c87-d0d7251ba8c7": {"__data__": {"id_": "64c51607-5fe3-458d-8c87-d0d7251ba8c7", "embedding": null, "metadata": {"page_label": "255", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5d5400c7-c8b7-4bcd-b06b-43121fa9a67c", "node_type": "4", "metadata": {"page_label": "255", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c79da383657e7752c113148c57999fda1e576a3ff82f3af8321deaebdf234645", "class_name": "RelatedNodeInfo"}}, "text": "11.10. QUESTIONS 255\n\u2022Packet Loss /Connection Based\n\u2022Get address info\n\u2022DNS\n\u2022TCP client calls\n\u2022TCP server calls\n\u2022shutdown\n\u2022recvfrom\n\u2022epoll vs select\n\u2022RPC\n11.10 Questions\n\u2022What is IPv4? IPv6? What are the differences between them?\n\u2022What is the TCP? The UDP? Give me the advantages and disadvantages of both of them. What is a scenario\nof using one over the other?\n\u2022Which protocol is connectionless and which one is connection based?\n\u2022What is DNS? What is the route that DNS takes?\n\u2022What does socket do?\n\u2022What are the calls to set up a TCP client?\n\u2022What are the calls to set up a TCP server?\n\u2022What is the difference between a socket shutdown and closing?\n\u2022When can you use read andwrite ? How about recvfrom andsendto ?\n\u2022What are some advantages to epoll over select ? How about select over epoll ?\n\u2022What is a remote procedure call? When should one use it versus HTTP or running code locally?\n\u2022What is marshaling /unmarshaling? Why is HTTP notan RPC?\nBibliography\n[1]User Datagram Protocol. RFC 768, August 1980. URL https://rfc-editor.org/rfc/rfc768.txt .\n[2]State of ipv6 deployment 2018, Jun 2018. URL https://www.internetsociety.org/resources/2018/\nstate-of-ipv6-deployment-2018/ .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1182, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2713b3fb-a4d5-4f7e-8b71-e5080c6721ac": {"__data__": {"id_": "2713b3fb-a4d5-4f7e-8b71-e5080c6721ac", "embedding": null, "metadata": {"page_label": "256", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4fc8c988-dfcf-4bdc-81aa-ace38e2be9be", "node_type": "4", "metadata": {"page_label": "256", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "72ff032552bae0053aa312b8b1acb6aebe47668441fefd80a664872f335fc6d2", "class_name": "RelatedNodeInfo"}}, "text": "256 CHAPTER 11. NETWORKING\n[3]Danny Cohen. On holy wars and a plea for peace, Apr 1980. URL https://www.ietf.org/rfc/ien/\nien137.txt .\n[4]Roy T . Fielding and Julian Reschke. Hypertext Transfer Protocol (HTTP /1.1): Semantics and Content. RFC\n7231, June 2014. URL https://rfc-editor.org/rfc/rfc7231.txt .\n[5]J. Reynolds and J. Postel. Assigned numbers. RFC 1700, RFC Editor, October 1994.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 388, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d054fb83-36a1-4310-a9df-35148fb693a8": {"__data__": {"id_": "d054fb83-36a1-4310-a9df-35148fb693a8", "embedding": null, "metadata": {"page_label": "362", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e8976e21-25dc-4b16-ad08-a19d677726d6", "node_type": "4", "metadata": {"page_label": "362", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "cbbb2ba5198e3a2b5a3314857d811e2a0d87ffe6d89cdef79620f81e4fb2e818", "class_name": "RelatedNodeInfo"}}, "text": "18\nPost Mortems\nHindsight is 20-20\nUnknown\nThis chapter is meant to serve as a big \"why are we learning all of this\". In all of your previous classes, you\nwere learning what to do. How to program a data structure, how to code a for loop, how to prove something.\nThis is the \ufb01rst class that is largely focused on what notto do. As a result, we draw experience from our past in\nreal ways. Sit back and scroll through this chapter as we tell you about the problems of past programmers. Even\nif you are dealing with something much higher level like web-development, everything relates back to the system.\n18.1 Shell Shock\nRequired: Appendix /Shell\nThis was a back door into most shells. The bug allowed an attacker to exploit an environment variable to\nexecute arbitrary code.\n$env x=\u2019(){:;};echo vulnerable \u2019bash -c \"echo this isatest \"\nvulnerable...\nThis meant that in any system that uses environment variables and doesn\u2019t sanitize their input (hint no one\nsanitized environment variable input because they saw it as safe) you can execute whatever code you want on\nother\u2019s machines including setting up a web server.\nLessons Learned: On production machines make sure that there is a minimal operating system (something\nlike BusyBox with DietLibc) so that you can understand most of the code in the systems and their effectiveness.\nPut in multiple layers of abstraction and checks to make sure that data isn\u2019t leaked. For example the above is\na problem insofar as getting information back to the attackers if it is allowed to communicate with them. This\nmeans that you can harden your machine ports by disallowing connections on all but a few ports. Also, you can\nharden your system to never perform exec calls to perform tasks (i.e. perform an exec call to update a value) and\ninstead do it in C or your favorite programming language of choice. Although you don\u2019t have \ufb02exibility , you have\npeace of mind what you allow users to do.\n362", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1935, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c768791e-4045-4f8d-bfc5-8ecf2a2b6b81": {"__data__": {"id_": "c768791e-4045-4f8d-bfc5-8ecf2a2b6b81", "embedding": null, "metadata": {"page_label": "363", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3491a0f8-7885-424a-9421-b76b94c74c39", "node_type": "4", "metadata": {"page_label": "363", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d40909cd69c3ab3b0bd5c66c550f7e4a3e6c41068a66805213201718e5c89fad", "class_name": "RelatedNodeInfo"}}, "text": "18.2. HEARTBLEED 363\n18.2 Heartbleed\nRequired: Intro to C\nTo put it simply , there were no bounds on buffer checking. The SSL Heartbeat is super simple. A server sends\na string of a certain length, and the second server is supposed to send the string of the length back. The problem\nis someone can maliciously change the size of the request to larger than what they sent (i.e. send \u201ccat\u201d but request\n500 bytes) and get crucial information like passwords from the server. There is a Relevant XKCD on it.\nLessons Learned: Check your buffers! Know the difference between a buffer and a string.\n18.3 Dirty Cow\nRequired: Processes /Virtual Memory\nDirty Cow\nA process usually has access to a set of read-only mappings of memory that if they try to write to they get a\nsegfault. Dirty COW is a vulnerability where a bunch of threads attempts to access the same piece of memory at\nthe same time hoping that one of the threads \ufb02ips the NX bit and the writable bit. After that, an attacker can\nmodify the page. This can be done to the effective user id bit and the process can pretend it was running as root\nand spawn a root shell, allowing access to the system from a normal shell.\nLessons Learned: Spinlocks in the kernel are hard.\n18.4 Meltdown\nThere is an example of this in the background section\n18.5 Spectre\nCheck in the security section.\n18.6 Mars Path\ufb01nder\nRequired sections: Synchronization and a bit of Scheduling\nPath\ufb01nder Link\nThe mars path\ufb01nder was a mission that tried to collect climate data on Mars. The \ufb01nder uses a single bus to\ncommunicate with different parts. Since this was 1997, the hardware itself didn\u2019t have advanced features like\nef\ufb01cient locking so it was up to the operating system developers to regulate that with mutexes. The architecture\nwas pretty simple. There was a thread that controlled data along the information bus, communications thread,", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1869, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8020715c-97ec-4ac5-99b0-05d78c71bb15": {"__data__": {"id_": "8020715c-97ec-4ac5-99b0-05d78c71bb15", "embedding": null, "metadata": {"page_label": "364", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1e4f4924-aa33-45d5-a297-f62a3ad8f904", "node_type": "4", "metadata": {"page_label": "364", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "921038edbb70ad306875095461313e6679d6ff8c7f41641791294d714f6b903e", "class_name": "RelatedNodeInfo"}}, "text": "364 CHAPTER 18. POST MORTEMS\nand data collection thread in with high, regular, and low priorities with respect to scheduling. The other caveat is\nthat if an interrupt happened at some interval and a task is running and a task is to be scheduled, the task that\nhas the higher priority wins.\nThe pattern that caused everything to start failing was the data collection thread starts writing to the bus, the\ninformation bus thread is waiting on the data. Then out the communication thread comes in to preempt the other\nlower priority thread while the lower priority thread still held the mutex . This means when the regular priority\nthread tried to lock the bus, the rover would deadlock. After some time the system would reset but isn\u2019t good to\nleave to chance.\nMoral of the lesson? Don\u2019t have the applications themselves deal with the synchronization. De\ufb01ne a module\nthat handles mutex locking and have the module communicate through \ufb01les, IPC, etc.\n18.7 Mars Again\nRequired Sections: Malloc\nMars\nThe short of it is that they ran out of memory . The long of it is that they ran out of memory , disk space, and\nswap space. The moral of the story? Make sure to write code that can handle \ufb01le failures and can handle \ufb01les\nwhen they close and go out of memory , so the operating system can hot swap \ufb01les to free up memory . Also clean\nup \ufb01les, assume that your temp directory is roughly a hundredth or a thousandth of the total size and use that.\n18.8 Year 2038\nRequired sections: Intro to C\n2038\nThis is issue that hasn\u2019t happened yet. Unix timestamps are kept as the number of seconds from a particular\nday (Jan 1st 1970). This is stored as a 32 bit signed integer. In March of 2038, this number will over\ufb02ow. This\nisn\u2019t a problem for most modern operating system who store 64 bit signed integers which is enough to keep us\ngoing until the end of time, but it is a problem for embedded devices that we can\u2019t change the internal hardware\nto. Stay tuned to see what happens.\nLessons learned: Plan like your application will be huge one day .\n18.9 Northeast Blackout of 2003\nRequired Sections: Synchronization\n2003\nA race condition triggered a series of unde\ufb01ned events in a system that caused the blackout of most of the\nnortheastern part of North America for quite some time. This bug also turned off or caused the backup system\nand logging systems to fail so people didn\u2019t even know of the bug for an hour. The exact bits that were \ufb02ipped are\nunknown, but patches have been put into place.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2485, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "335cbb26-9966-4ac6-a138-c9b9a3884534": {"__data__": {"id_": "335cbb26-9966-4ac6-a138-c9b9a3884534", "embedding": null, "metadata": {"page_label": "365", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "74ba0371-961a-455d-80f1-aa3516b441ce", "node_type": "4", "metadata": {"page_label": "365", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f72df64cc7b4cd43a40e3f7b2c7fd8dbf11e91e2b0f316dacf455a1b6098697a", "class_name": "RelatedNodeInfo"}}, "text": "18.10. APPLE IOS UNICODE HANDLING 365\nLessons Learned: Modularize your code to localize failures (i.e. keeping race conditions different between\nprocesses). If you need to synchronize among processes make sure your failure detection system is not interlaced\nwith your system.\n18.10 Apple IOS Unicode Handling\nRequired Sections: Intro to C\nCrashing your iphone with text\nWonder why we teach string parsing? Because it is a hard thing to do even for professional software developers.\nThis bug allowed a lot of unde\ufb01ned behavior when trying to parse a series of unicode characters. Apple probably\nknows why this happened, but our guess is that the parsing of the string happens somewhere inside the kernel\nand a segfault is reached. When you get a segfault in the kernel, your kernel panics, and the entire device reboots.\nUnde\ufb01ned behavior means anything though, and a lot of varied things did happen with this bug.\nLessons Learned: Fuzz your kernel\n18.11 Apple SSL Veri\ufb01cation\nRequired Sections: Intro to C\nApple Bug\nDue to a stray goto in Apple\u2019s code, a function always returned that an SSL certi\ufb01cate was valid. Naturally ,\nhackers were able to get away with some pretty crazy site names.\nLessons Learned: Always bracket if statements, use gotos sparingly . Chances are if you need to use a goto,\nwrite another function or a switch statement with fall throughs (still bad).\n18.12 Sony Rootkit Installation\nRequired Sections: Intro to C /Processes\nRoot Kit Scandal\nPicture this. It\u2019s 2005, Limewire came a few years prior, the internet was a growing pool of illegal activities \u2013\nnot to say that is \ufb01xed now. Sony knew that it didn\u2019t have the computing power to police all the interwebs or\nget around the various technologies people were using to get around copyright protection. So what did they do?\nWith 22 million Music CDs, they required users to install a rootkit on their operating system, so Sony can monitor\nthe device for unethical activities.\nPrivacy concerns aside, and believe me there are a lot of them, the big problem was that this rootkit is a\nbackdoor for everyone\u2019s systems if programmed incorrectly . A rootkit is a piece of code usually installed kernel-side\nthat keeps track of almost anything that a user does. What websites visited, what clicks or keys typed etc. If a\nhacker \ufb01nds out about this and there is a way to access that API from the user space level, that means any program\ncan \ufb01nd out important information about your device. Needless to say , people were angry .\nLessons Learned: Get an antivirus and /or apparmor and make sure that an application is only requesting\npermissions that make sense. If you are torn, try something like Windows sandbox or keep a Sacri\ufb01cial VM around\nto see if installing it makes your computer horrible. Don\u2019t trust certi\ufb01cates trust code.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2803, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "452f3e00-5a78-497b-a165-01720ec02ee2": {"__data__": {"id_": "452f3e00-5a78-497b-a165-01720ec02ee2", "embedding": null, "metadata": {"page_label": "366", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a951f138-1070-4ed3-9f72-4d54ac44b4f8", "node_type": "4", "metadata": {"page_label": "366", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "69330acd4f61369e5f5ee036fdbf4ded3a1dbf45c9b6515ea1ffd91c64593f02", "class_name": "RelatedNodeInfo"}}, "text": "366 CHAPTER 18. POST MORTEMS\n18.13 Civilization and Ghandi\nRequired Sections: Intro to C\nGhandi\u2019s Aggressiveness\nThis is probably well known to gamers why someone as (in real life) non-violent as Ghandi was aggressive\nin the video game civilization. In the original, the game kept aggressiveness as an unsigned integer. During the\ngame, the integer could be decremented and then the problem ensued because Ghandi was already at zero. This\ncaused him to become the most aggressive character in the game.\nLessons Learned: The take away from this is never use unsigned numbers unless you have an express written\nreason for it (reasons include you need to know about the over\ufb02ow behavior, you are bit shifting, you are bit\nmasking). In every other case, cast it.\n18.14 The Woes of Shell Scripting\nRequired Sections: Intro to C /Appending\nSteam\nThere was a simple bug in Steam that caused Steam to remove all of your \ufb01les in the form of something like\nthis\n$ ROOT=$( cd$0/;echo $PWD) ;\n$ rm -rf $ROOT\nWhat happens if $0 or the \ufb01rst parameter passed into a script doesn\u2019t exist? You move to root, and you delete\nyour entire computer.\nLessons Learned: Do parameter checks, always always always set -e on a script and if you expect a command\nto fail, explicitly list it. You can also alias rm to mv and then delete the trash later.\n18.15 Appnexus Double Free\nRequired Sections: Intro to C /Malloc\nDouble Free\nAppnexus uses an asynchronous garbage collector that reclaims different parts of the heap when it believes\nthat objects are unused. The architecture is that an element is in the unavailable list and then it is taken out to a\nto-be-freed list. After a certain time if that element was unused, it is freed and added to the free list. This is \ufb01ne\nuntil two thread try to delete the same object at once, adding to the list twice. After less time, one of the objects\nwas deleted, the delete was announced to other computers.\nLessons Learned: Avoid making hacky software if you need to. Modularize, and set memory limits, and\nmonitor different parts of your code and optimize by hand. There is no general catch-all garbage collector that \ufb01ts\neveryone. Even highly tested ones like the JVM need some nudges if you want to get performance out of them.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2244, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "914e0e80-d7c8-4955-847a-f85596cd5183": {"__data__": {"id_": "914e0e80-d7c8-4955-847a-f85596cd5183", "embedding": null, "metadata": {"page_label": "367", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "74b15e6b-e45a-42e9-9501-c1c9de739b29", "node_type": "4", "metadata": {"page_label": "367", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "27e0a19a75b27563b20e6283e7e00afe63b6fdafb8600e86eb3cf61786efa9db", "class_name": "RelatedNodeInfo"}}, "text": "18.16. ATT CASCADING FAILURES - 1990 367\n18.16 ATT Cascading Failures - 1990\nRequired Sections: Intro to C\nExplanation\nThe bug is explained well at the link above. We recommend reading to learn more. A series of network delays\nthat caused some telephone switches across the country to think that other switches were operable when they\nweren\u2019t. When the switches came back online, they realized they had a huge backlog of calls to route and began\ndoing so. Other routing failures and restarts only compounded the problem.\nLessons Learned: Not using C would\u2019ve actually helped here because of more rigorous fuzzing (though C ++\nin this day and age would be worse with its language constructs). The real moral of the story is networks are\nrandom and expect any jump at any point in your code. That means writing simulations and running them with\nrandom delays to \ufb01gure out bugs before they happen.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 894, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bf494829-b7b3-481a-b998-7565694b2d80": {"__data__": {"id_": "bf494829-b7b3-481a-b998-7565694b2d80", "embedding": null, "metadata": {"page_label": "74", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c103fa70-4986-4919-87ad-5c0afc65a55c", "node_type": "4", "metadata": {"page_label": "74", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "54a841e1117e900d01b01dfd0fd3a45a656f64f52d758ab459da027209e276e3", "class_name": "RelatedNodeInfo"}}, "text": "4\nProcesses\nWho needs process isolation?\nIntel Marketing on Meltdown and Spectre\nTo understand what a process is, you need to understand what an operating system is. An operating system\nis a program that provides an interface between hardware and user software as well as providing a set of tools\nthat the software can use. The operating system manages hardware and gives user programs a uniform way\nof interacting with hardware as long as the operating system can be installed on that hardware. Although this\nidea sounds like it is the end-all, we know that there are many different operating systems with their own quirks\nand standards. As a solution to that, there is another layer of abstraction: POSIX or portable operating systems\ninterface. This is a standard (or many standards now) that an operating system must implement to be POSIX\ncompatible \u2013 most systems that we\u2019ll be studying are almost POSIX compatible due more to political reasons.\nBefore we talk about POSIX systems, we should understand what the idea of a kernel is generally . In an\noperating system (OS), there are two spaces: kernel space and user space. Kernel space is a power operating\nmode that allows the system to interact with the hardware and has the potential to destroy your machine. User\nspace is where most applications run because they don\u2019t need this level of power for every operation. When a user\nspace program needs additional power, it interacts with the hardware through a system call that is conducted by\nthe kernel. This adds a layer of security so that normal user programs can\u2019t destroy your entire operating system.\nFor the purposes of our class, we\u2019ll talk about single machine multiple user operating systems. This is where there\nis a central clock on a standard laptop or desktop. Other OSes relax the central clock requirement (distributed) or\nthe \u201cstandardness\u201d of the hardware (embedded systems). Other invariants make sure events happen at particular\ntimes too.\nThe operating system is made up of many different pieces. There may be a program running to handle\nincoming USB connections, another one to stay connected to the network, etc. The most important one is the\nkernel \u2013 although it might be a set of processes \u2013 which is the heart of the operating system. The kernel has many\nimportant tasks. The \ufb01rst of which is booting.\n1.The computer hardware executes code from read-only memory , called \ufb01rmware.\n2.The \ufb01rmware executes a bootloader, which often conforms to the Extensible Firmware Interface ( EFI),\nwhich is an interface between the system \ufb01rmware and the operating system.\n3.The bootloader\u2019s boot manager loads the operating system kernels, based on the boot settings.\n4.Your kernel executes init to bootstrap itself from nothing.\n5.The kernel executes startup scripts like starting networking and USB handling.\n74", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2832, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "230370d4-410d-47ab-9da7-25d4e7706ad4": {"__data__": {"id_": "230370d4-410d-47ab-9da7-25d4e7706ad4", "embedding": null, "metadata": {"page_label": "75", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1bd0666f-a984-45fb-8d43-bbe717549c59", "node_type": "4", "metadata": {"page_label": "75", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "fc064adc044c79786813e6e3fb2fe1f15756918b61c5bc216b257966e79f8bc8", "class_name": "RelatedNodeInfo"}}, "text": "4.1. FILE DESCRIPTORS 75\n6.The kernel executes userland scripts like starting a desktop, and you get to use your computer!\nWhen a program is executing in user space, the kernel provides some important services to programs in User\nspace.\n\u2022Scheduling processes and threads\n\u2022Handling synchronization primitives (futexes, mutexes, semaphores, etc.)\n\u2022Providing system calls such as write orread\n\u2022Managing virtual memory and low-level binary devices such as USBdrivers\n\u2022Managing \ufb01lesystems\n\u2022Handling communication over networks\n\u2022Handling communication between processes\n\u2022Dynamically linking libraries\n\u2022The list goes on and on.\nThe kernel creates the \ufb01rst process init.d (an alternative is system.d). init.d boots up programs such as\ngraphical user interfaces, terminals, etc \u2013 by default, this is the only process explicitly created by the system. All\nother processes are instantiated by using the system calls fork andexec from that single process.\n4.1 File Descriptors\nAlthough these were mentioned in the last chapter, we are going to give a quick reminder about \ufb01le descriptors. A\nzine from Julia Evans gives some more details [8].\nThe kernel keeps track of the \ufb01le descriptors and what they point to. Later we will learn two things: that \ufb01le\ndescriptors point to more than \ufb01les and that the operating system keeps track of them.\nNotice that \ufb01le descriptors may be reused between processes, but inside of a process, they are unique. File\ndescriptors may have a notion of position. These are known as seekable streams. A program can read a \ufb01le on disk\ncompletely because the OS keeps track of the position in the \ufb01le, an attribute that belongs to your process as well.\nOther \ufb01le descriptors point to network sockets and various other pieces of information, that are unseekable\nstreams.\n4.2 Processes\nA process is an instance of a computer program that may be running. Processes have many resources at their\ndisposal. At the start of each program, a program gets one process, but each program can make more processes. A\nprogram consists of the following:\n\u2022A binary format: This tells the operating system about the various sections of bits in the binary \u2013 which\nparts are executable, which parts are constants, which libraries to include etc.\n\u2022A set of machine instructions", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2269, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4e55b646-ac3c-464b-af17-d8c464b756db": {"__data__": {"id_": "4e55b646-ac3c-464b-af17-d8c464b756db", "embedding": null, "metadata": {"page_label": "76", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f9057212-8280-49f5-8633-560064ca7e85", "node_type": "4", "metadata": {"page_label": "76", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "1f3b9c158faab71cf9aca74a50c1be80edcc27d54ffe0af21f98ebd399c89f5e", "class_name": "RelatedNodeInfo"}}, "text": "76 CHAPTER 4. PROCESSES\n\u2022A number denoting which instruction to start from\n\u2022Constants\n\u2022Libraries to link and where to \ufb01ll in the address of those libraries\nProcesses are powerful, but they are isolated!\nThat means that by default, no process can communicate with another process.\nThis is important because in complex systems (like the University of Illinois Engineering Workstations), it is\nlikely that different processes will have different privileges. One certainly doesn\u2019t want the average user to be\nable to bring down the entire system, by either purposely or accidentally modifying a process. As most of you\nhave realized by now, if you stuck the following code snippet into a program, the variables are unshared between\ntwo parallel invocations of the program.\nint secrets ;\nsecrets ++;\nprintf( \"%d\\n\", secrets) ;\nOn two different terminals, they would both print out 1 not 2. Even if we changed the code to attempt to\naffect other process instances, there would be no way to change another process\u2019 state unintentionally . However,\nthere are other intentional ways to change the program states of other processes.\n4.3 Process Contents\n4.3.1 Memory Layout\nWhen a process starts, it gets its own address space. Each process gets the following.\n\u2022A Stack\nThe stack is the place where automatically allocated variables and function call return addresses are stored.\nEvery time a new variable is declared, the program moves the stack pointer down to reserve space for\nthe variable. This segment of the stack is writable but not executable. This behavior is controlled by the\nno-execute (NX) bit, sometimes called the W \u02c6X (write XOR execute) bit, which helps prevent malicious code,\nsuch as shellcode from being run on the stack.\nIf the stack grows too far \u2013 meaning that it either grows beyond a preset boundary or intersects the heap \u2013\nthe program will stack over\ufb02ow error, most likely resulting in a SEGFAULT . The stack is statically allocated\nby default; there is only a certain amount of space to which one can write.\n\u2022A Heap\nThe heap is a contiguous, expanding region of memory [5]. If a program wants to allocate an object whose\nlifetime is manually controlled or whose size cannot be determined at compile-time, it would want to create\na heap variable.\nThe heap starts at the top of the text segment and grows upward, meaning malloc may push the heap\nboundary \u2013 called the program break \u2013 upward.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2408, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c3523cc5-97f1-42c5-9908-9aa9278ccd00": {"__data__": {"id_": "c3523cc5-97f1-42c5-9908-9aa9278ccd00", "embedding": null, "metadata": {"page_label": "77", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "73d30326-d346-444b-8427-60423669af22", "node_type": "4", "metadata": {"page_label": "77", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "41eeb06140b7fc2193924552c8cc54104fff5255aba1824fbafecafdb2eaf208", "class_name": "RelatedNodeInfo"}}, "text": "4.3. PROCESS CONTENTS 77\nWe will explore this in more depth in our chapter on memory allocation. This area is also writable but\nnot executable. One can run out of heap memory if the system is constrained or if a program run out of\naddresses, a phenomenon that is more common on a 32-bit system.\n\u2022A Data Segment\nThis segment contains two parts, an initialized data segment, and an uninitialized segment. Furthermore,\nthe initialized data segment is divided into a readable and writable section.\n\u2013Initialized Data Segment This contains all of a program\u2019s globals and any other static variables.\nThis section starts at the end of the text segment and starts at a constant size because the number of\nglobals is known at compile time. The end of the data segment is called the program break and can\nbe extended via the use of brk /sbrk.\nThis section is writable [10, P . 124 ]. Most notably , this section contains variables that were initialized\nwith a static initializer, as follows:\nint global = 1 ;\n\u2013Uninitialized Data Segment /BSS BSS stands for an old assembler operator known as Block Started\nby Symbol.\nThis contains all of your globals and any other static duration variables that are implicitly zeroed out.\nExample:\nint assumed_to_be_zero ;\nThis variable will be zeroed; otherwise, we would have a security risk involving isolation from other\nprocesses. They get put in a different section to speed up process start up time. This section starts\nat the end of the data segment and is also static in size because the amount of globals is known at\ncompile time. Currently , both the initialized and BSS data segments are combined and referred to as\nthe data segment [10, P . 124 ], despite being somewhat different in purpose.\n\u2022A Text Segment\nThis is where all executable instructions are stored, and is readable (function pointers) but not writable.\nThe program counter moves through this segment executing instructions one after the other. It is important\nto note that this is the only executable section of the program, by default. If a program\u2019s code while it\u2019s\nrunning, the program most likely will SEGFAULT . There are ways around it, but we will not be exploring\nthese in this course. Why doesn\u2019t it always start at zero? This is because of a security feature called address\nspace layout randomization. The reasons for and explanation about this is outside the scope of this class,\nbut it is good to know about its existence. Having said that, this address can be made constant, if a program\nis compiled with the DEBUG \ufb02ag.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2532, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e8d5ef94-5438-431f-b189-1b030835e3a0": {"__data__": {"id_": "e8d5ef94-5438-431f-b189-1b030835e3a0", "embedding": null, "metadata": {"page_label": "78", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ddc5011c-48e6-4995-9116-b1dabcf29a6e", "node_type": "4", "metadata": {"page_label": "78", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b57fa59b3d8e4a6dc056b53c24ad69fc436cd6b3a870f83f08d330f39cb9662e", "class_name": "RelatedNodeInfo"}}, "text": "78 CHAPTER 4. PROCESSES\nTextDataHeapStack\nFigure 4.1: Process address space\n4.3.2 Other Contents\nTo keep track of all these processes, your operating system gives each process a number called the process ID\n(PID). Processes are also given the PID of their parent process, called parent process ID ( PPID ). Every process has\na parent, that parent could be init.d .\nProcesses could also contain the following information:\n\u2022Running State - Whether a process is getting ready , running, stopped, terminated, etc. (more on this is\ncovered in the chapter on Scheduling).\n\u2022File Descriptors - A list of mappings from integers to real devices (\ufb01les, USB \ufb02ash drives, sockets)\n\u2022Permissions - What user the \ufb01le is running on and what group the process belongs to. The process can\nthen only perform operations based on the permissions given to the user orgroup , such as accessing \ufb01les.\nThere are tricks to make a program take a different user than who started the program i.e. sudo takes a\nprogram that a user starts and executes it as root . More speci\ufb01cally , a process has a real user ID (identi\ufb01es\nthe owner of the process), an effective user ID (used for non-privileged users trying to access \ufb01les only\naccessible by superusers), and a saved user ID (used when privileged users perform non-privileged actions).\n\u2022Arguments - a list of strings that tell your program what parameters to run under.\n\u2022Environment Variables - a list of key-value pair strings in the form NAME=VALUE that one can modify . These\nare often used to specify paths to libraries and binaries, program con\ufb01guration settings, etc.\nAccording to the POSIX speci\ufb01cation, a process only needs a thread and address space, but most kernel\ndevelopers and users know that only these aren\u2019t enough [6].", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1756, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b4196a97-3292-46dd-b1aa-44f17496bb6e": {"__data__": {"id_": "b4196a97-3292-46dd-b1aa-44f17496bb6e", "embedding": null, "metadata": {"page_label": "79", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0048b2ab-bbec-41a3-825a-237df653dc3f", "node_type": "4", "metadata": {"page_label": "79", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e98ccbc1f9745421df9741724cc46592c8b7a97939134de63e62a8ea89e99e61", "class_name": "RelatedNodeInfo"}}, "text": "4.4. INTRO TO FORK 79\n4.4 Intro to Fork\n4.4.1 A word of warning\nProcess forking is a powerful and dangerous tool. If you make a mistake resulting in a fork bomb, you can bring\ndown an entire system . To reduce the chances of this, limit your maximum number of processes to a small\nnumber e.g. 40 by typing ulimit -u 40 into a command line. Note, this limit is only for the user, which means\nif you fork bomb, then you won\u2019t be able to kill all created process since calling killall requires your shell to\nfork() . Quite unfortunate. One solution is to spawn another shell instance as another user (for example root)\nbeforehand and kill processes from there.\nAnother is to use the built-in exec command to kill all the user processes (you only have one attempt at this).\nFinally , you could reboot the system, but you only have one shot at this with the exec function.\nWhen testing fork() code, ensure that you have either root and /or physical access to the machine involved. If\nyou must work on fork() code remotely , remember that kill -9 -1 will save you in the event of an emergency . Fork\ncan be extremely dangerous if you aren\u2019t prepared for it. You have been warned.\n4.4.2 Fork Functionality\nThefork system call clones the current process to create a new process, called a child process. This occurs by\nduplicating the state of the existing process with a few minor differences.\n\u2022The child process executes the next line after the fork() as the parent process does.\n\u2022Just as a side remark, in older UNIX systems, the entire address space of the parent process was directly\ncopied regardless of whether the resource was modi\ufb01ed or not. The current behavior is for the kernel\nto perform a copy-on-write, which saves a lot of resources, while being time ef\ufb01cient [7, Copy-on-write\nsection ].\nHere is a simple example:\nm\nprintf( \"I\u2019mprinted once !\\n\");\nfork() ;\n//Now two processes running iffork succeeded\n//and each process will print out the next line .\nprintf( \"This line twice !\\n\");\nHere is a simple example of this address space cloning. The following program may print out 42 twice - but\nthefork() is after the printf !? Why?\nm\n#include <unistd.h >/*fork declared here */\n#include <stdio.h >/*printf declared here */\nint main() {", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2240, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c22de179-a7d6-4071-9e68-a5227d532349": {"__data__": {"id_": "c22de179-a7d6-4071-9e68-a5227d532349", "embedding": null, "metadata": {"page_label": "80", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b263ad4e-acba-44ee-858c-66516c49a1a7", "node_type": "4", "metadata": {"page_label": "80", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e5cc4ade696368d48eb9a3ef5bafa26cc4625416ec560be94e0bd88ad4c3c81f", "class_name": "RelatedNodeInfo"}}, "text": "80 CHAPTER 4. PROCESSES\nint answer = 84 >>1;\nprintf( \"Answer :%d\", answer) ;\nfork() ;\nreturn 0;\n}\nTheprintf line isexecuted only once however notice that the printed contents are not \ufb02ushed to standard\nout. There\u2019s no newline printed, we didn\u2019t call fflush , or change the buffering mode. The output text is therefore\nstill in process memory waiting to be sent. When fork() is executed the entire process memory is duplicated\nincluding the buffer. Thus, the child process starts with a non-empty output buffer which may be \ufb02ushed when\nthe program exits. We say may because the contents may be unwritten given a bad program exit as well.\nTo write code that is different for the parent and child process, check the return value of fork() . Iffork()\nreturns -1, that implies something went wrong in the process of creating a new child. One should check the value\nstored in errno to determine what kind of error occurred. Common errors include EAGAIN andENOENT Which are\nessentially \"try again \u2013 resource temporarily unavailable\", and \"no such \ufb01le or directory\".\nSimilarly , a return value of 0 indicates that we are operating in the context of the child process, whereas a\npositive integer shows that we are in the context of the parent process.\nThe positive value returned by fork() is the process id ( pid) of the child.\nA way to remember what is represented by the return value of fork is, that the child process can \ufb01nd its\nparent - the original process that was duplicated - by calling getppid() - so does not need any additional return\ninformation from fork() . However, the parent process may have many child processes, and therefore needs to be\nexplicitly informed of its child PIDs.\nAccording to the POSIX standard, every process only has a single parent process.\nThe parent process can only know the PID of the new child process from the return value of fork :\nm\npid_t id = fork() ;\nif(id == -1) exit(1) ;//fork failed\nif(id >0){\n//Original parent\n//Achild process with id\u2019id\u2019\n//Use waitpid towait for the child tofinish\n}else {//returned zero\n//Child Process\n}\nA slightly silly example is shown below. What will it print? Try running this program with multiple arguments.\nm\n#include <unistd.h >\n#include <stdio.h >\nint main( int argc, char **argv) {\npid_t id ;\nint status ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2281, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c2f83e6-174c-4275-9517-3c469d213c78": {"__data__": {"id_": "7c2f83e6-174c-4275-9517-3c469d213c78", "embedding": null, "metadata": {"page_label": "81", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f1e400dd-661c-4f6d-b041-d5af93ab6a14", "node_type": "4", "metadata": {"page_label": "81", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4793a44b7f2978050839c11e68fe1ffef7c2720b05a362aa9a5b18691d3bd7e7", "class_name": "RelatedNodeInfo"}}, "text": "4.4. INTRO TO FORK 81\nwhile (--argc && (id=fork())) {\nwaitpid(id,&status,0) ;/*Wait for child */\n}\nprintf( \"%d:%s\\n\", argc, argv[argc]) ;\nreturn 0;\n}\nAnother example is below. This is the amazing parallel apparent-O(N) sleepsort is today\u2019s silly winner. First\npublished on 4chan in 2011. A version of this awful but amusing sorting algorithm is shown below. This sorting\nalgorithm may fail to produce the correct output.\nint main( int c,char **v) {\nwhile (--c >1 && !fork()) ;\nint val = atoi(v[c]) ;\nsleep(val) ;\nprintf( \"%d\\n\", val) ;\nreturn 0;\n}\nImagine that we ran this program like so\n$ ./ssort 1 3 2 4", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 606, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d7075920-6a29-4e5b-b4ce-72493e3f5a6b": {"__data__": {"id_": "d7075920-6a29-4e5b-b4ce-72493e3f5a6b", "embedding": null, "metadata": {"page_label": "82", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d1caed6c-ee34-4245-b916-a15da6b54bc2", "node_type": "4", "metadata": {"page_label": "82", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "2661dfd3f22a6f56d7d44bdd6a832dd74fbc6dff7ea7c17a08bd0c2be58af740", "class_name": "RelatedNodeInfo"}}, "text": "82 CHAPTER 4. PROCESSES\nexit()\nexit()\nexit()\nexit()\nFigure 4.2: Timing of sorting 1, 3, 2, 4\nThe algorithm isn\u2019t actually O(N) because of how the system scheduler works. In essence, this program\noutsources the actual sorting to the operating system.\n4.4.3 Fork Bomb\nA \u2018fork bomb\u2019 is what we warned you about earlier. This occurs when there is an attempt to create an in\ufb01nite\nnumber of processes. This will often bring a system to a near-standstill, as it attempts to allocate CPU time\nand memory to a large number of processes that are ready to run. System administrators don\u2019t like them and\nmay set upper limits on the number of processes each user can have, or revoke login rights because they create\ndisturbances in the Force for other users\u2019 programs. A program can limit the number of child processes created by\nusing setrlimit() .\nFork bombs are not necessarily malicious - they occasionally occur due to programming errors. Below is a\nsimple example that is malicious.\nwhile (1) fork() ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 994, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4b78f1e4-4133-4c3c-9639-ecf807fa4e33": {"__data__": {"id_": "4b78f1e4-4133-4c3c-9639-ecf807fa4e33", "embedding": null, "metadata": {"page_label": "83", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b1bf2f8d-6b8d-475c-a0d8-42bf64e1c085", "node_type": "4", "metadata": {"page_label": "83", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a14fa0268a64ff5b5d62c15943a8313228d2c9a809bc09f345ce6abf790f5291", "class_name": "RelatedNodeInfo"}}, "text": "4.4. INTRO TO FORK 83\nIt is easy to cause one, if you are careless while calling fork, especially in a loop. Can you spot the fork bomb\nhere?\n#include <unistd.h >\n#define HELLO_NUMBER 10\nint main() {\npid_t children[HELLO_NUMBER] ;\nint i;\nfor(i = 0 ;i<HELLO_NUMBER ;i++){\npid_t child = fork() ;\nif(child == -1) {\nbreak ;\n}\nif(child == 0) {\n//Child\nexeclp( \"ehco \",\"echo \",\"hello \", NULL) ;\n}\nelse {\n//Parent\nchildren[i] = child ;\n}\n}\nint j;\nfor(j = 0 ;j<i;j++){\nwaitpid(children[j], NULL, 0) ;\n}\nreturn 0;\n}\nWe misspelled ehco , so the exec call fails. What does this mean? Instead of creating 10 processes, we created\n1024 processes, fork bombing our machine .How could we prevent this? Add an exit right after exec, so that if\nexec fails, we won\u2019t end up calling fork an unbounded number of times. There are various other ways. What\nif we removed the echo binary? What if the binary itself creates a fork bomb?\n4.4.4 Signals\nWe won\u2019t fully explore signals until the end of the course, but it is relevant to broach the subject now because\nvarious semantics related to fork and other function calls detail what a signal is.\nA signal can be thought of as a software interrupt. This means that a process that receives a signal stops the\nexecution of the current program and makes the program respond to the signal.\nThere are various signals de\ufb01ned by the operating system, two of which you may already know: SIGSEGV and\nSIGINT . The \ufb01rst is caused by an illegal memory access, and the second is sent by a user wanting to terminate a", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1529, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "667d02ee-b67e-44f0-9aaa-1fe6590506db": {"__data__": {"id_": "667d02ee-b67e-44f0-9aaa-1fe6590506db", "embedding": null, "metadata": {"page_label": "84", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "fdd13f4c-1205-4d85-908f-2501d10b8439", "node_type": "4", "metadata": {"page_label": "84", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "243b2030386804a79370ced3c96bb30bea8ed984dd6e46ffd7df79ee76489366", "class_name": "RelatedNodeInfo"}}, "text": "84 CHAPTER 4. PROCESSES\nprogram. In each case, the program jumps from the current line being executed to the signal handler. If no signal\nhandler is supplied by the program, a default handler is executed \u2013 such as terminating the program, or ignoring\nthe signal.\nHere is an example of a simple user-de\ufb01ned signal handler:\nvoid handler( int signum) {\nwrite(1, \"signaled !\", 9) ;\n//wedon\u2019tneed the signum because weare only catching SIGINT\n//ifyou want touse the same piece ofcode for multiple\n//signals ,check the signum\n}\nint main() {\nsignal(SIGINT, handler) ;\nwhile (1) ;\nreturn 0;\n}\nA signal has four stages in its life cycle: generated, pending, blocked, and received state. These refer to when\na process generates a signal, the kernel is about to deliver a signal, the signal is blocked, and when the kernel\ndelivers a signal, each of which requires some time to complete. Read more in the introduction to the Signals\nchapter.\nThe terminology is important because fork and exec require different operations based on the state a signal is\nin.\nTo note, it is generally poor programming practice to use signals in program logic, which is to send a signal to\nperform a certain operation. The reason: signals have no time frame of delivery and no assurance that they will\nbe delivered. There are better ways to communicate between two processes.\nIf you want to read more, feel free to skip ahead to the chapter on POSIX signals and read it over. It isn\u2019t long\nand gives you the long and short about how to deal with signals in processes.\n4.4.5 POSIX Fork Details\nPOSIX determines the standards of fork [4]. You can read the previous citation, but do note that it can be quite\nverbose. Here is a summary of what is relevant:\n1.Fork will return a non-negative integer on success.\n2.A child will inherit any open \ufb01le descriptors of the parent. That means if a parent half of the \ufb01le and forks,\nthe child will start at that offset. A read on the child\u2019s end will shift the parent\u2019s offset by the same amount.\nAny other \ufb02ags are also carried over.\n3.Pending signals are not inherited. This means that if a parent has a pending signal and creates a child, the\nchild will not receive that signal unless another process signals the child.\n4.The process will be created with one thread (more on that later. The general consensus is to not create\nprocesses and threads at the same time).\n5.Since we have copy on write (COW), read-only memory addresses are shared between processes.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2470, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6eacf695-85ee-48b3-a4f7-ca1e140bfb4d": {"__data__": {"id_": "6eacf695-85ee-48b3-a4f7-ca1e140bfb4d", "embedding": null, "metadata": {"page_label": "85", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0042a8be-64ad-41a8-842c-38e95d1a43e4", "node_type": "4", "metadata": {"page_label": "85", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c96aee67143c3ba6570713411f89fb39f6c2751f7508dda89f819f52428623d1", "class_name": "RelatedNodeInfo"}}, "text": "4.4. INTRO TO FORK 85\n6.If a program sets up certain regions of memory , they can be shared between processes.\n7.Signal handlers are inherited but can be changed.\n8.The process\u2019 current working directory (often abbreviated to CWD) is inherited but can be changed.\n9.Environment variables are inherited but can be changed.\nKey differences between the parent and the child include:\n\u2022The process id returned by getpid() . The parent process id returned by getppid() .\n\u2022The parent is noti\ufb01ed via a signal, SIGCHLD, when the child process \ufb01nishes but not vice versa.\n\u2022The child does not inherit pending signals or timer alarms. For a complete list see the fork man page\n\u2022The child has its own set of environment variables.\n4.4.6 Fork and FILEs\nThere are some tricky edge cases when it comes to using FILE and forking. First, we have to make a technical\ndistinction. A File Description is the struct that a \ufb01le descriptor points to. File descriptors can point to many\ndifferent structs, but for our purposes, they\u2019ll point to a struct that represents a \ufb01le on a \ufb01lesystem. This \ufb01le\ndescription contains elements like paths, how far the descriptor has read into the \ufb01le, etc. A \ufb01le descriptor points\nto a \ufb01le description. This is important because when a process is forked, only the \ufb01le descriptor is cloned, not the\ndescription. The following snippet contains only one description.\nint file = open(...) ;\nif(!fork) {\nread(file, ...) ;\n}else {\nread(file, ...) ;\n}\nOne process will read one part of the \ufb01le, the other process will read another part of the \ufb01le. In the following\nexample, there are two descriptions caused by two different \ufb01le handles.\nif(!fork) {\nint file = open(...) ;\nread(file, ...) ;\n}else {\nint file = open(...) ;\nread(file, ...) ;\n}\nLet\u2019s consider our motivating example.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1785, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "400d7f02-5c03-41cd-b9c2-742beec562fa": {"__data__": {"id_": "400d7f02-5c03-41cd-b9c2-742beec562fa", "embedding": null, "metadata": {"page_label": "86", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d312320e-84f0-4848-b89e-678f0e249b16", "node_type": "4", "metadata": {"page_label": "86", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "02b8d4c6f829c6ea4aeafd66a2557e2f0b7a40728323822695e255bead531182", "class_name": "RelatedNodeInfo"}}, "text": "86 CHAPTER 4. PROCESSES\n$cat test .txt\nA\nB\nC\nTake a look at this code, what does it do?\nsize_t buffer_cap = 0 ;\nchar * buffer = NULL ;\nssize_t nread ;\nFILE * file = fopen( \"test .txt\",\"r\");\nint count = 0 ;\nwhile ((nread = getline(&buffer, &buffer_cap, file) != -1) {\nprintf( \"%s\", buffer) ;\nif(fork() == 0) {\nexit(0) ;\n}\nwait(NULL) ;\n}\nThe initial thought may be that it prints the \ufb01le line by line with some extra forking. It is actually unde\ufb01ned\nbehavior because we didn\u2019t prepare the \ufb01le descriptors. To make a long story short, here is what to do to avoid\nthe example.\n1.You as the programmer need to make sure that all of your \ufb01le descriptors are prepared before forking.\n2.If it is a \ufb01le descriptor or an unbuffered FILE* , it is already prepared.\n3.If the FILE* is open for reading and has been read fully , it is already prepared.\n4.Otherwise, the FILE* must befflush \u2019ed or closed to be prepared.\n5.If the \ufb01le descriptor is prepared, it must unactive in the parent process if the child process is using it or\nvice versa. A process is using it if it is read or written or if that process for whatever reason calls exit . If a\nprocess uses it when the other process is as well, the whole application\u2019s behavior is unde\ufb01ned.\nSo how would we \ufb01x the code? We would have to \ufb02ush the \ufb01le before forking and refrain from using it until\nafter the wait call \u2013 more on the speci\ufb01cs of this next section.\nsize_t buffer_cap = 0 ;\nchar * buffer = NULL ;\nssize_t nread ;\nFILE * file = fopen( \"test .txt\",\"r\");\nint count = 0 ;\nwhile ((nread = getline(&buffer, &buffer_cap, file) != -1) {\nprintf( \"%s\", buffer) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1604, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c8e0ec4-2d06-4902-b6cc-13a814900857": {"__data__": {"id_": "0c8e0ec4-2d06-4902-b6cc-13a814900857", "embedding": null, "metadata": {"page_label": "87", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f19b4a22-e22d-4574-80ce-78857f8dd971", "node_type": "4", "metadata": {"page_label": "87", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "673bba7880c8a9612ba0147612af86f525ea49ebb94d074c113f9180b531aac9", "class_name": "RelatedNodeInfo"}}, "text": "4.5. WAITING AND EXECUTING 87\nfflush(file) ;\nif(fork() == 0) {\nexit(0) ;\n}\nwait(NULL) ;\n}\nWhat if the parent process and the child process need to perform asynchronously and need to keep the \ufb01le\nhandle open? Due to event ordering, we need to make sure that parent process knows that the child is \ufb01nished\nusing wait . We\u2019ll talk about Inter-Process communication in a later chapter, but now we can use the double fork\nmethod.\n//...\nfflush(file) ;\npid_t child = fork() ;\nif(child == 0) {\nfclose(file) ;\nif(fork() == 0) {\n//Doasynchronous work\n//Safe exit ,this child doesn \u2019tknow about\n//the file descriptor\nexit(0) ;\n}\nexit(0) ;\n}\nwaitpid(child, NULL, 0) ;\nIf you are interested in how this works, check out the appendix for a description of the Fork-\ufb01le problem.\n4.5 Waiting and Executing\nIf the parent process wants to wait for the child to \ufb01nish, it must use waitpid (orwait ), both of which wait for a\nchild to change process states, which can be one of the following:\n1.The child terminated\n2.The child was stopped by a signal\n3.The child was resumed by a signal\nNote that waitpid can be set to be non-blocking, which means they will return immediately , letting a program\nknow if the child has exited.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1206, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "74d929e5-12c6-417f-9a9b-f651b68359b5": {"__data__": {"id_": "74d929e5-12c6-417f-9a9b-f651b68359b5", "embedding": null, "metadata": {"page_label": "88", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c813164e-7534-45ca-b9d0-689c537fd914", "node_type": "4", "metadata": {"page_label": "88", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b4167e4fbd628fb7fba1e8ec74fe06998bf24da93c1702485a789447de49b213", "class_name": "RelatedNodeInfo"}}, "text": "88 CHAPTER 4. PROCESSES\npid_t child_id = fork() ;\nif(child_id == -1) {perror( \"fork \");exit(EXIT_FAILURE) ;}\nif(child_id >0){\n//Wehave achild !Get their exit code\nint status ;\nwaitpid( child_id, &status, 0 ) ;\n//code not shown toget exit status from child\n}else {//Inchild ...\n//start calculation\nexit(123) ;\n}\nwait is a simpler version of waitpid .wait accepts a pointer to an integer and waits on any child process.\nAfter the \ufb01rst one changes state, wait returns. Here is the behavior of waitpid :\n1.A program canwait on a speci\ufb01c process, or it can pass in special values for the pidto do different things\n(check the man pages).\n2.The last parameter to waitpid is an option parameter. The options are listed below:\n3.WNOHANG - Return whetherthe searched process has exited\n4.WNOWAIT - Wait, but leave the child wait-able by another wait call\n5.WEXITED - Wait for exited children\n6.WSTOPPED - Wait for stopped children\n7.WCONTINUED - Wait for continued children\nExit statuses or the value stored in the integer pointer for both of the calls above are explained below.\n4.5.1 Exit statuses\nTo \ufb01nd the return value of main() or value included in exit() ), Use the Wait macros - typically a program will\nuseWIFEXITED andWEXITSTATUS . See wait /waitpid man page for more information.\nint status ;\npid_t child = fork() ;\nif(child == -1) {\nreturn 1;//Failed\n}\nif(child >0){\n//Parent ,wait for child tofinish\npid_t pid = waitpid(child, &status, 0) ;\nif(pid != -1 && WIFEXITED(status)) {\nint exit_status = WEXITSTATUS(status) ;\nprintf( \"Process %dreturned %d\", pid, exit_status) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1573, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "179c3b6d-2363-483d-8c35-06bc67d6440d": {"__data__": {"id_": "179c3b6d-2363-483d-8c35-06bc67d6440d", "embedding": null, "metadata": {"page_label": "89", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cba44fcb-580b-4544-92c7-ec1282434a12", "node_type": "4", "metadata": {"page_label": "89", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4debef183c15e29b723f85a2770374574677ce56791a7944b1b8e93bfb1bf999", "class_name": "RelatedNodeInfo"}}, "text": "4.5. WAITING AND EXECUTING 89\n}\n}else {\n//Child ,dosomething interesting\nexecl( \"/bin/ls\",\"/bin/ls\",\".\", (char *) NULL) ;//\"ls.\"\n}\nA process can only have 256 return values, the rest of the bits are informational, and the information is\nextracted with bit shifting. However, the kernel has an internal way of keeping track of signaled, exited, or stopped\nprocesses. This API is abstracted so that that the kernel developers are free to change it at will. Remember: these\nmacros only make sense if the precondition is met. For example, a process\u2019 exit status won\u2019t be de\ufb01ned if the\nprocess isn\u2019t signaled. The macros will not do the checking for the program, so it\u2019s up to the programmer to make\nsure the logic is correct. As an example above, the program should use the WIFSTOPPED to check if a process\nwas stopped and then the WSTOPSIG to \ufb01nd the signal that stopped it. As such, there is no need to memorize\nthe following. This is a high-level overview of how information is stored inside the status variables. From the\nsys/wait.h of an old Berkeley Standard Distribution(BSD) kernel [1]:\n/*IfWIFEXITED (STATUS ),the low-order 8bits ofthe status .*/\n#define _WSTATUS(x) (_W_INT(x) & 0177)\n#define _WSTOPPED 0177 /*_WSTATUS ifprocess isstopped */\n#define WIFSTOPPED(x) (_WSTATUS(x) == _WSTOPPED)\n#define WSTOPSIG(x) (_W_INT(x) >>8)\n#define WIFSIGNALED(x) (_WSTATUS(x) != _WSTOPPED && _WSTATUS(x) != 0)\n#define WTERMSIG(x) (_WSTATUS(x))\n#define WIFEXITED(x) (_WSTATUS(x) == 0)\nThere is a convention about exit codes. If the process exited normally and everything was successful, then a\nzero should be returned. Beyond that, there aren\u2019t too many widely accepted conventions. If a program speci\ufb01es\nreturn codes to mean certain conditions, it may be able to make more sense of the 256 error codes. For example,\na program could return 1if the program went to stage 1 (like writing to a \ufb01le) 2if it did something else, etc.\nUsually , UNIX programs are not designed to follow this policy , for the sake of simplicity .\n4.5.2 Zombies and Orphans\nIt is good practice to wait on your process\u2019 children. If a parent doesn\u2019t wait on your children they become, what\nare called zombies. Zombies are created when a child terminates and then takes up a spot in the kernel process\ntable for your process. The process table keeps track of the following information about a process: PID, status,\nand how it was killed. The only way to get rid of a zombie is to wait on your children. If a long-running parent\nnever waits for your children, it may lose the ability to fork.\nHaving said that, a program doesn\u2019t always need to wait for your children! Your parent process can continue\nto execute code without having to wait for the child process. If a parent dies without waiting on its children, a\nprocess can orphan its children. Once a parent process completes, any of its children will be assigned to init\n- the \ufb01rst process, whose PID is 1. Therefore, these children would see getppid() return a value of 1. These\norphans will eventually \ufb01nish and for a brief moment become a zombie. The init process automatically waits for\nall of its children, thus removing these zombies from the system.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3174, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "016d1b68-259b-406f-9269-ccb615f2ca2e": {"__data__": {"id_": "016d1b68-259b-406f-9269-ccb615f2ca2e", "embedding": null, "metadata": {"page_label": "90", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4d594d2e-fc1a-43e3-9943-125e8794d69d", "node_type": "4", "metadata": {"page_label": "90", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "1c4a3b700f253d8ce5708efdb318dbe6bca0de58da2d0eb1361d00c37824d74f", "class_name": "RelatedNodeInfo"}}, "text": "90 CHAPTER 4. PROCESSES\n4.5.3 Advanced: Asynchronously Waiting\nWarning: This section uses signals which are partially introduced. The parent gets the signal SIGCHLD when a\nchild completes, so the signal handler can wait for the process. A slightly simpli\ufb01ed version is shown below.\npid_t child ;\nvoid cleanup( int signal) {\nint status ;\nwaitpid(child, &status, 0) ;\nwrite(1, \"cleanup !\\n\",9);\n}\nint main() {\n//Register signal handler BEFORE the child can finish\nsignal(SIGCHLD, cleanup) ;//orbetter -sigaction\nchild = fork() ;\nif(child == -1) {exit(EXIT_FAILURE) ;}\nif(child == 0) {\n//Dobackground stuff e.g.call exec\n}else {/*I\u2019mthe parent !*/\nsleep(4) ;//sowecan see the cleanup\nputs( \"Parent isdone \");\n}\nreturn 0;\n}\nHowever, the above example misses a couple of subtle points.\n1.More than one child may have \ufb01nished but the parent will only get one SIGCHLD signal (signals are not\nqueued)\n2.SIGCHLD signals can be sent for other reasons (e.g. a child process has temporarily stopped)\n3.It uses the deprecated signal code, instead of the more portable sigaction.\nA more robust code to reap zombies is shown below.\nvoid cleanup( int signal) {\nint status ;\nwhile (waitpid((pid_t) (-1), 0, WNOHANG) >0){\n}\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1207, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7aaba711-3a58-49f2-ae87-a8296b1ab22f": {"__data__": {"id_": "7aaba711-3a58-49f2-ae87-a8296b1ab22f", "embedding": null, "metadata": {"page_label": "91", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "33ef6d4e-4ec5-458f-94f2-a65b4d005832", "node_type": "4", "metadata": {"page_label": "91", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f3f939f8245d8d1b4570e18e145b92fb82b6ca51dbbe795ed1d99f86850f427c", "class_name": "RelatedNodeInfo"}}, "text": "4.6. EXEC 91\n4.6 exec\nTo make the child process execute another program, use one of the exec functions after forking. The exec set of\nfunctions replaces the process image with that of the speci\ufb01ed program. This means that any lines of code after\ntheexec call are replaced with those of the executed program. Any other work a program wants the child process\nto do should be done before the exec call. The naming schemes can be shortened mnemonically .\n1.e \u2013 An array of pointers to environment variables is explicitly passed to the new process image.\n2.l \u2013 Command-line arguments are passed individually (a list) to the function.\n3.p \u2013 Uses the PATH environment variable to \ufb01nd the \ufb01le named in the \ufb01le argument to be executed.\n4.v \u2013 Command-line arguments are passed to the function as an array (vector) of pointers.\nNote that if the information is passed via an array , the last element must be followed by a NULL element to\nterminate the array .\nAn example of this code is below. This code executes ls\n#include <unistd.h >\n#include <sys/types.h >\n#include <sys/wait.h >\n#include <stdlib.h >\n#include <stdio.h >\nint main( int argc, char **argv) {\npid_t child = fork() ;\nif(child == -1) return EXIT_FAILURE ;\nif(child) {\nint status ;\nwaitpid(child , &status ,0) ;\nreturn EXIT_SUCCESS ;\n}else {\n//Other versions ofexec pass inarguments asarrays\n//Remember first arg isthe program name\n//Last arg must beachar pointer toNULL\nexecl( \"/bin/ls\",\"/bin/ls\",\"-alh\", (char *) NULL) ;\n//Ifweget tothis line ,something went wrong !\nperror( \"exec failed !\");\n}\n}\nTry to decode the following example", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1586, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "da042b45-2a4b-4464-9b43-5cb49453ad65": {"__data__": {"id_": "da042b45-2a4b-4464-9b43-5cb49453ad65", "embedding": null, "metadata": {"page_label": "92", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f68544ad-0038-43c6-9a8b-53e0ee19c017", "node_type": "4", "metadata": {"page_label": "92", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d7fe416af0a8ea47029b35f29e3b30355e6c6c4435bbb1c28dbce77804fc4b01", "class_name": "RelatedNodeInfo"}}, "text": "92 CHAPTER 4. PROCESSES\n#include <unistd.h >\n#include <fcntl.h >//O_CREAT ,O_APPEND etc.defined here\nint main() {\nclose(1) ;//close standard out\nopen( \"log.txt\", O_RDWR | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR) ;\nputs( \"Captain \u2019slog\");\nchdir( \"/usr/include \");\n//execl (executable ,arguments for executable including program name\nand NULL atthe end)\nexecl( \"/bin/ls\",/*Remaining items sent tols*/\"/bin/ls\",\".\",\n(char *) NULL) ;//\"ls.\"\nperror( \"exec failed \");\nreturn 0;\n}\nThe example writes \"Captain\u2019s Log\" to a \ufb01le then prints everything in /usr/include to the same \ufb01le. There\u2019s no\nerror checking in the above code (we assume close, open, chdir etc. work as expected).\n1.open \u2013 will use the lowest available \ufb01le descriptor (i.e. 1) ; so standard out(stdout) is now redirected to the\nlog \ufb01le.\n2.chdir \u2013 Change the current directory to /usr/include\n3.execl \u2013 Replace the program image with /bin/ls and call its main() method\n4.perror \u2013 We don\u2019t expect to get here - if we did then exec failed.\n5.We need the \"return 0;\" because compilers complain if we don\u2019t have it.\n4.6.1 POSIX Exec Details\nPOSIX details all of the semantics that exec needs to cover [3]. Note the following\n1.File descriptors are preserved after an exec. That means if a program open a \ufb01le and doesn\u2019t to close it,\nit remains open in the child. This is a problem because usually the child doesn\u2019t know about those \ufb01le\ndescriptors. Nevertheless, they take up a slot in the \ufb01le descriptor table and could possibly prevent other\nprocesses from accessing the \ufb01le. The one exception to this is if the \ufb01le descriptor has the Close-On-Exec\n\ufb02ag set (O_CLOEXEC) \u2013 we will go over setting \ufb02ags later.\n2.Various signal semantics. The executed processes preserve the signal mask and the pending signal set but\ndoes not preserve the signal handlers since it is a different program.\n3.Environment variables are preserved unless using an environ version of exec\n4.The operating system may open up 0, 1, 2 \u2013 stdin, stdout, stderr, if they are closed after exec, most of the\ntime they leave them closed.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2055, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fb9b6b0a-30bf-4b98-8047-0a9cf8413382": {"__data__": {"id_": "fb9b6b0a-30bf-4b98-8047-0a9cf8413382", "embedding": null, "metadata": {"page_label": "93", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f90a875c-76d8-42ec-9e84-91cdbabf3749", "node_type": "4", "metadata": {"page_label": "93", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d8dacf5dd0e5f2244b0ad96f734bca12497e75b6138638518c866b830ef2a212", "class_name": "RelatedNodeInfo"}}, "text": "4.7. THE FORK-EXEC-WAIT PATTERN 93\n5.The executed process runs as the same PID and has the same parent and process group as the previous\nprocess.\n6.The executed process is run on the same user and group with the same working directory\n4.6.2 Shortcuts\nsystem pre-packs the above code [9, P . 371 ]. The following is a snippet of how to use system.\n#include <unistd.h >\n#include <stdlib.h >\nint main( int argc, char **argv) {\nsystem( \"ls\");//execl (\"/bin/sh\",\"/bin/sh\",\"-c\",\"\\\\\" ls\\\\\"\")\nreturn 0;\n}\nThesystem call will fork, execute the command passed by parameter and the original parent process will\nwait for this to \ufb01nish. This also means that system is a blocking call. The parent process can\u2019t continue until the\nprocess started by system exits. Also, system actually creates a shell that is then given the string, which is more\noverhead than using exec directly . The standard shell will use the PATH environment variable to search for a\n\ufb01lename that matches the command. Using system will usually be suf\ufb01cient for many simple run-this-command\nproblems but can quickly become limiting for more complex or subtle problems, and it hides the mechanics of the\nfork-exec-wait pattern, so we encourage you to learn and use fork exec andwaitpid instead. It also tends to be\na huge security risk. By allowing someone to access a shell version of the environment, the program can run into\nall sorts of problems:\nint main( int argc, char **argv) {\nchar *to_exec = asprintf( \"ls%s\", argv[1]) ;\nsystem(to_exec) ;\n}\nPassing something along the lines of argv [1] =\"; sudo su\" is a huge security risk called privilege escalation.\n4.7 The fork-exec-wait Pattern\nA common programming pattern is to call fork followed by exec andwait . The original process calls fork, which\ncreates a child process. The child process then uses exec to start the execution of a new program. Meanwhile, the\nparent uses wait (orwaitpid ) to wait for the child process to \ufb01nish.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1944, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6de0d041-cd0d-4482-ae08-1d1a4c4ee88b": {"__data__": {"id_": "6de0d041-cd0d-4482-ae08-1d1a4c4ee88b", "embedding": null, "metadata": {"page_label": "94", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "05e5fddb-4fc1-4ce4-8203-d3c12b06876e", "node_type": "4", "metadata": {"page_label": "94", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ebf80a629c2060b98f4252a455977920518c80febba8d78425dbd427fdde3890", "class_name": "RelatedNodeInfo"}}, "text": "94 CHAPTER 4. PROCESSES\nParent\nChild exec()fork() wait()\nFigure 4.3: Fork, exec, wait diagram\n#include <unistd.h >\nint main() {\npid_t pid = fork() ;\nif(pid <0){//fork failure\nexit(1) ;\n}else if(pid >0){\nint status ;\nwaitpid(pid, &status, 0) ;\n}else {\nexecl( \"/bin/ls\",\"/bin/ls\", NULL) ;\nexit(1) ;//For safety .\n}\n}\nWhy not execute ls directly? The reason is that now we have a monitor program \u2013 our parent that can do\nother things. It can proceed and execute another function, or it can also modify the state of the system or read the\noutput of the function call.\n4.7.1 Environment Variables\nEnvironment variables are variables that the system keeps for all processes to use. Your system has these set up\nright now! In Bash, some are already de\ufb01ned\n$echo $HOME\n/home/user\n$echo $PATH\n/usr/ local /sbin:/usr/bin:...\nHow would a program later these in C? They can call getenv andsetenv function respectively .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 907, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8d13f3f6-55c2-4a37-bbab-0e7d15fb91cb": {"__data__": {"id_": "8d13f3f6-55c2-4a37-bbab-0e7d15fb91cb", "embedding": null, "metadata": {"page_label": "95", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "34114b5c-f30a-49eb-913b-4c029b66924b", "node_type": "4", "metadata": {"page_label": "95", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "5343fd0294bcada0b152a8960d56a156d82d412c6f440b16816ebd71af0bde01", "class_name": "RelatedNodeInfo"}}, "text": "4.8. FURTHER READING 95\nchar * home = getenv( \"HOME \");//Will return /home /user\nsetenv( \"HOME \",\"/home /user \", 1 /*set overwrite totrue */);\nEnvironment variables are important because they are inherited between processes and can be used to specify\na standard set of behaviors [2], although you don\u2019t need to memorize the options. Another security related\nconcern is that environment variables cannot be read by an outside process, whereas argv can be.\n4.8 Further Reading\nRead the man pages and the POSIX groups above! Here are some guiding questions. Note that we aren\u2019t expecting\nyou to memorize the man page.\n\u2022What is one reason fork may fail?\n\u2022Does fork copy all pages to the child?\n\u2022Are \ufb01le descriptors cloned between parent and child?\n\u2022Are \ufb01le descript ions cloned between parent and child?\n\u2022What is the difference between exec calls ending in an e?\n\u2022What is the difference between l and v in an exec call? How about p?\n\u2022When does exec error? What happens?\n\u2022Does wait only notify if a child has exited?\n\u2022Is it an error to pass a negative value into wait?\n\u2022How does one extract information out of the status?\n\u2022Why may wait fail?\n\u2022What happens when a parent doesn\u2019t wait on their children?\n\u2022fork\n\u2022exec\n\u2022wait\n4.8.1 Topics\n\u2022Correct use of fork, exec and waitpid\n\u2022Using exec with a path\n\u2022Understanding what fork and exec and waitpid do. E.g. how to use their return values.\n\u2022SIGKILL vs SIGSTOP vs SIGINT .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1409, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "611db140-d289-46bb-93b9-758b7c5263b5": {"__data__": {"id_": "611db140-d289-46bb-93b9-758b7c5263b5", "embedding": null, "metadata": {"page_label": "96", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "24d0e59e-7c0e-4d9c-8694-862da5bd9c9e", "node_type": "4", "metadata": {"page_label": "96", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "979fa49445ebb4bc85d6941cef9557594d83f311f10f7114842c121aeef8942e", "class_name": "RelatedNodeInfo"}}, "text": "96 CHAPTER 4. PROCESSES\n\u2022What signal is sent when press CTRL-C at a terminal?\n\u2022Using kill from the shell or the kill POSIX call.\n\u2022Process memory isolation.\n\u2022Process memory layout (where is the heap, stack etc; invalid memory addresses).\n\u2022What is a fork bomb, zombie and orphan? How to create /remove them.\n\u2022getpid vs getppid\n\u2022How to use the WAIT exit status macros WIFEXITED etc.\n4.9 Questions /Exercises\n\u2022What is the difference between execs with a p and without a p? What does the operating system\n\u2022How does a program pass in command line arguments to execl* ? How about execv* ? What should be\nthe \ufb01rst command line argument by convention?\n\u2022How does a program know if exec orfork failed?\n\u2022What is the int *status pointer passed into wait? When does wait fail?\n\u2022What are some differences between SIGKILL ,SIGSTOP ,SIGCONT ,SIGINT ? What are the default behaviors?\nWhich ones can a program set up a signal handler for?\n\u2022What signal is sent when you press CTRL-C ?\n\u2022My terminal is anchored to PID =1337 and has become unresponsive. Write me the terminal command\nand the C code to send SIGQUIT to it.\n\u2022Can one process alter another processes memory through normal means? Why?\n\u2022Where is the heap, stack, data, and text segment? Which segments can a program write to? What are\ninvalid memory addresses?\n\u2022Code up a fork bomb in C (please don\u2019t run it).\n\u2022What is an orphan? How does it become a zombie? What should a parent do to avoid this?\n\u2022Don\u2019t you hate it when your parents tell you that you can\u2019t do something? Write a program that sends\nSIGSTOP to a parent process.\n\u2022Write a function that fork exec waits an executable, and using the wait macros tells me if the process exited\nnormally or if it was signaled. If the process exited normally , then print that with the return value. If not,\nthen print the signal number that caused the process to terminate.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1857, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fb7a946c-0d8a-4d10-a835-8b91d0ad0228": {"__data__": {"id_": "fb7a946c-0d8a-4d10-a835-8b91d0ad0228", "embedding": null, "metadata": {"page_label": "97", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "22b3f44f-4ad1-4d34-a82d-571c2b577b6e", "node_type": "4", "metadata": {"page_label": "97", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a8621583215182dfaa0beeac9dba386e390167b7478c2beb709a6cfebab0ab9b", "class_name": "RelatedNodeInfo"}}, "text": "BIBLIOGRAPHY 97\nBibliography\n[1]Source to sys /wait.h. URL http://unix.superglobalmegacorp.com/Net2/newsrc/sys/wait.h.html .\n[2]Environment variables, Jul 2018. URL https://pubs.opengroup.org/onlinepubs/9699919799/\nbasedefs/V1_chap08.html .\n[3]exec, Jul 2018. URL https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html .\n[4]fork, Jul 2018. URL https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html .\n[5]Overview of malloc, Mar 2018. URL https://sourceware.org/glibc/wiki/MallocInternals .\n[6]De\ufb01nitions, Jul 2018. URL http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_\nchap03.html#tag_03_210 .\n[7]Daniel Bovet and Marco Cesati. Understanding The Linux Kernel . Oreilly & Associates Inc, 2005. ISBN\n0596005652.\n[8]Julia Evans. File descriptors, Apr 2018. URL https://drawings.jvns.ca/file-descriptors/ .\n[9]Larry Jones. Wg14 n1539 committee draft iso /iec 9899: 201x, 2010.\n[10]Peter Van der Linden. Expert C programming: deep C secrets . Prentice Hall Professional, 1994.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1010, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3dc626c7-34d3-4384-bba6-1cec5b7e2f01": {"__data__": {"id_": "3dc626c7-34d3-4384-bba6-1cec5b7e2f01", "embedding": null, "metadata": {"page_label": "306", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1a76c8e1-ebca-4586-a5da-e59a20636cca", "node_type": "4", "metadata": {"page_label": "306", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ae66225ecc6f63b01da54f9ca15bad8980d242613b1de70bd40c7be14bb8f802", "class_name": "RelatedNodeInfo"}}, "text": "15\nReview\nA non-comprehensive list of topics is below.\n15.1 C\n15.1.1 Memory and Strings\n1.In the example below, which variables are guaranteed to print the value of zero?\nint a;\nstatic int b;\nvoid func() {\nstatic int c;\nint d;\nprintf( \"%d%d%d%d\\n\",a,b,c,d) ;\n}\n2.In the example below, which variables are guaranteed to print the value of zero?\nvoid func() {\nint* ptr1 = malloc( sizeof (int));\nint* ptr2 = realloc(NULL, sizeof (int));\nint* ptr3 = calloc(1, sizeof (int));\nint* ptr4 = calloc( sizeof (int), 1) ;\nprintf( \"%d%d%d%d\\n\",*ptr1,*ptr2,*ptr3,*ptr4) ;\n}\n306", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 563, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0272bb7d-543e-4907-8cd9-7116ecefde79": {"__data__": {"id_": "0272bb7d-543e-4907-8cd9-7116ecefde79", "embedding": null, "metadata": {"page_label": "307", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3672e5cf-e2c6-4a0a-b5f2-20e5bdc4187b", "node_type": "4", "metadata": {"page_label": "307", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a4ae7415f8b8b12a4093ff4ee54f85ffd45c06fe5851a987b24a2c18d3c48b0b", "class_name": "RelatedNodeInfo"}}, "text": "15.1. C 307\n3.Explain the error in the following attempt to copy a string.\nchar * copy( char *src) {\nchar *result = malloc( strlen(src) ) ;\nstrcpy(result, src) ;\nreturn result ;\n}\n4.Why does the following attempt to copy a string sometimes work and sometimes fail?\nchar * copy( char *src) {\nchar *result = malloc( strlen(src) +1 ) ;\nstrcat(result, src) ;\nreturn result ;\n}\n5.Explain the two errors in the following code that attempts to copy a string.\nchar * copy( char *src) {\nchar result[ sizeof (src)] ;\nstrcpy(result, src) ;\nreturn result ;\n}\n6.Which of the following is legal?\nchar a[] = \"Hello \";strcpy(a, \"World \");\nchar b[] = \"Hello \";strcpy(b, \"World12345 \", b) ;\nchar * c = \"Hello \";strcpy(c, \"World \");\n7.Complete the function pointer typedef to declare a pointer to a function that takes a void* argument and\nreturns a void*. Name your type \u2018pthread_callback\u2019\ntypedef ______________________ ;\n8.In addition to the function arguments what else is stored on a thread\u2019s stack?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 985, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4cda223-39a2-48cb-9461-39644f748f69": {"__data__": {"id_": "e4cda223-39a2-48cb-9461-39644f748f69", "embedding": null, "metadata": {"page_label": "308", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "172c2c71-ee13-4afb-ba6a-0fd681edc954", "node_type": "4", "metadata": {"page_label": "308", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "5b036ed87ad4735af039080744d9a72ddea511e7cafe84274d31a4fa6c8673de", "class_name": "RelatedNodeInfo"}}, "text": "308 CHAPTER 15. REVIEW\n9.Implement a version of char* strcat(char*dest, const char*src) using only strcpy strlen and\npointer arithmetic\nchar * mystrcat( char *dest, const char *src) {\n? Use strcpy strlen here\nreturn dest ;\n}\n10.Implement version of size_t strlen(const char*) using a loop and no function calls.\nsize_t mystrlen( const char *s) {\n}\n11.Identify the three bugs in the following implementation of strcpy .\nchar * strcpy( const char * dest, const char * src) {\nwhile (*src) {*dest ++= *src ++;}\nreturn dest ;\n}\n15.1.2 Printing\n1.Spot the two errors!\nfprintf( \"You scored 100% \");\n2.Complete the following code to print to a \ufb01le. Print the name, a comma and the score to the \ufb01le \u2018result.txt\u2019\nchar * name = ..... ;\nint score = ......\nFILE *f = fopen( \"result .txt\",_____) ;\nif(f) {\n_____", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 797, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27430c41-6220-4835-9a4b-285e1d962ac6": {"__data__": {"id_": "27430c41-6220-4835-9a4b-285e1d962ac6", "embedding": null, "metadata": {"page_label": "309", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "53a407b0-b77c-42d7-b003-4e4980be6e11", "node_type": "4", "metadata": {"page_label": "309", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3c621eac4f7ba2f789b228377852bc63a5a3deee3b628c5d9cb3c76e41520c89", "class_name": "RelatedNodeInfo"}}, "text": "15.2. PROCESSES 309\n}\nfclose(f) ;\n3.How would you print the values of the variables a,mesg ,valandptrto a string? Print a as an integer,\nmesg as C string, val as a double val and ptr as a hexadecimal pointer. You may assume the mesg points to a\nshort C string( <50 characters). Bonus: How would you make this code more robust or able to cope with?\nchar * toString( int a,char *mesg, double val, void * ptr) {\nchar * result = malloc( strlen(mesg) + 50) ;\n_____\nreturn result ;\n}\n15.1.3 Input parsing\n1.Why should you check the return value of sscanf and scanf? ## Q 5.2 Why is \u2018gets\u2019 dangerous?\n2.Write a complete program that uses getline . Ensure your program has no memory leaks.\n3.When would you use calloc instead of malloc? When would realloc be useful?\n4.What mistake did the programmer make in the following code? Is it possible to \ufb01x it\ni) using heap memory? ii) using global (static) memory?\nstatic int id;\nchar * next_ticket() {\nid++;\nchar result[20] ;\nsprintf(result, \"%d\",id) ;\nreturn result ;\n}\n15.2 Processes\n1.What is a process?\n2.What attributes are carried over from a process on fork? How about on a successful exec call?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1139, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f882ea27-9ec0-4efb-adf0-7b9295f866b0": {"__data__": {"id_": "f882ea27-9ec0-4efb-adf0-7b9295f866b0", "embedding": null, "metadata": {"page_label": "310", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8a597797-d489-45be-9578-b1f11480e9fd", "node_type": "4", "metadata": {"page_label": "310", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "eefa1b57927501f7a3452dbccaf92c29d2948ec877fecbb1efe779c37f051fcf", "class_name": "RelatedNodeInfo"}}, "text": "310 CHAPTER 15. REVIEW\n3.What is a fork bomb? How can we avoid one?\n4.What is the wait system call used for?\n5.What is a zombie? How do we avoid them?\n6.What is an orphan? What happens to them?\n7.How do we check the status of a process that has exited?\n8.What is a common pattern of processes?\n15.3 Memory\n1.What are the calls in C to allocate memory?\n2.What must malloc memory be aligned to? Why is it important?\n3.What is Knuth\u2019s Allocation Scheme?\n4.How would you handle a request in a buddy allocation scheme?\n5.What is a free list?\n6.What are some different ways of inserting into a free list?\n7.What are the bene\ufb01ts and drawbacks to \ufb01rst \ufb01t, worst \ufb01t, best \ufb01t?\n8.When would a trivial malloc implementation\nvoid *malloc( int size) {\nreturn (void *)sbrk(size) ;\n}\nBe acceptable?\n15.4 Threading and Synchronization\n1.What is a thread? What do threads share?\n2.How does one create a thread?\n3.Where are the stacks for a thread located in memory?\n4.What is a mutex? What problem does it solve?\n5.What is a condition variable? What problem does it solve?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1054, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "768e1e44-5820-468f-b202-57f26cedde5c": {"__data__": {"id_": "768e1e44-5820-468f-b202-57f26cedde5c", "embedding": null, "metadata": {"page_label": "311", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "00a8a64f-a260-4723-9ca2-905e109f75ce", "node_type": "4", "metadata": {"page_label": "311", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b26f8cae5f9104b183434416bbfd49ade857d77b77a038f835cea17f75c1c5ba", "class_name": "RelatedNodeInfo"}}, "text": "15.4. THREADING AND SYNCHRONIZATION 311\n6.Write a thread safe linked list that supports insert front, back, pop front, and pop back. Make sure it doesn\u2019t\nbusy wait!\n7.What is Peterson\u2019s Solution to the critical section problem? How about Dekker\u2019s?\n8.Is the following code thread-safe? Redesign the following code to be thread-safe. Hint: A mutex is\nunnecessary if the message memory is unique to each call.\nstatic char message[20] ;\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ;\nvoid *format( int v){\npthread_mutex_lock(&mutex) ;\nsprintf(message, \":%d:\",v);\npthread_mutex_unlock(&mutex) ;\nreturn message ;\n}\n9.Which one of the following may leave a process in running?\n(a)Returning from the pthread\u2019s starting function in the last running thread.\n(b)The original thread returning from main.\n(c)Any thread causing a segmentation fault.\n(d)Any thread calling exit .\n(e)Calling pthread_exit in the main thread with other threads still running.\n10.Write a mathematical expression for the number of \u201cW\u201d characters that will be printed by the following\nprogram. Assume a,b,c,d are small positive integers. Your answer may use a \u2018min\u2019 function that returns its\nlowest valued argument.\nunsigned int a=...,b=...,c=...,d=... ;\nvoid * func( void * ptr) {\nchar m = * ( char *)ptr ;\nif(m == \u2019P\u2019) sem_post(s) ;\nif(m == \u2019W\u2019) sem_wait(s) ;\nputchar(m) ;\nreturn NULL ;\n}\nint main( int argv, char ** argc) {\nsem_init(s,0, a) ;\nwhile (b--) pthread_create(&tid, NULL, func, \"W\");\nwhile (c--) pthread_create(&tid, NULL, func, \"P\");\nwhile (d--) pthread_create(&tid, NULL, func, \"W\");", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1566, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e436db12-919e-4822-b6de-ccdc2f304527": {"__data__": {"id_": "e436db12-919e-4822-b6de-ccdc2f304527", "embedding": null, "metadata": {"page_label": "312", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "47c0629d-452f-4451-87b6-06af971fa3e0", "node_type": "4", "metadata": {"page_label": "312", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6a7a0e22a27dccb69ab9a1a9592c81ae2392073eb5b8683cbc46d759f4e2f164", "class_name": "RelatedNodeInfo"}}, "text": "312 CHAPTER 15. REVIEW\npthread_exit(NULL) ;\n/*Process will finish when all threads have exited */\n}\n11.Complete the following code. The following code is supposed to print alternating AandB. It represents two\nthreads that take turns to execute. Add condition variable calls to func so that the waiting thread need not\nto continually check the turn variable. Q: Is pthread_cond_broadcast necessary or is pthread_cond_signal\nsuf\ufb01cient?\npthread_cond_t cv = PTHREAD_COND_INITIALIZER ;\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER ;\nvoid * turn ;\nvoid * func( void * mesg) {\nwhile (1) {\n//Add mutex lock and condition variable calls ...\nwhile (turn == mesg) {\n/*poll again ... Change me-This busy loop burns CPU time !\n*/\n}\n/*Dostuff onthis thread */\nputs( ( char *) mesg) ;\nturn = mesg ;\n}\nreturn 0;\n}\nint main( int argc, char ** argv) {\npthread_t tid1 ;\npthread_create(&tid1, NULL, func, \"A\");\nfunc( \"B\");//noneed tocreate another thread -use the main\nthread\nreturn 0;\n}\n12.Identify the critical sections in the given code. Add mutex locking to make the code thread safe. Add\ncondition variable calls so that total never becomes negative or above 1000. Instead the call should block\nuntil it is safe to proceed. Explain why pthread_cond_broadcast is necessary .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1259, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3843a229-4552-4fe9-8f45-6ae1e7ef2dca": {"__data__": {"id_": "3843a229-4552-4fe9-8f45-6ae1e7ef2dca", "embedding": null, "metadata": {"page_label": "313", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d37b295f-ea6c-4bee-a644-19a1951d38c9", "node_type": "4", "metadata": {"page_label": "313", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9547f25fd7a1d7d8504151a3874106641395408f14f3edda62402d9a1a7a6a1a", "class_name": "RelatedNodeInfo"}}, "text": "15.4. THREADING AND SYNCHRONIZATION 313\nint total ;\nvoid add( int value) {\nif(value <1)return ;\ntotal += value ;\n}\nvoid sub( int value) {\nif(value <1)return ;\ntotal -= value ;\n}\n13.An thread unsafe data structure has size() enqanddeqmethods. Use condition variable and mutex lock\nto complete the thread-safe, blocking versions.\nvoid enqueue( void * data) {\n//should block ifthe size ()would become greater than 256\nenq(data) ;\n}\nvoid * dequeue() {\n//should block ifsize ()is0\nreturn deq() ;\n}\n14.Your startup offers path planning using the latest traf\ufb01c information. Your overpaid intern has created a\nthread unsafe data structure with two functions: shortest (which uses but does not modify the graph)\nandset_edge (which modi\ufb01es the graph).\ngraph_t* create_graph( char * filename) ;//called once\n//returns anew heap object that isthe shortest path from vertex\nitoj\npath_t* shortest(graph_t* graph, int i,int j);\n//updates edge from vertex itoj\nvoid set_edge(graph_t* graph, int i,int j,double time) ;\nFor performance, multiple threads must be able to call shortest at the same time but the graph can only\nbe modi\ufb01ed by one thread when no threads other are executing inside shortest orset_edge .\n15.Use mutex lock and condition variables to implement a reader-writer solution. An incomplete attempt is\nshown below. Though this attempt is thread safe (thus suf\ufb01cient for demo day!), it does not allow multiple\nthreads to calculate shortest path at the same time and will not have suf\ufb01cient throughput.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1500, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4ee90e4-a1ad-42bb-b18d-725b148b77d7": {"__data__": {"id_": "e4ee90e4-a1ad-42bb-b18d-725b148b77d7", "embedding": null, "metadata": {"page_label": "314", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4f65aa5a-c28e-473a-8ebc-46652cce472a", "node_type": "4", "metadata": {"page_label": "314", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f29fb808207bb699df082481e0317d39468f6aa00268641744c3bdcaa640862f", "class_name": "RelatedNodeInfo"}}, "text": "314 CHAPTER 15. REVIEW\npath_t* shortest_safe(graph_t* graph, int i,int j){\npthread_mutex_lock(&m) ;\npath_t* path = shortest(graph, i, j) ;\npthread_mutex_unlock(&m) ;\nreturn path ;\n}\nvoid set_edge_safe(graph_t* graph, int i,int j,double dist) {\npthread_mutex_lock(&m) ;\nset_edge(graph, i, j, dist) ;\npthread_mutex_unlock(&m) ;\n}\n16.How many of the following statements are true for the reader-writer problem?\n\u2022There can be multiple active readers\n\u2022There can be multiple active writers\n\u2022When there is an active writer the number of active readers must be zero\n\u2022If there is an active reader the number of active writers must be zero\n\u2022A writer must wait until the current active readers have \ufb01nished\n15.5 Deadlock\n1.What do each of the Coffman conditions and what do they mean? Can you provide a de\ufb01nition of each one\nand an example of breaking them using mutexes?\n2.Give a real life example of breaking each Coffman condition in turn. A situation to consider: Painters, paint\nand paint brushes.\n(a)Hold and wait\n(b)Circular wait\n(c)No preemption\n(d)Mutual exclusion\n3.Identify when Dining Philosophers code causes a deadlock (or not). For example, if you saw the following\ncode snippet which Coffman condition is not satis\ufb01ed?\n//Get both locks ornone .\npthread_mutex_lock( a ) ;\nif( pthread_mutex_trylock( b ) ) {/*failed */\npthread_mutex_unlock( a ) ;\n...\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1355, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "77f6c88d-5aeb-4e3b-af72-b3a4e0c36520": {"__data__": {"id_": "77f6c88d-5aeb-4e3b-af72-b3a4e0c36520", "embedding": null, "metadata": {"page_label": "315", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7f23e810-8db4-4937-a758-99e6a5459297", "node_type": "4", "metadata": {"page_label": "315", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "96b40b581b068a22b6deafc58a7340e8f54506284613bd2e572f814d688b5bd8", "class_name": "RelatedNodeInfo"}}, "text": "15.6. IPC 315\n4.How many processes are blocked?\n\u2022P1 acquires R1\n\u2022P2 acquires R2\n\u2022P1 acquires R3\n\u2022P2 waits for R3\n\u2022P3 acquires R5\n\u2022P1 acquires R4\n\u2022P3 waits for R1\n\u2022P4 waits for R5\n\u2022P5 waits for R1\n5.What are the pros and cons for the following solutions to dining philosophers\n(a)Arbitrator\n(b)Dijkstra\n(c)Stalling\u2019s\n(d)Trylock\n15.6 IPC\n1.What are the following and what is their purpose?\n(a)Translation Lookaside Buffer\n(b)Physical Address\n(c)Memory Management Unit\n(d)The dirty bit\n2.How do you determine how many bits are used in the page offset?\n3.20 ms after a context switch the TLB contains all logical addresses used by your numerical code which\nperforms main memory access 100% of the time. What is the overhead (slowdown) of a two-level page\ntable compared to a single-level page table?\n4.Explain why the TLB must be \ufb02ushed when a context switch occurs (i.e. the CPU is assigned to work on a\ndifferent process).\n5.Fill in the blanks to make the following program print 123456789. If catis given no arguments it simply\nprints its input until EOF . Bonus: Explain why the close call below is necessary .\nint main() {\nint i = 0 ;\nwhile (++i<10) {\npid_t pid = fork() ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1173, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d90c905e-65bd-40d6-a389-b68605888b9a": {"__data__": {"id_": "d90c905e-65bd-40d6-a389-b68605888b9a", "embedding": null, "metadata": {"page_label": "316", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "49fbf5fc-83f9-461f-9835-416e44914a4c", "node_type": "4", "metadata": {"page_label": "316", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8d99699af3361ac2460ced1e2a837d56c9583fc3892b6e6cb99904ae613b235b", "class_name": "RelatedNodeInfo"}}, "text": "316 CHAPTER 15. REVIEW\nif(pid == 0) {/*child */\nchar buffer[16] ;\nsprintf(buffer, ______,i) ;\nint fds[ ______] ;\npipe(fds) ;\nwrite(fds[1], ______,______ ) ;//Write the buffer into the\npipe\nclose(______) ;\ndup2(fds[0], ______) ;\nexeclp( \"cat\",\"cat\", ______) ;\nperror( \"exec \");exit(1) ;\n}\nwaitpid(pid, NULL, 0) ;\n}\nreturn 0;\n}\n6.Use POSIX calls fork pipe dup2 andclose to implement an autograding program. Capture the standard\noutput of a child process into a pipe. The child process should exec the program ./test with no additional\narguments (other than the process name). In the parent process read from the pipe: Exit the parent process\nas soon as the captured output contains the ! character. Before exiting the parent process send SIGKILL to\nthe child process. Exit 0 if the output contained a !. Otherwise if the child process exits causing the pipe\nwrite end to be closed, then exit with a value of 1. Be sure to close the unused ends of the pipe in the parent\nand child process\n7.This advanced challenge uses pipes to get an \u201cAI player\u201d to play itself until the game is complete. The\nprogram tic tac toe accepts a line of input - the sequence of turns made so far, prints the same sequence\nfollowed by another turn, and then exits. A turn is speci\ufb01ed using two characters. For example \u201cA1\u201d and\n\u201cC3\u201d are two opposite corner positions. The string B2A1A3 is a game of 3 turns /plys. A valid response is\nB2A1A3C1 (the C1 response blocks the diagonal B2 A3 threat). The output line may also include a suf\ufb01x\n-I win -You win -invalid or-draw Use pipes to control the input and output of each child process\ncreated. When the output contains a -, print the \ufb01nal output line (the entire game sequence and the result)\nand exit.\n8.Write a function that uses fseek and ftell to replace the middle character of a \ufb01le with an \u2018X\u2019\nvoid xout( char * filename) {\nFILE *f = fopen(filename, ____ ) ;\n//Your code here ...\n}\n9.What is an MMU? What are the drawbacks to using it versus a direct memory system?\n10.What is a pipe?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2013, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c2906f00-c702-49c5-b6aa-4ca6f302ad06": {"__data__": {"id_": "c2906f00-c702-49c5-b6aa-4ca6f302ad06", "embedding": null, "metadata": {"page_label": "317", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "076682ff-baaa-4474-8b2d-d2a31e7d0f6e", "node_type": "4", "metadata": {"page_label": "317", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "0d315b7964f042c9158e162414ffbdd3929f85ddfbbc36754a63847083407160", "class_name": "RelatedNodeInfo"}}, "text": "15.7. FILESYSTEMS 317\n11.What are the pros and cons between named and unnamed pipes?\n15.7 Filesystems\n1.What is the \ufb01le API?\n2.Where are the names of the \ufb01les stored?\n3.What is contained in an inode?\n4.What are the two special \ufb01le names in every directory\n5.How do you resolve the following path a/../b/./c/../../c\n6.What are the rwx groups?\n7.What is an UID? GID? What is the difference between UID and Effective UID?\n8.What is umask?\n9.What is the sticky bit?\n10.What is a virtual \ufb01le system?\n11.What is RAID?\n12.In an ext2 \ufb01lesystem how many inodes are read from disk to access the \ufb01rst byte of the \ufb01le /dir1/subdirA/notes.txt\n? Assume the directory names and inode numbers in the root directory (but not the inodes themselves) are\nalready in memory .\n13.In an ext2 \ufb01lesystem what is the minimum number of disk blocks that must be read from disk to access the\n\ufb01rst byte of the \ufb01le /dir1/subdirA/notes.txt ? Assume the directory names and inode numbers in the\nroot directory and all inodes are already in memory .\n14.In an ext2 \ufb01lesystem with 32 bit addresses and 4KiB disk blocks, an inode can store 10 direct disk block\nnumbers. What is the minimum \ufb01le size required to require a single indirection table? ii) a double direction\ntable?\n15.Fix the shell command chmod below to set the permission of a \ufb01le secret.txt so that the owner can\nread,write,and execute permissions the group can read and everyone else has no access.\n$ chmod 000 secret.txt\n15.8 Networking\n1.What is a socket?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1486, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f589a889-a384-439a-abe4-5ba2370d3a7a": {"__data__": {"id_": "f589a889-a384-439a-abe4-5ba2370d3a7a", "embedding": null, "metadata": {"page_label": "318", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "802109ea-1595-4395-9f9f-8d08ec973ce6", "node_type": "4", "metadata": {"page_label": "318", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "66632541981fa29a441fc994b6901e6975b64810a4b418f580506bd30d8e0233", "class_name": "RelatedNodeInfo"}}, "text": "318 CHAPTER 15. REVIEW\n2.What are the different layers of the internet?\n3.What is IP? What is an IP address?\n4.What is TCP? What is UDP? What are the differences?\n5.Create a TCP client that send \u201cHello\u201d to a server.\n6.Create a simple TCP echo server. This is a server that reads bytes from a client until it closes and echoes the\nbytes back to the client.\n7.Create a UDP client that would send a \ufb02ood of packets to a hostname at argv [1].\n8.What is HTTP?\n9.What is DNS?\n10.Why do we use non-blocking IO for networking?\n11.What is an RPC?\n12.What is special about listening on port 1000 vs port 2000?\n\u2022Port 2000 is twice as slow as port 1000\n\u2022Port 2000 is twice as fast as port 1000\n\u2022Port 1000 requires root privileges\n\u2022Nothing\n13.Describe one signi\ufb01cant difference between IPv4 and IPv6?\n14.When and why would you use ntohs?\n15.If a host address is 32 bits which IP scheme am I most likely using? 128 bits?\n16.Which common network protocol is packet based and may not successfully deliver the data?\n17.Which common protocol is stream-based and will resend data if packets are lost?\n18.What is the SYN ACK ACK-SYN handshake?\n19.Which one of the following is NOT a feature of TCP?\n(a)Packet reordering\n(b)Flow control\n(c)Packet retranmission\n(d)Simple error detection\n(e)Encryption\n20.What protocol uses sequence numbers? What is their initial value? And why?\n21.What are the minimum network calls are required to build a TCP server? What is their correct order?\n22.What are the minimum network calls are required to build a TCP client? What is their correct order?\n23.When would you call bind on a TCP client?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1608, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "de1f07df-a9d6-4021-9c3a-9ac6a28e8155": {"__data__": {"id_": "de1f07df-a9d6-4021-9c3a-9ac6a28e8155", "embedding": null, "metadata": {"page_label": "319", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ec51867a-8144-4cbb-9a1e-cd08f30ea021", "node_type": "4", "metadata": {"page_label": "319", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9dfd89ea5d70711f49acb874f3d42c600b389688e16f2390488072b0e41c7aa0", "class_name": "RelatedNodeInfo"}}, "text": "15.8. NETWORKING 319\n24.What is the purpose of socket bind listen accept ?\n25.Which of the above calls can block, waiting for a new client to connect?\n26.What is DNS? What does it do for you? Which of the CS241 network calls will use it for you?\n27.For getaddrinfo, how do you specify a server socket?\n28.Why may getaddrinfo generate network packets?\n29.Which network call speci\ufb01es the size of the allowed backlog?\n30.Which network call returns a new \ufb01le descriptor?\n31.When are passive sockets used?\n32.When is epoll a better choice than select? When is select a better choice than epoll?\n33.Willwrite(fd, data, 5000) always send 5000 bytes of data? When can it fail?\n34.How does Network Address Translation (NAT) work?\n35.Assuming a network has a 20ms One Way Transit Time between Client and Server, how much time would it\ntake to establish a TCP Connection?\n(a)20ms\n(b)40ms\n(c)100ms\n(d)60ms\n36.What are some of the differences between HTTP 1.0 and HTTP 1.1? How many ms will it take to transmit 3\n\ufb01les from server to client if the network has a 20ms transmit time? How does the time taken differ between\nHTTP 1.0 and HTTP 1.1?\n37.Writing to a network socket may not send all of the bytes and may be interrupted due to a signal. Check the\nreturn value of write to implement write_all that will repeatedly call write with any remaining data.\nIfwrite returns -1 then immediately return -1 unless the errno isEINTR - in which case repeat the last\nwrite attempt. You will need to use pointer arithmetic.\n//Returns -1ifwrite fails (unless EINTR inwhich case itrecalls\nwrite\n//Repeated calls write until all ofthe buffer iswritten .\nssize_t write_all( int fd, const char *buf, size_t nbyte) {\nssize_t nb = write(fd, buf, nbyte) ;\nreturn nb;\n}\n38.Implement a multithreaded TCP server that listens on port 2000. Each thread should read 128 bytes from\nthe client \ufb01le descriptor and echo it back to the client, before closing the connection and ending the thread.\n39.Implement a UDP server that listens on port 2000. Reserve a buffer of 200 bytes. Listen for an arriving\npacket. Valid packets are 200 bytes or less and start with four bytes 0x65 0x66 0x67 0x68. Ignore invalid\npackets. For valid packets add the value of the \ufb01fth byte as an unsigned value to a running total and print\nthe total so far. If the running total is greater than 255 then exit.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2346, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "47a9ecf0-6a3c-4240-bc0e-28384d17d41c": {"__data__": {"id_": "47a9ecf0-6a3c-4240-bc0e-28384d17d41c", "embedding": null, "metadata": {"page_label": "320", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c3f5dd12-57a6-4a0c-a35f-a2c956b303fa", "node_type": "4", "metadata": {"page_label": "320", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "632eaa893ebbd5be926c7d3e8ef949c9d5196d7c2d52ff21b4b2390b6e30fa1e", "class_name": "RelatedNodeInfo"}}, "text": "320 CHAPTER 15. REVIEW\n15.9 Security\n1.What are the three measures for data security?\n2.What is stack smashing?\n3.What is buffer over\ufb02ows?\n4.How does an operating system provide security? What are some examples from Networking and Filesystems?\n5.What security features does TCP provide?\n6.Is DNS secure?\n15.10 Signals\n1.Give the names of two signals that are normally generated by the kernel\n2.Give the name of a signal that can not be caught by a signal\n3.Why is it unsafe to call any function (something that it is not signal handler safe) in a signal handler?\n4.Write brief code that uses SIGACTION and a SIGNALSET to create a SIGALRM handler.\n5.What is the difference between a disposition, mask, and pending signal set?\n6.What attributes are passed over to process children? How about exececuted processes?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 811, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "11128841-fc44-4c17-af9d-39e5ee259e26": {"__data__": {"id_": "11128841-fc44-4c17-af9d-39e5ee259e26", "embedding": null, "metadata": {"page_label": "216", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a8f88bf6-abb2-4231-8cbd-de26991d3960", "node_type": "4", "metadata": {"page_label": "216", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b3520e6bd8f377d57dc83ad9af78e02a5316b57b07b2915f6e5936a13c855563", "class_name": "RelatedNodeInfo"}}, "text": "10\nScheduling\nI wish that I could \ufb02y\nThere\u2019s danger if I dare to stop and here\u2019s the reason why\nYou see I\u2019m overdue\nI\u2019m in a rabbit stew\nCan\u2019t even say \"Good-bye\", hello\nI\u2019m late, I\u2019m late, I\u2019m late\nNo, no, no, no, no, no, no!\nAlice in Wonderland\nCPU Scheduling is the problem of ef\ufb01ciently selecting which process to run on a system\u2019s CPU cores. In a busy\nsystem, there will be more ready-to-run processes than there are CPU cores, so the system kernel must evaluate\nwhich processes should be scheduled to run and which processes should be executed later. The system must also\ndecide whetherit should take a particular process and pause its execution \u2013 along with any associated threads.\nThe balance comes from stopping processes often enough where you have a responsive computer but infrequently\nenough where the programs themselves are spending minimal time context switching. It is a hard balance to get\nright.\nThe additional complexity of multi-threaded and multiple CPU cores are considered a distraction to this initial\nexposition so are ignored here. Another gotcha for non-native speakers is the dual meaning of \u201cTime\u201d: The word\n\u201cTime\u201d can be used in both clock and elapsed duration context. For example \u201cThe arrival time of the \ufb01rst process\nwas 9:00am.\u201d and, \u201cThe running time of the algorithm is 3 seconds\u201d.\nOne clari\ufb01cation that we will make is that our scheduling will mainly deal with short term or CPU scheduling.\nThat means we will assume that the processes are in memory and ready to go. The other types of scheduling\nare long and medium term. Long term schedulers act as gatekeepers to the processing world. When a process\nrequests another process to be executed, it can either tell the process yes, no, or wait. The medium term scheduler\ndeals with the caveats of moving a process from the paused state in memory to the paused state on disk when\nthere are too many processes or some process are known to use an insigni\ufb01cant amount of CPU cycles. Think\nabout a process that only checks something once an hour.\n216", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2031, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "509c8708-14ec-456e-98c7-4e68d50a74ea": {"__data__": {"id_": "509c8708-14ec-456e-98c7-4e68d50a74ea", "embedding": null, "metadata": {"page_label": "217", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cff4897c-4ac5-4f1b-839c-860ae2dc8940", "node_type": "4", "metadata": {"page_label": "217", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8c7ae08c2edaff3b5f97b9d19b81e3b6c11285740ab22d03d5032cab1e3eead5", "class_name": "RelatedNodeInfo"}}, "text": "10.1. HIGH LEVEL SCHEDULER OVERVIEW 217\n10.1 High Level Scheduler Overview\nSchedulers are pieces of software programs. In fact, you can implement schedulers yourself! If you are given\na list of commands to exec, a program can schedule them them with SIGSTOP and SIGCONT . These are called\nuser space schedulers. Hadoop and python\u2019s celery may do some sort of user space scheduling or deal with the\noperating system.\nAt the operating system level, you generally have this type of \ufb02owchart, described in words \ufb01rst below. Note,\nplease don\u2019t memorize all the states.\n1.New is the initial state. A process has been requested to schedule. All process requests come from fork or\nclone. At this point the operating system knows it needs to create a new process.\n2.A process moves from the new state to the ready . This means any structs in the kernel are allocated. From\nthere, it can go into ready suspended or running.\n3.Running is the state that we hope most of our processes are in, meaning they are doing useful work. A\nprocess could either get preempted, blocked, or terminate. Preemption brings the process back to the ready\nstate. If a process is blocked, that means it could be waiting on a mutex lock, or it could\u2019ve called sleep \u2013\neither way , it willingly gave up control.\n4.On the blocked state the operating system can either turn the process ready or it can go into a deeper state\ncalled blocked suspended.\n5.There are so-called deep slumber states called blocked suspended and blocked ready . You don\u2019t need to\nworry about these.\nWe will try to pick a scheme that decides when a process should move to the running state, and when it should\nbe moved back to the ready state. We won\u2019t make much mention of how to factor in voluntarily blocked states\nand when to switch to deep slumber states.\n10.2 Measurements\nScheduling affects the performance of the system, speci\ufb01cally the latency and throughput of the system. The\nthroughput might be measured by a system value, for example, the I /O throughput - the number of bits written\nper second, or the number of small processes that can complete per unit time. The latency might be measured\nby the response time \u2013 elapse time before a process can start to send a response \u2013 or wait time or turnaround\ntime \u2013the elapsed time to complete a task. Different schedulers offer different optimization trade-offs that may be\nappropriate for desired use. There is no optimal scheduler for all possible environments and goals. For example,\nShortest Job First will minimize total wait time across all jobs but in interactive (UI) environments it would be\npreferable to minimize response time at the expense of some throughput, while FCFS seems intuitively fair and\neasy to implement but suffers from the Convoy Effect. Arrival time is the time at which a process \ufb01rst arrives at\nthe ready queue, and is ready to start executing. If a CPU is idle, the arrival time would also be the starting time\nof execution.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2951, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ea400ccf-8c9e-4329-abb4-135793cfc07c": {"__data__": {"id_": "ea400ccf-8c9e-4329-abb4-135793cfc07c", "embedding": null, "metadata": {"page_label": "218", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2191a06e-6b93-4504-a434-41d54402c08a", "node_type": "4", "metadata": {"page_label": "218", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d7a044c82a792f71db0dcec567bb7bda30689e48f5f8cc984e2cc8ad1198cf90", "class_name": "RelatedNodeInfo"}}, "text": "218 CHAPTER 10. SCHEDULING\n10.2.1 What is preemption?\nWithout preemption, processes will run until they are unable to utilize the CPU any further. For example the\nfollowing conditions would remove a process from the CPU and the CPU would be available to be scheduled for\nother processes. The process terminates due to a signal, is blocked waiting for concurrency primitive, or exits\nnormally . Thus once a process is scheduled it will continue even if another process with a high priority appears on\nthe ready queue.\nWith preemption, the existing processes may be removed immediately if a more preferred process is added\nto the ready queue. For example, suppose at t =0 with a Shortest Job First scheduler there are two processes\n(P1 P2) with 10 and 20 ms execution times. P1 is scheduled. P1 immediately creates a new process P3, with\nexecution time of 5 ms, which is added to the ready queue. Without preemption, P3 will run 10ms later (after P1\nhas completed). With preemption, P1 will be immediately evicted from the CPU and instead placed back in the\nready queue, and P3 will be executed instead by the CPU.\nAny scheduler that doesn\u2019t use some form of preemption can result in starvation because earlier processes may\nnever be scheduled to run (assigned a CPU). For example with SJF , longer jobs may never be scheduled if the\nsystem continues to have many short jobs to schedule. It all depends on the type of scheduler.\n10.2.2 Why might a process (or thread) be placed on the ready queue?\nA process is placed on the ready queue when it can use a CPU. Some examples include:\n\u2022A process was blocked waiting for a read from storage or socket to complete and data is now available.\n\u2022A new process has been created and is ready to start.\n\u2022A process thread was blocked on a synchronization primitive (condition variable, semaphore, mutex lock)\nbut is now able to continue.\n\u2022A process is blocked waiting for a system call to complete but a signal has been delivered and the signal\nhandler needs to run.\n10.3 Measures of Ef\ufb01ciency\nFirst some de\ufb01nitions\n1.start_time is the wall-clock start time of the process (CPU starts working on it)\n2.end_time is the end wall-clock of the process (CPU \ufb01nishes the process)\n3.run_time is the total amount of CPU time required\n4.arrival_time is the time the process enters the scheduler (CPU may start working on it)\nHere are measures of ef\ufb01ciency and their mathematical equations\n1.Turnaround Time is the total time from when the process arrives to when it ends. end_time - arrival_time\n2.Response Time is the total latency (time) that it takes from when the process arrives to when the CPU\nactually starts working on it. start_time - arrival_time", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2683, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d8e53a0d-2be6-4956-baee-f5c74efed7ac": {"__data__": {"id_": "d8e53a0d-2be6-4956-baee-f5c74efed7ac", "embedding": null, "metadata": {"page_label": "219", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d7b9d93c-ac45-4c8e-bd66-696ebfec0b95", "node_type": "4", "metadata": {"page_label": "219", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "1b43d9ad5c45865df2933f943b0fb0e479ee95a6d5ecca5494185fb53f7835fe", "class_name": "RelatedNodeInfo"}}, "text": "10.4. SCHEDULING ALGORITHMS 219\n3.Wait Time is the total wait time or the total time that a process is on the ready queue. A common mistake\nis to believe it is only the initial waiting time in the ready queue. If a CPU intensive process with no I /O\ntakes 7 minutes of CPU time to complete but required 9 minutes of wall-clock time to complete we can\nconclude that it was placed on the ready-queue for 2 minutes. For those 2 minutes, the process was ready\nto run but had no CPU assigned. It does not matter when the job was waiting, the wait time is 2 minutes.\nend_time - arrival_time - run_time\n10.3.1 Convoy Effect\nThe convoy effect is when a process takes up a lot of the CPU time, leaving all other processes with potentially\nsmaller resource needs following like a Convoy Behind them.\nSuppose the CPU is currently assigned to a CPU intensive task and there is a set of I /O intensive processes\nthat are in the ready queue. These processes require a tiny amount of CPU time but they are unable to proceed\nbecause they are waiting for the CPU-intensive task to be removed from the processor. These processes are starved\nuntil the CPU bound process releases the CPU. But, the CPU will rarely be released. For example, in the case of an\nFCFS scheduler, we must wait until the process is blocked due to an I /O request. The I /O intensive process can\nnow \ufb01nally satisfy their CPU needs, which they can do quickly because their CPU needs are small and the CPU is\nassigned back to the CPU-intensive process again. Thus the I /O performance of the whole system suffers through\nan indirect effect of starvation of CPU needs of all processes.\nThis effect is usually discussed in the context of FCFS scheduler; however, a Round Robin scheduler can also\nexhibit the Convoy Effect for long time-quanta.\n10.4 Scheduling Algorithms\nUnless otherwise stated\n1.Process 1: Runtime 1000ms\n2.Process 2: Runtime 2000ms\n3.Process 3: Runtime 3000ms\n4.Process 4: Runtime 4000ms\n5.Process 5: Runtime 5000ms", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1985, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c14c84d0-7db0-4319-98d0-c207622d0da9": {"__data__": {"id_": "c14c84d0-7db0-4319-98d0-c207622d0da9", "embedding": null, "metadata": {"page_label": "220", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0f3b430f-d94e-4094-8987-a82abc37cbef", "node_type": "4", "metadata": {"page_label": "220", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "999eedbdd685a8442e203167e4fb6630d1cdcdbf35d8242a025e4c0f4b12305a", "class_name": "RelatedNodeInfo"}}, "text": "220 CHAPTER 10. SCHEDULING\n10.4.1 Shortest Job First (SJF)\n12345\nProcess\nNumber\nTime (s)0Shortest Job First\n2 4 6 8 10 12 14 16\nFigure 10.1: Shortest job \ufb01rst scheduling\n\u2022P1 Arrival: 0ms\n\u2022P2 Arrival: 0ms\n\u2022P3 Arrival: 0ms\n\u2022P4 Arrival: 0ms\n\u2022P5 Arrival: 0ms\nThe processes all arrive at the start and the scheduler schedules the job with the shortest total CPU time. The\nglaring problem is that this scheduler needs to know how long this program will run over time before it ran the\nprogram.\nTechnical Note: A realistic SJF implementation would not use the total execution time of the process but the\nburst time or the number of CPU cycles needed to \ufb01nish a program. The expected burst time can be estimated by\nusing an exponentially decaying weighted rolling average based on the previous burst time [1, Chapter 6 ]. For\nthis exposition, we will simplify this discussion to use the total running time of the process as a proxy for the burst\ntime.\nAdvantages\n1.Shorter jobs tend to get run \ufb01rst\n2.On average wait times and response times are down\nDisadvantages\n1.Needs algorithm to be omniscient\n2.Need to estimate the burstiness of a process which is harder than let\u2019s say a computer network", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1188, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "542ad568-fb21-4d3f-9bef-0d4d1b9aa60e": {"__data__": {"id_": "542ad568-fb21-4d3f-9bef-0d4d1b9aa60e", "embedding": null, "metadata": {"page_label": "221", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c7900d1f-274a-424d-a9e7-9fa10579c4e5", "node_type": "4", "metadata": {"page_label": "221", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "635677fac13eeacbf68e693a66b6b3a39c4f8f6246ce24e012adf61927807d6b", "class_name": "RelatedNodeInfo"}}, "text": "10.4. SCHEDULING ALGORITHMS 221\n10.4.2 Preemptive Shortest Job First (PSJF)\nPreemptive shortest job \ufb01rst is like shortest job \ufb01rst but if a new job comes in with a shorter runtime than the\ntotal runtime of the current job, it is run instead. If it is equal like our example our algorithm can choose. The\nscheduler uses the total runtime of the process. If the scheduler wants to compare the shortest remaining time left,\nthat is a variant of PSJF called Shortest Remaining Time First (SRTF).\n12345\nProcess\nNumber\nTime (s)0Preemptive Shortest Job First\n2 4 6 8 10 12 14 16\nFigure 10.2: Preemptive Shortest Job First scheduling\n\u2022P2 at 0ms\n\u2022P1 at 1000ms\n\u2022P5 at 3000ms\n\u2022P4 at 4000ms\n\u2022P3 at 5000ms\nHere\u2019s what our algorithm does. It runs P2 because it is the only thing to run. Then P1 comes in at 1000ms, P2\nruns for 2000ms, so our scheduler preemptively stops P2, and let\u2019s P1 run all the way through. This is completely\nup to the algorithm because the times are equal. Then, P5 Comes in \u2013 since no processes running, the scheduler\nwill run process 5. P4 comes in, and since the runtimes are equal P5, the scheduler stops P5 and runs P4. Finally ,\nP3 comes in, preempts P4, and runs to completion. Then P4 runs, then P5 runs.\nAdvantages\n1.Ensures shorter jobs get run \ufb01rst\nDisadvantages\n1.Need to know the runtime again\n2.Context switching and jobs can get interrupted", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1365, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "34192754-6eec-4218-988b-e15051ab5a8b": {"__data__": {"id_": "34192754-6eec-4218-988b-e15051ab5a8b", "embedding": null, "metadata": {"page_label": "222", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b6564d06-a3d1-4a35-a6bf-bb075580aca3", "node_type": "4", "metadata": {"page_label": "222", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "5fc78165d1cac2a2dd85b8db3f61caa5cf72237b48e03324e06f03ac59fea40b", "class_name": "RelatedNodeInfo"}}, "text": "222 CHAPTER 10. SCHEDULING\n10.4.3 First Come First Served (FCFS)\n12345\nProcess\nNumber\nTime (s)0First Come First Served\n2 4 6 8 10 12 14 16\nFigure 10.3: First come \ufb01rst serve scheduling\n\u2022P2 at 0ms\n\u2022P1 at 1000ms\n\u2022P5 at 3000ms\n\u2022P4 at 4000ms\n\u2022P3 at 5000ms\nProcesses are scheduled in the order of arrival. One advantage of FCFS is that scheduling algorithm is simple\nThe ready queue is a FIFO (\ufb01rst in \ufb01rst out) queue. FCFS suffers from the Convoy effect. Here P2 Arrives, then P1\narrives, then P5, then P4, then P3. You can see the convoy effect for P5.\nAdvantages\n\u2022Simple algorithm and implementation\n\u2022Context switches infrequent when there are long-running processes\n\u2022No starvation if all processes are guaranteed to terminate\nDisadvantages\n\u2022Simple algorithm and implementation\n\u2022Context switches infrequent when there are long-running processes", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 842, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8ae2a5aa-8105-4498-9a26-f119ff9b1aae": {"__data__": {"id_": "8ae2a5aa-8105-4498-9a26-f119ff9b1aae", "embedding": null, "metadata": {"page_label": "223", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "883da25f-2f2f-4aeb-a855-b3aff3ce6e1a", "node_type": "4", "metadata": {"page_label": "223", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "2c3fdb8b61267f248268bc60b1777908d72de1675b579897e6ed409ce6ab981d", "class_name": "RelatedNodeInfo"}}, "text": "10.4. SCHEDULING ALGORITHMS 223\n10.4.4 Round Robin (RR)\nProcesses are scheduled in order of their arrival in the ready queue. After a small time step though, a running\nprocess will be forcibly removed from the running state and placed back on the ready queue. This ensures\nlong-running processes refrain from starving all other processes from running. The maximum amount of time that\na process can execute before being returned to the ready queue is called the time quanta. As the time quanta\napproaches to in\ufb01nity , Round Robin will be equivalent to FCFS.\n12345\nProcess\nNumber\nTime (s)0Round Robin\n2 4 6 8 10 12 14 16\nFigure 10.4: Round Robin Scheduling\n\u2022P1 Arrival: 0ms\n\u2022P2 Arrival: 0ms\n\u2022P3 Arrival: 0ms\n\u2022P4 Arrival: 0ms\n\u2022P5 Arrival: 0ms\nQuantum =1000ms\nHere all processes arrive at the same time. P1 is run for 1 quantum and is \ufb01nished. P2 for one quantum; then,\nit is stopped for P3. After all other processes run for a quantum we cycle back to P2 until all the processes are\n\ufb01nished.\nAdvantages\n1.Ensures some notion of fairness\nDisadvantages\n1.Large number of processes =Lots of switching", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1094, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c8a5c780-3a48-4184-a041-4bc15deaa02c": {"__data__": {"id_": "c8a5c780-3a48-4184-a041-4bc15deaa02c", "embedding": null, "metadata": {"page_label": "224", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ed99338a-8f5a-4e52-a126-b188170f8ac3", "node_type": "4", "metadata": {"page_label": "224", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "da47689ae430c7a173f0174a5aa8a4c9706a1cbef17648c85c819e2b59aafbd8", "class_name": "RelatedNodeInfo"}}, "text": "224 CHAPTER 10. SCHEDULING\n10.4.5 Priority\nProcesses are scheduled in the order of priority value. For example, a navigation process might be more important\nto execute than a logging process.\nIf you need a math-y way of comparing scheduling algorithms, please check out the appendix and the\nsection conceptually scheduling\n10.5 Topics\n\u2022Scheduling Algorithms\n\u2022Measures of Ef\ufb01ciency\n10.6 Questions\n\u2022What is scheduling?\n\u2022What is queueing? What are some different queueing methods?\n\u2022What is Turnaround Time? Response Time? Wait Time?\n\u2022What is the convoy effect?\n\u2022Which algorithms have the best turnaround /response /wait time on average?\n\u2022Do preemptive algorithms do better on average response time compared to non preemptive? How about\nturnaround /wait time?\nBibliography\n[1]A. Silberschatz, P .B. Galvin, and G. Gagne. Operating System Concepts . Wiley , 2005. ISBN 9780471694663.\nURL https://books.google.com/books?id=FH8fAQAAIAAJ .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 931, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b16f8589-3d0f-4b12-a9a1-e819eef355e8": {"__data__": {"id_": "b16f8589-3d0f-4b12-a9a1-e819eef355e8", "embedding": null, "metadata": {"page_label": "297", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d0c9644f-9363-4b47-b654-bab46ffe7129", "node_type": "4", "metadata": {"page_label": "297", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8bb05c6610137e1b01a33e7c8f85ffda247c1625c39bb9b305bcc1329acce45c", "class_name": "RelatedNodeInfo"}}, "text": "14\nSecurity\nHackers Are Like Artists, Who Wake Up In A Good Mood & Start\nPainting\nVladimir Putin\nComputer security is the protection of hardware and software from unauthorized access or modi\ufb01cation. Even\nif you don\u2019t work directly in the computer security \ufb01eld, the concepts are important to learn because all systems\nwill have attackers given enough time. Even though this is introduced as a different chapter, it is important to note\nthat most of these concepts and code examples have already been introduced at different points in the course. We\nwon\u2019t go in depth about all of the common ways of attack and defense nor will we go into how to perform all of\nthese attacks in an arbitrary system. Our goal is to introduce you to the \ufb01eld of making programs do what you\nwant to do.\n14.1 Security Terminology and Ethics\nThere is some terminology that needs to be explained to get someone who has little to no experience in computer\nsecurity up to speed\n1.AnAttacker is typically the user who is trying to break into the system. Breaking into the system means\nperforming an action that the developer of the system didn\u2019t intend. It could also mean accessing a system\nyou shouldn\u2019t have access to.\n2.ADefender is typically the user who is preventing the attacker from breaking into the system. This may be\nthe developer of the system.\n3.There are different types of attackers. There are white hat hackers who attempt to hack a defender with\ntheir consent. This is commonly a form of pre-emptive testing \u2013 in case a not-so-friendly attack comes along.\nTheblack hat hackers are hackers who hack without permission and the intent to use the information\nobtained for any purpose. Gray hat hacking differs because the hacker\u2019s intent is to inform the defender of\nthe vulnerability \u2013 though this can be hard to judge at times.\nDanger Will Robinson Before we let you go much further, it is important that we talk about ethics. Before\nyou skip over this section, know that your career quite literally can be terminated over an unethical decision\nthat you might make. The computer fraud and security act is a broad, and arguably terrible law, that casts any\n297", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2149, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eed845cf-d032-49ee-a4de-f14c5681ce4c": {"__data__": {"id_": "eed845cf-d032-49ee-a4de-f14c5681ce4c", "embedding": null, "metadata": {"page_label": "298", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "482a15e4-81de-4ad3-b20d-dc2c329b3546", "node_type": "4", "metadata": {"page_label": "298", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "32277b20febfe9e9b639bf2d4dcf9e96b6cf3fabeecead412e811cfeb15e7dd3", "class_name": "RelatedNodeInfo"}}, "text": "298 CHAPTER 14. SECURITY\nnon-authorized use of a \u2018protected computer\u2019 of a computer as a felony . Since most computers are involved in\nsome interstate /international commerce (the internet) most computers fall under this category . It is important to\nthink about your actions and have some ladder of accountability before executing any attack or defense. To be\nmore concrete, make sure supervisors in your organization have given you their blessing before trying to execute\nan attack.\nFirst if at all possible, get written permission from one of your superiors. We do realize that this is a cop-out\nand this puts the blame up a level, but at the risk of sounding cynical organizations will often put blame on an\nindividual employee to avoid damages TODO: Citation Needed . If not possible, try to go through the engineering\nsteps\n1.Figure out what the problem is that you are trying to solve. You can\u2019t solve a problem that you don\u2019t fully\nunderstand.\n2.Determine whetheryou need to \u201chack\u201d the system. A hack is de\ufb01ned generally as trying to use a system\nunintendedly . First, you should determine if your use is intended or unintended or somewhere in the middle\n\u2013 get a decision for them. If you can\u2019t get that, make a reasonable judgement as to what the intended use.\n3.Figure out a reasonable estimate of what the cost is to \u201chacking\u201d the system. Get that reasonable estimate\nchecked out with a few engineers so they can highlight things that you may have missed. Try to get someone\nto sign off on the plan.\n4.Execute the plan with caution. If at any point something seems wrong, weigh the risks and execute the plan.\nIf there isn\u2019t a certain ethical guideline for the current application, then create some. This is often called a\npolicy vacuum . This may seem like busy work and more on the \u201cbusiness side\u201d than computer scientists are\nused to, but your career is at stake here. It is up to you as a computing professional to assess the risk and to\ndecide whether to execute. Courts generally like sitting on precedent, but you can easily say that you aren\u2019t a\nlegal scholar. In lieu, you must be able to say that you reacted as a \u201creasonable\u201d engineer would react.\nTODO: Link to some case studies of real engineers having to decide\n14.1.1 CIA Triad\nThere are three commonly accepted goals to help understand if a system is secure.\n1.Information Con\ufb01dentiality means that only authorized parties are allowed to see a piece of information\n2.Information Integrity means that only authorized parties are allowed the modify a piece of information,\nregardless of whether they are allowed to see it. It ensures that information remains in complete during\ntransit.\n3.Information Availability means information, or a service, is available when it is needed.\n4.The triad above forms the Con\ufb01dentiality , Integrity , and Availability (CIA) triad, often authenticity is added\nas well.\nIf any of these are broken, the security of a system (either a service or piece of information) has been\ncompromised.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2995, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "86bdb7b6-e5e0-4e09-bc8a-1f2c145ed0db": {"__data__": {"id_": "86bdb7b6-e5e0-4e09-bc8a-1f2c145ed0db", "embedding": null, "metadata": {"page_label": "299", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "968764ab-bf07-4e25-869e-b2b523b82596", "node_type": "4", "metadata": {"page_label": "299", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "46552998095cf90222329099f31650d9727fc24c6332f5c0834b41b2c3266d1c", "class_name": "RelatedNodeInfo"}}, "text": "14.2. SECURITY IN C PROGRAMS 299\n14.2 Security in C Programs\n14.2.1 Stack Smashing\nConsider the following code snippet\nvoid greeting( const char *name) {\nchar buf[32] ;\nstrcpy(buf, name) ;\nprintf( \"Hello ,%s!\\n\", buf) ;\n}\nint main( int argc, char *argv[]) {\nif(argc <2){\nreturn 1;\n}\ngreeting(argv[1]) ;\nreturn 0;\n}\nThere is no checking on the bounds of strcpy! This means that we could potentially pass in a large string and\nget the program to do something unintended, usually via replacing the return address of the function with the\naddress of malicious code. Most strings will cause the program to exit with a segmentation fault\n$ ./a.out john\nHello, john!\n$ ./a.out JohnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...\nProgram received signal SIGSEGV, Segmentation fault.\n...\nIf we manipulate the bytes in certain ways and the program was compiled with the correct \ufb02ags, we can actually\nget access to a shell! Consider if that \ufb01le is owned by root, we put in some valid bytecode (binary instructions)\nas the string. What will happen is we\u2019ll try to execute execve(\u2019/bin/sh\u2019, \u2019/bin/sh\u2019, NULL , NULL) that is\ncompiled to the bytecode of the operating system and pass it as part of our string. With some luck, we will get\naccess to a root shell.\n$ ./a.out <payload >\nroot#", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1259, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "06087d79-6635-4ff4-8b00-95bb65ce74ab": {"__data__": {"id_": "06087d79-6635-4ff4-8b00-95bb65ce74ab", "embedding": null, "metadata": {"page_label": "300", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e8752142-6031-487d-9763-25029c1306c4", "node_type": "4", "metadata": {"page_label": "300", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "34e0888976643ac033955976d27d1b15098cc913a8af5245f051a9c89e4d9b21", "class_name": "RelatedNodeInfo"}}, "text": "300 CHAPTER 14. SECURITY\nThe question arises, which parts of the triad does this break? Try to answer that question yourself. So how\nwould we go about \ufb01xing this? We could ingrain into most programmers at the C level to use strncpy orstrlcpy\non OpenBSD systems. Turning on stack canaries as explained later will \ufb01x this issue as well.\n14.2.2 Buffer Over\ufb02ow\nMost of you are already familiar with Buffer Over\ufb02ows! A lot of time they are fairly tame, leading to simple\nprogram crashes or funny mistakes. Here is a complete example\n>cat main.c\n#include <stdio.h >\nint main() {\nchar out[10] ;\nchar in[10] ;\nfscanf(stdin, \"%s\", in) ;\nout[0] = \u2019a\u2019;\nout[9] = \u2019\\0\u2019;\nprintf( \"%s\\n\", out) ;\nreturn 0;\n}\n>gcc main.c -fno-stack-protector # need the special flag otherwise\nwon\u2019twork\n#Stack protectors are explained later .\n>./a.out\nhello\na\n>./a.out\nhellloooooooo\naoo\n>\nWhat happens here should be clear if you recall the c memory model. Out and in are both next to each other\nin memory . If you read in a string from standard input that over\ufb02ows in, then you end up printing aoo. It gets a\nlittle more serious if the snippet starts out as\nint main() {\nchar pass_hash[10] ;\nchar in[10] ;\nread_user_password(pass_hash, 10) ;\n//...\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1216, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b8986a40-b4ec-4895-8823-9cbfbc17b51f": {"__data__": {"id_": "b8986a40-b4ec-4895-8823-9cbfbc17b51f", "embedding": null, "metadata": {"page_label": "301", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "33789f51-26a7-4f00-a805-80a0e048d022", "node_type": "4", "metadata": {"page_label": "301", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "fdbc47f0d94c03505b53f9b3737c810c89f03037c4ced91ac6ee2f7fd0b05890", "class_name": "RelatedNodeInfo"}}, "text": "14.2. SECURITY IN C PROGRAMS 301\n14.2.3 Out of order instructions & Spectre\nOut of order execution is an amazing development that has been recently adopted by many hardware vendors\n(think 1990s) TODO: citation needed . Processors now instead of executing a sequence of instructions (let\u2019s say\nassigning a variable and then another variable) execute instructions before the current one is done [1, P . 45 ]. This\nis because modern processors spend a lot of time waiting for memory accesses and other I /O driven applications.\nThis means that a processor, while it is waiting for an operation to complete, will execute the next few operations.\nIf any of the operations would possibly alter the \ufb01nal result, there is a barrier, or if the re-ordering violates the\ndata dependencies of the instructions, the processor keep the instructions in the stated order [1, P . 296 ].\nNaturally , this allowed CPUs to become more energy-ef\ufb01cient while executing more instructions in real-time\nand increased security risks from complex architectures. What system programmers are worried about is that\noperation with mutex locks among threads are out of order \u2013 meaning that a pure software implementation of a\nmutex will fail without copious memory barriers. Therefore, the programmer has to acknowledge that updates\nmay be missed among a series of threads, given that there is no barrier, on modern processors.\nOne of the most prominent bugs concerning this is Spectre [2]. Spectre is a bug where instructions that\notherwise wouldn\u2019t be executed are speculatively executed due to out-of-order instruction execution. The following\nsnippet is a high-level proof of concept.\nchar *a[10] ;\nfor (int i = 10 ;i != 1 ;--i) {\na[i] = calloc(1, 1) ;\n}\na[0] = 0xCAFE ;\nint val;\nint j = 10 ;//This will beinaregister\nint i = 10 ;//This will beinmain memory\nfor (int i = 10 ;i != 0 ;--i, --j) {\nif(i) {\nval = *a[j] ;\n}\n}\nLet\u2019s analyze this code. The \ufb01rst loop allocates 9 elements through a valid malloc. The last element is 0xCAFE ,\nmeaning a dereference should result in a SEGFAULT . For the \ufb01rst 9 iterations, the branch is taken and valis\nassigned to a valid value. The interesting part happens in the last iteration. The resulting behavior of the program\nis to skip the last iteration. Therefore, valnever gets assigned to the last value.\nBut under the right compilation conditions and compiler \ufb02ags, the instructions will be speculatively executed.\nThe processor thinks that the branch will be taken, since it has been taken in the last 9 iterations. As such, the\nprocessor will fetch those instructions. Due to out-of-order instruction execution, while the value of iis being\nfetched from memory , we have to force it not to be in a register. Then, the processor will try to dereference that\naddress. This should result in a SEGFAULT . Since the address was never logically reached by the program, the\nresult is discarded.\nNow here is the trick. Even though the value of the calculation would have resulted in a SEGFAULT , the bug\ndoesn\u2019t clear the cache that refers to the physical memory where 0xCAFE is located. This is an inexact explanation,", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3125, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d9c62ba4-b423-49ca-bda9-e273e4ec3fce": {"__data__": {"id_": "d9c62ba4-b423-49ca-bda9-e273e4ec3fce", "embedding": null, "metadata": {"page_label": "302", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "844d4de6-5546-48a4-8e19-52ff5f53db1f", "node_type": "4", "metadata": {"page_label": "302", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e60675633c6fc930389d167928048bfa4635a6783ecd6624610d6f1f696c46a7", "class_name": "RelatedNodeInfo"}}, "text": "302 CHAPTER 14. SECURITY\nbut essentially how it works. Since it is still in the cache, if you again trick the processor to read form the cache\nusing valthen you will read a memory value that you wouldn\u2019t be able to read normally . This could include\nimportant information such as passwords, payment information, etc.\n14.2.4 Operating Systems Security\n1.Permissions. In POSIX systems, we have permissions everywhere. There are directories that you can and\ncan\u2019t access, \ufb01les that you can and can\u2019t access. Each user account is given access to each \ufb01le and directory\nthrough the read-write-execute (RWX) bits. The user gets matched with either the owner, the group, or\n\u2018everyone else\u2019, and their access to the \ufb01le is limited using these bits. Note that permissions work slightly\ndifferently on directories compared to \ufb01les.\n2.Capabilities. In addition to permissions on \ufb01les, each user has a certain set of permissions that they can do.\nFor a full list, you can check capabilities(7). In short, allowing a capability allows a user to perform a set of\nactions. Some examples include controlling networking devices, creating special \ufb01les, and peering into IPC\nor interprocess communication.\n3.Address Space Layout Randomization (ASLR). ASLR causes the address spaces of important sections of\na process, including the base address of the executable and the positions of the stack, heap and libraries,\nto start at randomized values, on every run. This is so that an attacker with a running executable has to\nrandomly guess where sensitive information could be hidden. For example, an attacker may use this to\neasily perform a return-to-libc attack.\n4.Stack Protectors. Let\u2019s say you\u2019ve programmed a buffer over\ufb02ow as above. In most cases, what happens?\nUnless speci\ufb01cally turned off, the compiler will put in stack protectors or stack canaries. This is a value\nthat resides in the stack and must remain constant for the duration of the function call. If that protector is\noverwritten at the end of the function call, the run time will abort and report to the user that stack smashing\nwas detected.\n5.Write xor Execute, also known as Data Execution Prevention (DEP). This is a protection that was\ncovered in the IPC section that distinguishes code from data. A page can either be written to or executed\nbut not both. This is to prevent buffer over\ufb02ows where attackers write arbitrary code, often stored on the\nstack or heap, and execute with the user\u2019s permissions.\n6.Firewall. The Linux kernel provides the net\ufb01lter module as a way of deciding whetheran incoming connection\nshould be allowed and various other restrictions on connections. This can help with a DDOS attack (explained\nlater).\n7.AppArmor. AppArmor is a suite of operating system tools at the userspace level to restrict applications to\ncertain operations.\nOpenBSD is an arguably better system for security . It has many security oriented features. Some of these\nfeatures have been touched upon earlier. An exhaustive list of features is at https://www.openbsd.org/\ninnovations.html\n1.pledge. Pledge is a powerful command that restricts system calls. This means if you have a simple program\nlikecatwhich only reads to and from \ufb01les, one can reasonably restrict all network access, pipe access,\nand write access to \ufb01les. This is known as the process of \u201chardening\u201d an executable or system, giving the\nsmallest amount of permissions to the least number of executables needed to run a system. Pledge is also\nuseful in case one tries to perform an injection attack.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3518, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5e19f9dd-f373-42e3-85ce-1db4a235fac6": {"__data__": {"id_": "5e19f9dd-f373-42e3-85ce-1db4a235fac6", "embedding": null, "metadata": {"page_label": "303", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f7181f86-4f43-4e3c-bd98-fac5bd944c09", "node_type": "4", "metadata": {"page_label": "303", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f1429ce3a1f2847b46ab21069b1d1cb95002e339c48e32e192d85587fcca400d", "class_name": "RelatedNodeInfo"}}, "text": "14.2. SECURITY IN C PROGRAMS 303\n2.unveil. Unveil is a system call that restricts the access of a current program to a few directories. Those\npermissions apply to all forked programs as well. This means if you have a suspicious executable that you\nwant to run whose description is \u201ccreates a new \ufb01le and outputs random words\u201d one could use this call to\nrestrict access to a safe subdirectory and watch it receive the SIGKILL signal if it tries to access system \ufb01les\nin the root directory , for example. This could be useful for your program as well. If you want to ensure\nthat no user data is lost during an update (which is what happened with a Steam system update), then the\nsystem could only reveal the program\u2019s installation directory . If an attacker manages to \ufb01nd an exploit in\nthe executable, it can only compromise the installation directory .\n3.sudo. Sudo is an openBSD project that runs everywhere! Before to run commands as root, one would have\nto drop to a root shell. Some times that would also mean giving users scary system capabilities. Sudo gives\nyou access to perform commands as root for one-offs without giving a long list of capabilities to all of your\nusers.\n14.2.5 Virtualization Security\nVirtualization is the act of creating a virtual version of an environment for a program to run on. Though that\nde\ufb01nition might be bent a little with the advent of new-age bare metal Virtual Machines, the abstraction is still there.\nOne can imagine a single Operating System per motherboard. Virtualization in the software sense is providing\n\u201cvirtual\u201d motherboard features like USB ports or monitors that another program (the bridge) communicates with\nthe actual hardware to perform a task. A simple example is running a virtual machine on your host desktop!\nOne can spin up an entirely different operating system whose instructions are fed through another program and\nexecuted on the host system. There are many forms of virtualization that we use today . We will discuss two\npopular forms below. One form is virtual machines. These programs emulate allforms of motherboard peripherals\nto create a full machine. Another form is containers. Virtual machines are good but are often bulky and programs\nonly need a certain level of protection. Containers are virtual machines that don\u2019t emulate all motherboard\nperipherals and instead share with the host operating system, adding in additional layers of security .\nNow, you can\u2019t have proper virtualization without security . One of the reasons to have virtualization is to ensure\nthat the virtualized environment doesn\u2019t maliciously leak back into the host environment. We say maliciously\nbecause there are intended ways of communication that we want to keep in check. Here are some simple examples\nof security provided through virtualization\n1.chroot is a contrived way of creating a virtualization environment. chroot is short for change root. This\nchanges where a program believes that ( /) is mounted on the system. For example with chroot, one can\nmake a hello world program believe /home/user/ is actually the root directory . This is useful because no\nother \ufb01les are exposed. This is contrived because Linux still needs additional tools (think the c standard\nlibrary) to come from different directories such as /usr/lib which means those could still be vulnerable.\n2.namespaces are Linux\u2019s better way to create a virtualization environment. We won\u2019t go into this too much,\njust know that they exist.\n3.Hardware virtualization technology . Hardware vendors have become increasingly aware that physical\nprotections are needed when emulating instructions. As such, there can be switches enabled by the user\nthat allows the operating system to \ufb02ip into a virtualization mode where instructions are run as normal but\nare monitored for malicious activity . This helps the performance and increases the security of virtualized\nenvironments.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3900, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2026d110-fc39-43d3-a7c6-31a526f56ed1": {"__data__": {"id_": "2026d110-fc39-43d3-a7c6-31a526f56ed1", "embedding": null, "metadata": {"page_label": "304", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cfc6e13c-a2bd-4544-9f3e-962289387ad9", "node_type": "4", "metadata": {"page_label": "304", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "518f9d342f30d1bc3498ffbdd766208ee89a5f0760203945368a98593c97088a", "class_name": "RelatedNodeInfo"}}, "text": "304 CHAPTER 14. SECURITY\n14.3 Cyber Security\nCyber Security is arguably the most popular area of security . More and more of our systems are hacked over the\nweb, it is important to understand how we can protect against these attacks\n14.3.1 Security at the TCP Level\n1.Encryption. TCP is unencrypted! This means any data that is sent over a TCP connection is in plain text. If\none needs to send encrypted data, one needs to use a higher level protocol such as HTTPs or develop their\nown.\n2.Identity Veri\ufb01cation. In TCP , there is no way to verify the identity of who the program is connecting to.\nThere are no checks or federated databases in place. One just has to trust the DNS server gave a reasonable\nresponse which is almost always the incorrect answer. Apart from systems that have an approved white list\nor a \u201csecret\u201d connection protocol, there is little at the TCP level that one can do to stop.\n3.Syn-Ack Sequence Number. This is a security improvement. TCP features what we call sequence numbers.\nThat means that during the SYN-SYN /ACK-ACK dance, a connection starts at a random integer. This is\nimportant because if an attacker is trying to spoof packets (pretend those packets are coming from your\nprogram) that means that the attacker must either correctly guess \u2013 which is hard \u2013 or be in the route that\nyour packet takes to the destination \u2013 much more likely . ISPs help out with the destination problem because\nit may send a connection through varying routers which makes it hard for an attacker to sit anywhere and\nbe sure that they will receive your packets \u2013 this is why security experts usually advise against using coffee\nshop wi\ufb01 for sensitive tasks.\n4.Syn-Flood. Before the \ufb01rst synchronization packet is acknowledged, there is no connection. That means a\nmalicious attacker can write a bad TCP implementation that sends out a \ufb02ood of SYN packets to a hapless\nserver. The SYN \ufb02ood is easily mitigated by using IPTABLES or another net\ufb01lter module to drop all incoming\nconnections from an IP address after a certain volume of traf\ufb01c is reached for a certain period.\n5.Denial of Service, Distributed Denial of Service is the hardest form of attack to stop. Companies today are\nstill trying to \ufb01nd good ways to ease these attacks. This involves sending all sorts of network traf\ufb01c forward\nto servers in the hopes that the traf\ufb01c will clog them up and slow down the servers. In big systems, this can\nlead to cascading failures. If a system is engineered poorly , one server\u2019s failure causes all the other servers\nto pick up more work which increases the probability that they will fail and so on and so forth.\n14.3.2 Security at the DNS Level\nAs of 2019, the United States Department of Homeland Security released a directive to switch all services from\nDNS to DNSSec https://cyber.dhs.gov/assets/report/ed-19-01.pdf . This directive is an inherent \ufb02aw\nof the DNS system. First, DNS doesn\u2019t offer any sort of veri\ufb01cation on domain name requests. That is, it is easy to\nspoof DNS nameservers such that they point your browser to potentially malicious servers. Remember that DNS\nrequests are sent as unsecured UDP packets, which are prone to tampering. This means that if an attacker snags a\nplain-text request for a DNS server, that attacker can now send the result back to the requester. More commonly\ninstead of just attacking one person, they will connect to a public wi\ufb01 station and poison the cache of the router \u2013\nmeaning that all who are connected will get a bad IP address when requesting a domain name. This can get into\nserious spoo\ufb01ng attacks if one tries to pretend they are a major bank.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3617, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8aa9936d-b92c-4621-ba4d-a03ceb189c54": {"__data__": {"id_": "8aa9936d-b92c-4621-ba4d-a03ceb189c54", "embedding": null, "metadata": {"page_label": "305", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ad738fc2-314f-4daf-8323-49459a457289", "node_type": "4", "metadata": {"page_label": "305", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "69f81427e09ffb4816226f63bc1107ae6775a10dd637da75f05c04dad7af9f53", "class_name": "RelatedNodeInfo"}}, "text": "14.4. TOPICS 305\n14.4 Topics\n1.Security Terminology\n2.Security in local C programs\n3.Security in CyberSpace\n14.5 Review\n1.What is a chmod statement to break only the con\ufb01dentiality of your data?\n2.What is a chmod statement to break only the con\ufb01dentiality and availability of your data?\n3.An attacker gains root access on a Linux system that you use to store private information. Does this affect\ncon\ufb01dentiality , integrity , or availability of your information, or all three?\n4.Hackers brute force your git username and password. Who is affected?\n5.Why is privilege separation useful in RPC applications?\n6.Is it easier to forge a UDP or TCP packet and why?\n7.Why are TCP sequence numbers initialized to a random number?\n8.What is the impact if the RAM used to hold a shared library (e.g. the C standard library) was writable by\nany process?\n9.Is creating and implementing client-server protocols that are secure and invulnerable to malicious attackers\neasy?\n10.Which is harder to defend against: Syn-Flooding or Distributed Denial of Service?\n11.Does deadlock affect the availability of a service?\n12.Do buffer over\ufb02ows /under\ufb02ows affect the integrity of a data?\n13.Why shouldn\u2019t stack memory be executable.\n14.HeartBleed is an example of what kind of security issue? Which one(s) of the triad does it break?\n15.Meltdown and Spectre is an example of what kind of security issue? Which one(s) of the triad does it break?\nBibliography\n[1]Part Guide. Intel\u00ae 64 and ia-32 architectures software developers manual. Volume 3B: System programming\nGuide, Part , 2, 2011.\n[2]Paul Kocher, Daniel Genkin, Daniel Gruss, Werner Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas\nPrescher, Michael Schwarz, and Yuval Yarom. Spectre attacks: Exploiting speculative execution. arXiv preprint\narXiv:1801.01203 , 2018.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1807, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bbda6786-2b92-43aa-b7fd-0be8905a1359": {"__data__": {"id_": "bbda6786-2b92-43aa-b7fd-0be8905a1359", "embedding": null, "metadata": {"page_label": "285", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "155b8336-3c6a-4660-9090-eca9d4950100", "node_type": "4", "metadata": {"page_label": "285", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "95edfd747696ca2262e5967bbab956f1de048efcbb4229bbc1273e4038f0699f", "class_name": "RelatedNodeInfo"}}, "text": "13\nSignals\nThat\u2019s a signal, Jerry , that\u2019s a signal! [snaps his \ufb01ngers again ]Signal!\nGeorge Costanza (Seinfeld)\nSignals are a convenient way to deliver low-priority information and for users to interact with their programs\nwhen other ways don\u2019t work (for example standard input being frozen). They allow a program to clean up or\nperform an action in the case of an event. Sometimes, a program can choose to ignore events which is supported.\nCrafting a program that uses signals well is tricky due to how signals are handled. As such, signals are usually for\ntermination and clean up. Rarely are they supposed to be used in programming logic.\nFor those of you with an architecture background, the interrupts used here aren\u2019t the interrupts generated by\nthe hardware. Those interrupts are almost always handled by the kernel because they require higher levels of\nprivileges. Instead, we are talking about software interrupts that are generated by the kernel \u2013 though they can\nbe in response to a hardware event like SIGSEGV .\nThis chapter will go over how to read information from a process that has either exited or been signaled. Then,\nit will deep dive into what are signals, how does the kernel deal with a signal, and the various ways processes can\nhandle signals both with and without threads.\n13.1 The Deep Dive of Signals\nA signal allows one process to asynchronously send an event or message to another process. If that process wants\nto accept the signal, it can, and then, for most signals, decide what to do with that signal.\nFirst, a bit of terminology . A signal disposition is a per-process attribute that determines how a signal is\nhandled after it is delivered . Think of it as a table of signal-action pairs. The full discussion is in the Man Page.\nThe actions are\n1.TERM , terminates the process\n2.IGN, ignore\n3.CORE , generate a core dump\n4.STOP , stops a process\n5.CONT , continues a process\n285", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1914, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d844cb05-3997-4129-9101-1c5f5deb561c": {"__data__": {"id_": "d844cb05-3997-4129-9101-1c5f5deb561c", "embedding": null, "metadata": {"page_label": "286", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a1a3ba85-82a9-438d-b0f0-575d72eb6a60", "node_type": "4", "metadata": {"page_label": "286", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "313cf535692b3b0c99207e75c6d2ba66eb278781869e09cd7745be99024336db", "class_name": "RelatedNodeInfo"}}, "text": "286 CHAPTER 13. SIGNALS\n6.Execute a custom function.\nA signal mask determines whether a particular signal is delivered or not. The overall process for how a kernel\nsends a signal are below.\n1.If no signals have arrived, the process can install its own signal handlers. This tells the kernel that when the\nprocess gets signal X that it should jump to function Y.\n2.A signal that is created is in a \"generated\" state.\n3.The time between when a signal is generated and the kernel can apply the mask rules is called the pending\nstate.\n4.Then the kernel then checks the process\u2019 signal mask. If the mask says all the threads in a process are\nblocking the signal, then the signal is currently blocked and nothing happens until a thread unblocks it.\n5.If a single thread can accept the signal, then the kernel executes the action in the disposition table. If the\naction is a default action, then no threads need to be paused.\n6.Otherwise, the kernel delivers the signal by stopping whatever a particular thread is doing currently , and\njumps that thread to the signal handler. The signal is now in the delivered phase. More signals can be\ngenerated now, but they can\u2019t be delivered until the signal handler is complete which is when the delivered\nphase is over.\n7.Finally , we consider a signal caught if the process remains intact after the signal was delivered.\nAs a \ufb02owchart\nBlockedGenerated Pending Delivered Caught\nKilled\nFigure 13.1: Signal lifecycle diagram\nHere are some common signals that you will see thrown around.\nOne of our favorite anecdotes is to never use kill -9 for a host of reasons. The following is an excerpt from\nUseless Use of Kill -9 Link to archive\nNo no no. Don\u2019t use kill -9.\nIt doesn\u2019t give the process a chance to cleanly:\n1) shut down socket connections\n2) clean up temp \ufb01les\n3) inform its children that it is going away\n4) reset its terminal characteristics\nand so on and so on and so on.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1914, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "18aed881-87d5-4444-9de9-c759a8fabaec": {"__data__": {"id_": "18aed881-87d5-4444-9de9-c759a8fabaec", "embedding": null, "metadata": {"page_label": "287", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cfd75abe-704e-449a-a0e8-6b029a54bb2a", "node_type": "4", "metadata": {"page_label": "287", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7960308b8e51e523b0de4dd141c00811062640bac493c305bb21728305a8bcb7", "class_name": "RelatedNodeInfo"}}, "text": "13.2. SENDING SIGNALS 287\nTable 13.1: POSIX Signals\nName Portable Number Default Action\nUsual Use\nSIGINT 2 Terminate (Can be caught)\nStop a process nicely\nSIGQUIT 3 Terminate (Can be caught)\nStop a process harshly\nSIGTERM 15 Terminate Process\nStop a process even more harshly\nSIGSTOP N/A Stop Process (Cannot be caught)\nSuspends a process\nSIGCONT N/A Continues a process\nStarts after a stop\nSIGKILL 9 Terminate Process (Cannot be caught)\nYou want the process gone\nGenerally , send 15, and wait a second or two, and if that doesn\u2019t work, send 2, and if that doesn\u2019t\nwork, send 1. If that doesn\u2019t, REMOVE THE BINARY because the program is badly behaved!\nDon\u2019t use kill -9. Don\u2019t bring out the combine harvester just to tidy up the \ufb02ower pot.\nWe still keep kill -9 in there for extreme scenarios where the process needs to be gone.\n13.2 Sending Signals\nSignals can be generated in multiple ways.\n1.The user can send a signal. For example, you are at the terminal, and you press CTRL-C . One can also use\nthe built-in kill to send any signal.\n2.The system can send an event. For example, if a process accesses a page that it isn\u2019t supposed to, the\nhardware generates an interrupt which gets intercepted by the kernel. The kernel \ufb01nds the process that\ncaused this and sends a software interrupt signal SIGSEGV . There are other kernel events like a child being\ncreated or a process needs to be resumed.\n3.Finally , another process can send a message. This could be used in low-stakes communication of events\nbetween processes. If you are relying on signals to be the driver in your program, you should rethink your\napplication design. There are many drawbacks to using POSIX /Real-Time signals for asynchronous commu-\nnication. The best way to handle interprocess communication is to use, well, interprocess communication\nmethods speci\ufb01cally designed for your task at hand.\nYou or another process can temporarily pause a running process by sending it a SIGSTOP signal. If it succeeds,\nit will freeze a process. The process will not be allocated any more CPU time. To allow a process to resume\nexecution, send it the SIGCONT signal. For example, the following is a program that slowly prints a dot every\nsecond, up to 59 dots.\n#include <unistd.h >\n#include <stdio.h >\nint main() {", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2274, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f0b38288-8c9d-49c1-9cce-c44bd2d53ab7": {"__data__": {"id_": "f0b38288-8c9d-49c1-9cce-c44bd2d53ab7", "embedding": null, "metadata": {"page_label": "288", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "46c8b4e6-3700-44b5-a09f-c2a27d74c433", "node_type": "4", "metadata": {"page_label": "288", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "5cd8cefcc0cf8d2cc1c557240913b539853a99d36a69d225a4f452270c81417c", "class_name": "RelatedNodeInfo"}}, "text": "288 CHAPTER 13. SIGNALS\nprintf( \"Mypid is%d\\n\", getpid() ) ;\nint i = 60 ;\nwhile (--i) {\nwrite(1, \".\",1);\nsleep(1) ;\n}\nwrite(1, \"Done !\",5);\nreturn 0;\n}\nWe will \ufb01rst start the process in the background (notice the & at the end). Then, send it a signal from the shell\nprocess by using the kill command.\n$ ./program &\nMy pid is 403\n...\n$kill -SIGSTOP 403\n$kill -SIGCONT 403\n...\nIn C, a program can send a signal to the child using kill POSIX call,\nkill(child, SIGUSR1) ;//Send auser -defined signal\nkill(child, SIGSTOP) ;//Stop the child process (the child cannot\nprevent this )\nkill(child, SIGTERM) ;//Terminate the child process (the child can\nprevent this )\nkill(child, SIGINT) ;//The equivalent toCTRL -C(bydefault closes the\nprocess )\nAs we saw above there is also a kill command available in the shell. Another command killall works the\nexact same way but instead of looking up by PID, it tries to match the name of the process. psis an important\nutility that can help you \ufb01nd the pid of a process.\n#First let\u2019suse psand grep tofind the process wewant tosend a\nsignal to\n$psau | grep myprogram\nangrave 4409 0.0 0.0 2434892 512 s004 R+ 2:42PM 0:00.00\nmyprogram 1 2 3\n#Send SIGINT signal toprocess 4409 (The equivalent of\u2018CTRL -C\u2018)\n$kill -SIGINT 4409", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1251, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cfd4409f-967c-4c6b-8c44-f87b5bdb6b3e": {"__data__": {"id_": "cfd4409f-967c-4c6b-8c44-f87b5bdb6b3e", "embedding": null, "metadata": {"page_label": "289", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e769ceca-6dde-4184-a601-83a332f11aa5", "node_type": "4", "metadata": {"page_label": "289", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ba8dcf0a66feec66c490947b932494958cb5639e08b8e5159e5555c524218649", "class_name": "RelatedNodeInfo"}}, "text": "13.3. HANDLING SIGNALS 289\n#Send SIGKILL (terminate the process )\n$kill -SIGKILL 4409\n$kill -9 4409\n#Use kill all instead tokill aprocess byexecutable name\n$ killall -l firefox\nTo send a signal to the running process, use raise orkill with getpid() .\nraise( int sig) ;//Send asignal tomyself !\nkill(getpid(), int sig) ;//Same asabove\nFor non-root processes, signals can only be sent to processes of the same user. You can\u2019t SIGKILL any process!\nman -s2 kill for more details.\n13.3 Handling Signals\nThere are strict limitations on the executable code inside a signal handler. Most library and system calls are\nasync-signal-unsafe , meaning they may not be used inside a signal handler because they are not re-entrant.\nRe-entrant safety means that your function can be frozen at any point and executed again, can you guarantee that\nyour function wouldn\u2019t fail? Let\u2019s take the following\nint func( const char *str) {\nstatic char buffer[200] ;\nstrncpy(buffer, str, 199) ;\n# Here is where we get paused\nprintf( \"%s\\n\", buffer)\n}\n1.We execute (func(\"Hello\"))\n2.The string gets copied over to the buffer completely (strcmp(buffer, \"Hello\") ==0)\n3.A signal is delivered and the function state freezes, we also stop accepting any new signals until after the\nhandler (we do this for convenience)\n4.We execute func(\"World\")\n5.Now (strcmp(buffer, \"World\") ==0) and the buffer is printed out \"World\".\n6.We resume the interrupted function and now print out the buffer once again \"World\" instead of what the\nfunction call originally intended \"Hello\"", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1533, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c92e77e-10d3-4f09-a2c6-c64ac9980110": {"__data__": {"id_": "0c92e77e-10d3-4f09-a2c6-c64ac9980110", "embedding": null, "metadata": {"page_label": "290", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c5cf832c-8969-4bd0-b5a7-e8298744b247", "node_type": "4", "metadata": {"page_label": "290", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "315cbd13c0a5fe66bba7ad6221013c84041aea1f0d5915234779166758d6d231", "class_name": "RelatedNodeInfo"}}, "text": "290 CHAPTER 13. SIGNALS\nGuaranteeing that your functions are signal handler safe can\u2019t be solved by removing shared buffers. You\nmust also think about multithreading and synchronization \u2013 what happens when I double lock a mutex? You\nalso have to make sure that each function call is reentrant safe. Suppose your original program was interrupted\nwhile executing the library code of malloc . The memory structures used by malloc will be inconsistent. Calling\nprintf , which uses malloc as part of the signal handler, is unsafe and will result in unde\ufb01ned behavior . A safe\nway to avoid this behavior is to set a variable and let the program resume operating. The design pattern also\nhelps us in designing programs that can receive signals twice and operate correctly .\nint pleaseStop ;//See notes onwhy \"volatile sig_atomic_t \"isbetter\nvoid handle_sigint( int signal) {\npleaseStop = 1 ;\n}\nint main() {\nsignal(SIGINT, handle_sigint) ;\npleaseStop = 0 ;\nwhile (!pleaseStop) {\n/*application logic here */\n}\n/*clean upcode here */\n}\nThe above code might appear to be correct on paper. However, we need to provide a hint to the compiler\nand the CPU core that will execute the main() loop. We need to prevent compiler optimization. The expression\npleaseStop doesn\u2019t get changed in the body of the loop, so some compilers will optimize it to true TODO:\ncitation needed . Secondly , we need to ensure that the value of pleaseStop is uncached using a CPU register and\ninstead always read from and written to main memory . The sig_atomic_t type implies that all the bits of the\nvariable can be read or modi\ufb01ed as an atomic operation - a single uninterruptible operation. It is impossible to\nread a value that is composed of some new bit values and old bit values.\nBy specifying pleaseStop with the correct type volatile sig_atomic_t , we can write portable code where\nthe main loop will be exited after the signal handler returns. The sig_atomic_t type can be as large as an int\non most modern platforms but on embedded systems can be as small as a char and only able to represent (-127\nto 127) values.\nvolatile sig_atomic_t pleaseStop ;\nTwo examples of this pattern can be found in COMP a terminal based 1Hz 4bit computer [3]. Two boolean\n\ufb02ags are used. One to mark the delivery of SIGINT (CTRL-C), and gracefully shutdown the program, and the\nother to mark SIGWINCH signal to detect terminal resize and redraw the entire display .\nYou can also choose a handle pending signals asynchronously or synchronously . To install a signal handler\nto asynchronously handle signals, use sigaction . To synchronously catch a pending signal use sigwait which\nblocks until a signal is delivered or signalfd which also blocks and provides a \ufb01le descriptor that can be read()\nto retrieve pending signals.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2777, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7f812be7-2960-4b6f-a4b6-1288ff41cc31": {"__data__": {"id_": "7f812be7-2960-4b6f-a4b6-1288ff41cc31", "embedding": null, "metadata": {"page_label": "291", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3261e187-a18b-4de0-abc0-e4106d8b878c", "node_type": "4", "metadata": {"page_label": "291", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c70a44204e6a54bd4b95d51bcd5b81224289c4698bd72f7d1680b6d8c61a5e60", "class_name": "RelatedNodeInfo"}}, "text": "13.3. HANDLING SIGNALS 291\n13.3.1 Sigaction\nYou should use sigaction instead of signal because it has better de\ufb01ned semantics. signal on different\noperating system does different things which is bad.sigaction is more portable and is better de\ufb01ned for threads.\nYou can use system call sigaction to set the current handler and disposition for a signal or read the current\nsignal handler for a particular signal.\nint sigaction( int signum, const struct sigaction *act, struct sigaction\n*oldact) ;\nThe sigaction struct includes two callback functions (we will only look at the \u2018handler\u2019 version), a signal mask\nand a \ufb02ags \ufb01eld -\nstruct sigaction {\nvoid (*sa_handler)( int);\nvoid (*sa_sigaction)( int, siginfo_t *, void *);\nsigset_t sa_mask ;\nint sa_flags ;\n};\nSuppose you stumble upon legacy code that uses signal . The following snippet installs myhandler as the\nSIGALRM handler.\nsignal(SIGALRM, myhandler) ;\nThe equivalent sigaction code is:\nstruct sigaction sa ;\nsa.sa_handler = myhandler ;\nsigemptyset(&sa.sa_mask) ;\nsa.sa_flags = 0 ;\nsigaction(SIGALRM, &sa, NULL)\nHowever, we typically may also set the mask and the \ufb02ags \ufb01eld. The mask is a temporary signal mask used\nduring the signal handler execution. If the thread serving the signal is interrupted in the middle of a system call,\ntheSA_RESTART \ufb02ag will automatically restart some system calls that otherwise would have returned early with\nEINTR error. The latter means we can simplify the rest of code somewhat because a restart loop may no longer be\nrequired.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1516, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "65a9e312-cd94-4593-942a-713abbca55c8": {"__data__": {"id_": "65a9e312-cd94-4593-942a-713abbca55c8", "embedding": null, "metadata": {"page_label": "292", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "889978af-4efc-4ae5-ac49-3aca7427c233", "node_type": "4", "metadata": {"page_label": "292", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e0f5bf598a36228cf90462775ce84e9c28b2163dfc0954f1064949da96d9a66e", "class_name": "RelatedNodeInfo"}}, "text": "292 CHAPTER 13. SIGNALS\nsigfillset(&sa.sa_mask) ;\nsa.sa_flags = SA_RESTART ;/*Restart functions ifinterrupted by\nhandler */\nIt is often better to have your code check for the error and restart itself due to the selective nature of the \ufb02ag.\n13.4 Blocking Signals\nTo block signals use sigprocmask ! With sigprocmask you can set the new mask, add new signals to be blocked to\nthe process mask, and unblock currently blocked signals. You can also determine the existing mask (and use it for\nlater) by passing in a non-null value for oldset.\nint sigprocmask( int how, const sigset_t *set, sigset_t *oldset) ;\nFrom the Linux man page of sigprocmask, here are the possible values for howTODO: cite .\n\u2022SIG_BLOCK . The set of blocked signals is the union of the current set and the set argument.\n\u2022SIG_UNBLOCK . The signals in set are removed from the current set of blocked signals. It is permissible to\nattempt to unblock a signal which is not blocked.\n\u2022SIG_SETMASK . The set of blocked signals is set to the argument set.\nThe sigset type behaves as a set. It is a common error to forget to initialize the signal set before adding to the\nset.\nsigset_t set, oldset ;\nsigaddset(&set, SIGINT) ;//Ooops !\nsigprocmask(SIG_SETMASK, &set, &oldset)\nCorrect code initializes the set to be all on or all off. For example,\nsigfillset(&set) ;//all signals\nsigprocmask(SIG_SETMASK, &set, NULL) ;//Block all the signals which\ncan beblocked\nsigemptyset(&set) ;//nosignals\nsigprocmask(SIG_SETMASK, &set, NULL) ;//set the mask tobeempty again\nIf you block a signal with either sigprocmask orpthread_sigmask , then the handler registered with\nsigaction is not delivered unless explicitly sigwait\u2019ed onTODO: cite .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1687, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b86abe7e-e9a9-4dd2-a3d0-4cac5540a238": {"__data__": {"id_": "b86abe7e-e9a9-4dd2-a3d0-4cac5540a238", "embedding": null, "metadata": {"page_label": "293", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f5b9a272-52f0-46e9-82a7-fc9a7bac64f6", "node_type": "4", "metadata": {"page_label": "293", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "79fe971c32ced315bc48eadb2152d7ee3bacad24ed852ad5a02f1ec7afa20ecc", "class_name": "RelatedNodeInfo"}}, "text": "13.4. BLOCKING SIGNALS 293\n13.4.1 Sigwait\nSigwait can be used to read one pending signal at a time. sigwait is used to synchronously wait for signals,\nrather than handle them in a callback. A typical use of sigwait in a multi-threaded program is shown below. Notice\nthat the thread signal mask is set \ufb01rst (and will be inherited by new threads). The mask prevents signals from\nbeing delivered so they will remain in a pending state until sigwait is called. Also notice the same set sigset_t\nvariable is used by sigwait - except rather than setting the set of blocked signals it is used as the set of signals that\nsigwait can catch and return.\nOne advantage of writing a custom signal handling thread (such as the example below) rather than a callback\nfunction is that you can now use many more C library and system functions safely .\nBased on sigmask code [2]\nstatic sigset_t signal_mask ;/*signals toblock */\nint main( int argc, char *argv[]) {\npthread_t sig_thr_id ;/*signal handler thread ID*/\nsigemptyset (&signal_mask) ;\nsigaddset (&signal_mask, SIGINT) ;\nsigaddset (&signal_mask, SIGTERM) ;\npthread_sigmask (SIG_BLOCK, &signal_mask, NULL) ;\n/*New threads will inherit this thread \u2019smask */\npthread_create (&sig_thr_id, NULL, signal_thread, NULL) ;\n/*APPLICATION CODE */\n...\n}\nvoid *signal_thread( void *arg) {\nint sig_caught ;\n/*Use the same mask asthe set ofsignals that we\u2019dlike toknow\nabout !*/\nsigwait(&signal_mask, &sig_caught) ;\nswitch (sig_caught) {\ncase SIGINT:\n...\nbreak ;\ncase SIGTERM:\n...\nbreak ;\ndefault :\nfprintf (stderr, \"\\nUnexpected signal %d\\n\", sig_caught) ;\nbreak ;\n}\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1594, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2ba23a71-ba84-44df-80ef-f77226063a15": {"__data__": {"id_": "2ba23a71-ba84-44df-80ef-f77226063a15", "embedding": null, "metadata": {"page_label": "294", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1c039564-05c2-4d21-8f8e-404c80798eaa", "node_type": "4", "metadata": {"page_label": "294", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b345acd422b6369cf438649613221d32b785605c7d87fefa95126e84d1648eb6", "class_name": "RelatedNodeInfo"}}, "text": "294 CHAPTER 13. SIGNALS\n13.5 Signals in Child Processes and Threads\nThis is a recap of the processes chapter. After forking, the child process inherits a copy of the parent\u2019s signal\ndispositions and a copy of the parent\u2019s signal mask. If you have installed a SIGINT handler before forking, then\nthe child process will also call the handler if a SIGINT is delivered to the child. If SIGINT is blocked in the parent,\nit will be blocked in the child as well. Note that pending signals for the child are notinherited during forking.\nAfter exec though, only the signal mask and pending signals are carried over [1]. Signal handlers are reset to\ntheir original action, because the original handler code may have disappeared along with the old process.\nEach thread has its own mask. A new thread inherits a copy of the calling thread\u2019s mask. On initialization, the\ncalling thread\u2019s mask is the exact same as the processes mask. After a new thread is created though, the processes\nsignal mask turns into a gray area. Instead, the kernel likes to treat the process as a collection of threads, each of\nwhich can institute a signal mask and receive signals. To start setting your mask, you can use,\npthread_sigmask(...) ;//set mymask toblock delivery ofsome signals\npthread_create(...) ;//new thread will start with acopy ofthe same\nmask\nBlocking signals is similar in multi-threaded programs to single-threaded programs with the following transla-\ntion.\n1.Usepthread_sigmask instead of sigprocmask\n2.Block a signal in all threads to prevent its asynchronous delivery\nThe easiest method to ensure a signal is blocked in all threads is to set the signal mask in the main thread\nbefore new threads are created.\nsigemptyset(&set) ;\nsigaddset(&set, SIGQUIT) ;\nsigaddset(&set, SIGINT) ;\npthread_sigmask(SIG_BLOCK, &set, NULL) ;\n//this thread and the new thread will block SIGQUIT and SIGINT\npthread_create(&thread_id, NULL, myfunc, funcparam) ;\nJust as we saw with sigprocmask ,pthread_sigmask includes a \u2018how\u2019 parameter that de\ufb01nes how the signal\nset is to be used:\npthread_sigmask(SIG_SETMASK, &set, NULL) - replace the thread \u2019smask\nwith given signal set\npthread_sigmask (SIG_BLOCK ,&set,NULL )-add the signal set tothe\nthread \u2019s mask\npthread_sigmask(SIG_UNBLOCK, &set, NULL) - remove the signal set from\nthe thread \u2019smask", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2309, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "81abed72-4db6-4b2d-8fd8-341e62380811": {"__data__": {"id_": "81abed72-4db6-4b2d-8fd8-341e62380811", "embedding": null, "metadata": {"page_label": "295", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0c051f7f-aca1-4685-b374-3b3d200d86f2", "node_type": "4", "metadata": {"page_label": "295", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c26b47023473a3b0e6dd1267a156d0e95411a66ee814af5dfa2b6a695c250896", "class_name": "RelatedNodeInfo"}}, "text": "13.6. TOPICS 295\nA signal then can be delivered to any signal thread that is willing to accept that signal. If the two or more\nthreads can receive the signal then which thread will be interrupted is arbitrary! A common practice is to have one\nthread that can receive all signals or if there is a certain signal that requires special logic, have multiple threads\nfor multiple signals. Even though programs from the outside can\u2019t send signals to speci\ufb01c threads, you can do\nthat internally with pthread_kill(pthread_t thread, int sig) . In the example below, the newly created\nthread executing func will be interrupted by SIGINT\npthread_create(&tid, NULL, func, args) ;\npthread_kill(tid, SIGINT) ;\npthread_kill(pthread_self(), SIGKILL) ;//send SIGKILL tomyself\nAs a word of warning pthread_kill(threadid, SIGKILL) will kill the entire process. Though individual\nthreads can set a signal mask, the signal disposition is per-proces s not per-thread . This means sigaction can be\ncalled from any thread because you will be setting a signal handler for all threads in the process.\nThe Linux man pages discuss signal system calls in section 2. There is also a longer article in section 7 (though\nnot in OSX /BSD):\nman -s7 signal\n13.6 Topics\n\u2022Signals\n\u2022Signal Handler Safety\n\u2022Signal Disposition\n\u2022Signal States\n\u2022Pending Signals when Forking /Exec\n\u2022Signal Disposition when Forking /Exec\n\u2022Raising Signals in C\n\u2022Raising Signals in a multithreaded program\n13.7 Questions\n\u2022What is a signal?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1475, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc1db42e-a113-47ae-9e8c-fadd92ba4f33": {"__data__": {"id_": "fc1db42e-a113-47ae-9e8c-fadd92ba4f33", "embedding": null, "metadata": {"page_label": "296", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9024f802-544f-4a3b-90ec-742cc7fc7c02", "node_type": "4", "metadata": {"page_label": "296", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "732b58885c9c1907bd464511375b3a5c3fee7efff597f53411030dc3af2f7f62", "class_name": "RelatedNodeInfo"}}, "text": "296 CHAPTER 13. SIGNALS\n\u2022How are signals served under UNIX? (Bonus: How about Windows?)\n\u2022What does it mean that a function is signal handler safe? How about reentrant?\n\u2022What is a process signal disposition? How does it differ from a mask?\n\u2022What function changes the signal disposition in a single threaded program? How about a multithreaded\nprogram?\n\u2022What are some drawbacks to using signals?\n\u2022What are the ways of asynchronously and synchronously catching a signal?\n\u2022What happens to pending signals after a fork? exec? How about my signal mask? How about signal\ndisposition?\n\u2022What is the process the kernel goes through from creation to delivery /block?\nBibliography\n[1]Executing a \ufb01le. URL https://www.gnu.org/software/libc/manual/html_node/Executing-a-File.\nhtml#Executing-a-File .\n[2]pthreadsi gmask .URL.\nJure orn. gto76 /comp-cpp, Jun 2015. URL https://github.com/gto76/comp-cpp/blob/1bf9a77eaf8f57f7358a316e5bbada97f2dc8987/\nsrc/output.c .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 946, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b3bc4f64-d1a1-4168-8d72-83dc563f660d": {"__data__": {"id_": "b3bc4f64-d1a1-4168-8d72-83dc563f660d", "embedding": null, "metadata": {"page_label": "129", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c010ea09-376e-4217-9b2c-d5e95baf2ff7", "node_type": "4", "metadata": {"page_label": "129", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "293cc3a94904b36c66bb622a89b0aca8764b1bc20c3d58c3692d5b61b92dee70", "class_name": "RelatedNodeInfo"}}, "text": "7\nSynchronization\nWhen multithreading gets interesting\nSynchronization coordinates various tasks so that they all \ufb01nishin the the correct state. In C, we have series of\nmechanisms to control what threads are allowed to perform at a given state. Most of the time, the threads can\nprogress without having to communicate, but every so often two or more threads may want to access a critical\nsection. A critical section is a section of code that can only be executed by one thread at a time if the program is\nto function correctly . If two threads (or processes) were to execute code inside the critical section at the same\ntime, it is possible that the program may no longer have the correct behavior.\nAs we said in the previous chapter, race conditions happen when an operation touches a piece of memory\nat the same time as another thread. If the memory location is only accessible by one thread, for example the\nautomatic variable ibelow, then there is no possibility of a race condition and no Critical Section associated with\ni. However, the sumvariable is a global variable and accessed by two threads. It is possible that two threads may\nattempt to increment the variable at the same time.\n#include <stdio.h >\n#include <pthread.h >\nint sum = 0 ;//shared\nvoid *countgold( void *param) {\nint i;//local toeach thread\nfor (i = 0 ;i<10000000 ;i++){\nsum += 1 ;\n}\nreturn NULL ;\n}\nint main() {\npthread_t tid1, tid2 ;\npthread_create(&tid1, NULL, countgold, NULL) ;\npthread_create(&tid2, NULL, countgold, NULL) ;\n129", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1509, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "281a2b78-848f-42f1-8c22-2b0d081ab8ce": {"__data__": {"id_": "281a2b78-848f-42f1-8c22-2b0d081ab8ce", "embedding": null, "metadata": {"page_label": "130", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "905799e5-769f-4ae3-bac5-391c9b564d86", "node_type": "4", "metadata": {"page_label": "130", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "81e8bb71779fa9edb0a81445d11bf12e1385fbc2e0da9ee1b4d1d93353c4deb1", "class_name": "RelatedNodeInfo"}}, "text": "130 CHAPTER 7. SYNCHRONIZATION\n//Wait for both threads tofinish :\npthread_join(tid1, NULL) ;\npthread_join(tid2, NULL) ;\nprintf( \"ARRRRG sum is%d\\n\", sum) ;\nreturn 0;\n}\nA typical output of the above code is ARGGGH sum is <some number less than expected> because there\nis a race condition. The code allows two threads to read and write sumat the same time. For example, both\nthreads copy the current value of sum into CPU that runs each thread (let\u2019s pick 123). Both threads increment\none to their own copy . Both threads write back the value (124). If the threads had accessed the sum at different\ntimes then the count would have been 125. A few of the possible different orderings are below.\nPermissible Pattern\nTable 7.1: Good Thread Access Pattern\nThread 1 Thread 2\nLoad Addr, Add 1 (i =1 locally) ...\nStore (i =1 globally) ...\n... Load Addr, Add 1 (i =2 locally)\n... Store (i =2 globally)\nPartial Overlap\nTable 7.2: Bad Thread Access Pattern\nThread 1 Thread 2\nLoad Addr, Add 1 (i =1 locally) ...\nStore (i =1 globally) Load Addr, Add 1 (i =1 locally)\n... Store (i =1 globally)\nFull Overlap\nTable 7.3: Horrible Thread Access Pattern\nThread 1 Thread 2\nLoad Addr, Add 1 (i =1 locally) Load Addr, Add 1 (i =1 locally)\nStore (i =1 globally) Store (i =1 globally)\nWe would like the \ufb01rst pattern of the code being mutually exclusive. Which leads us to our \ufb01rst synchronization\nprimitive, a Mutex.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1391, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eb4971e7-97de-4ee2-99c0-825733e27096": {"__data__": {"id_": "eb4971e7-97de-4ee2-99c0-825733e27096", "embedding": null, "metadata": {"page_label": "131", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c3a8dc9e-e5fc-4420-960e-35e084b0f6de", "node_type": "4", "metadata": {"page_label": "131", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8725a968e12367a4d16d9b6c8d0695ff7dcf3ab602af85c44f3c75c294637d65", "class_name": "RelatedNodeInfo"}}, "text": "7.1. MUTEX 131\n7.1 Mutex\nTo ensure that only one thread at a time can access a global variable, use a mutex \u2013 short for Mutual Exclusion.\nIf one thread is currently inside a critical section we would like another thread to wait until the \ufb01rst thread is\ncomplete. A mutex isn\u2019t a primitive in the truest sense, though it is one of the smallest that has useful threading\nAPI. A mutex also isn\u2019t a data structure. It is an abstract data type.\nLet\u2019s think about a duck satisfying the mutex api. If someone has the duck then they are allowed to access a\nshared resource! We call it the mutex duck. Everyone else has to waddle around and wait. Once someone let\u2019s go\nof the duck, they have to stop interacting with the resource and the next grabber can interact with the shared\nresource. Now you know the origins of the duck.\nThere are many ways to implement a mutex, and we\u2019ll give a few in this chapter. For right now let\u2019s use the\nblack box that the pthread library gives us. Here is how we declare a mutex.\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER ;\npthread_mutex_lock(&m) ;//start ofCritical Section\n//Critical section\npthread_mutex_unlock(&m) ;//end ofCritical Section\n7.1.1 Mutex Lifetime\nFor all mutexes, there are two ways of initializing a mutex:\n\u2022PTHREAD_MUTEX_INITIALIZER\n\u2022pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *attr)\nThe macro PTHREAD_MUTEX_INITIALIZER is functionally equivalent to the more general purpose pthread_mutex_init(m,NULL) .\nIn other words, PTHREAD_MUTEX_INITIALIZER will create a mutex with default properties. The attr in the init\nversion includes options to trade performance for additional error-checking, advanced sharing, and more. While\nwe recommend using the init function inside of a program for a mutex located on the heap, you can use either\nmethod.\npthread_mutex_t *lock = malloc( sizeof (pthread_mutex_t)) ;\npthread_mutex_init(lock, NULL) ;\n//later\npthread_mutex_destroy(lock) ;\nfree(lock) ;\nOnce we are \ufb01nished with the mutex we should also call pthread_mutex_destroy(m) too. Note, a program\ncan only destroy an unlocked mutex, destroy on a locked mutex is unde\ufb01ned behavior. Things to keep in mind\nabout initializing and destroying mutexes:\n1.Initializing an already initialized mutex is unde\ufb01ned behavior", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2268, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf089f90-c956-498a-ba8a-cfc65b208317": {"__data__": {"id_": "cf089f90-c956-498a-ba8a-cfc65b208317", "embedding": null, "metadata": {"page_label": "132", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "614bbbac-9060-4071-8078-a73c0aaaf020", "node_type": "4", "metadata": {"page_label": "132", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "25b0caada5b8d0d63340be0efcd361f899bcf8dee560755024d04f314f68a51f", "class_name": "RelatedNodeInfo"}}, "text": "132 CHAPTER 7. SYNCHRONIZATION\n2.Destroying a locked mutex is unde\ufb01ned behavior\n3.Keep to the pattern of one and only one thread initializing a mutex.\n4.Copying the bytes of the mutex to a new memory location and then using the copy is notsupported. To\nreference a mutex, a program must to have a pointer to that memory address.\n5.Global /Static mutexes need not be destroyed.\n7.1.2 Mutex Usages\nHow does one use a mutex? Here is a complete example in the spirit of the earlier piece of code.\n#include <stdio.h >\n#include <pthread.h >\n//Create aglobal mutex ,this isready tobelocked !\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER ;\nint sum = 0 ;\nvoid *countgold( void *param) {\nint i;\n//Same thread that locks the mutex must unlock it\n//Critical section is\u2019sum +=1\u2019\n//However locking and unlocking ten million times\n//has significant overhead\npthread_mutex_lock(&m) ;\n//Other threads that call lock will have towait until wecall unlock\nfor (i = 0 ;i<10000000 ;i++){\nsum += 1 ;\n}\npthread_mutex_unlock(&m) ;\nreturn NULL ;\n}\nint main() {\npthread_t tid1, tid2 ;\npthread_create(&tid1, NULL, countgold, NULL) ;\npthread_create(&tid2, NULL, countgold, NULL) ;\npthread_join(tid1, NULL) ;\npthread_join(tid2, NULL) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1206, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e7bba28a-ab03-4471-ac39-ffb4a110f2c4": {"__data__": {"id_": "e7bba28a-ab03-4471-ac39-ffb4a110f2c4", "embedding": null, "metadata": {"page_label": "133", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4f82ee2f-9dec-4bbd-85ca-6c164ae4e794", "node_type": "4", "metadata": {"page_label": "133", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "91f288e17534f435849328517ad1d83acc03e4c8e27e2c51cdb09aca8b724934", "class_name": "RelatedNodeInfo"}}, "text": "7.1. MUTEX 133\nprintf( \"ARRRRG sum is%d\\n\", sum) ;\nreturn 0;\n}\nIn the code above, the thread gets the lock to the counting house before entering. The critical section is only\nthesum+=1 so the following version is also correct.\nfor (i = 0 ;i<10000000 ;i++){\npthread_mutex_lock(&m) ;\nsum += 1 ;\npthread_mutex_unlock(&m) ;\n}\nreturn NULL ;\n}\nThis process runs slower because we lock and unlock the mutex a million times, which is expensive - at least\ncompared with incrementing a variable. In this simple example, we didn\u2019t need threads - we could have added up\ntwice! A faster multi-thread example would be to add one million using an automatic (local) variable and only\nthen adding it to a shared total after the calculation loop has \ufb01nished:\nint local = 0 ;\nfor (i = 0 ;i<10000000 ;i++){\nlocal += 1 ;\n}\npthread_mutex_lock(&m) ;\nsum += local ;\npthread_mutex_unlock(&m) ;\nreturn NULL ;\n}\nStarting with the gotchas. Firstly , C Mutexes do not lock variables. A mutex is a simple data structure. It\nworks with code, not data. If a mutex is locked, the other threads will continue. It\u2019s only when a thread attempts\nto lock a mutex that is already locked, will the thread have to wait. As soon as the original thread unlocks the\nmutex, the second (waiting) thread will acquire the lock and be able to continue. The following code creates a\nmutex that does effectively nothing.\nint a;\npthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER,\nm2 = = PTHREAD_MUTEX_INITIALIZER ;\n//later", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1467, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9a9bc81a-59df-43de-af38-fe6c97beedd6": {"__data__": {"id_": "9a9bc81a-59df-43de-af38-fe6c97beedd6", "embedding": null, "metadata": {"page_label": "134", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "47c52128-3a12-40af-8840-870dbad382ba", "node_type": "4", "metadata": {"page_label": "134", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "da93de9b25ba17325922835c0df8d1bd3783ebfe76e8e604b09d2484a7c20693", "class_name": "RelatedNodeInfo"}}, "text": "134 CHAPTER 7. SYNCHRONIZATION\n//Thread 1\npthread_mutex_lock(&m1) ;\na++;\npthread_mutex_unlock(&m1) ;\n//Thread 2\npthread_mutex_lock(&m2) ;\na++;\npthread_mutex_unlock(&m2) ;\nHere are some other gotchas in no particular order\n1.Don\u2019t cross the streams! If using threads, don\u2019t fork in the middle of your program. This means any time\nafter your mutexes have been initialized.\n2.The thread that locks a mutex is the only thread that can unlock it.\n3.Each program can have multiple mutex locks. A thread safe design might include a lock with each data\nstructure, one lock per heap, or one lock per set of data structures If a program has only one lock, then\nthere may be signi\ufb01cant contention for the lock. If two threads were updating two different counters, it isn\u2019t\nnecessary to use the same lock.\n4.Locks are only tools. They don\u2019t spot critical sections!\n5.There will always be a small amount of overhead of calling pthread_mutex_lock andpthread_mutex_unlock .\nHowever, this is the price to pay for correctly functioning programs!\n6.Not unlocking a mutex due to an early return during an error condition\n7.Resource leak (not calling pthread_mutex_destroy )\n8.Using an uninitialized mutex or using a mutex that has already been destroyed\n9.Locking a mutex twice on a thread without unlocking \ufb01rst\n10.Deadlock\n7.1.3 Mutex Implementation\nSo we have this cool data structure. How do we implement it? A naive, incorrect implementation is shown below.\nTheunlock function simply unlocks the mutex and returns. The lock function \ufb01rst checks to see if the lock is\nalready locked. If it is currently locked, it will keep checking again until another thread has unlocked the mutex.\nFor the time being, we\u2019ll avoid the condition that other threads are able to unlock a lock they don\u2019t own and focus\non the mutual exclusion aspect.\n//Version 1(Incorrect !)\nvoid lock(mutex_t *m) {\nwhile (m->locked) {/*Locked ?Never -mind -loop and check again !*/}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1933, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e2ca87d9-08a6-4511-ab9f-7f6bbbf6b094": {"__data__": {"id_": "e2ca87d9-08a6-4511-ab9f-7f6bbbf6b094", "embedding": null, "metadata": {"page_label": "135", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "fc0f6a60-0c1a-426f-9825-756c24a702d6", "node_type": "4", "metadata": {"page_label": "135", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "19c92b39d474e3f04a46b3cf629cb7c6b29b1e8fd1df780436b675fabbf45ccb", "class_name": "RelatedNodeInfo"}}, "text": "7.1. MUTEX 135\nm->locked = 1 ;\n}\nvoid unlock(mutex_t *m) {\nm->locked = 0 ;\n}\nVersion 1 uses \u2018busy-waiting\u2019 unnecessarily wasting CPU resources. However, there is a more serious problem.\nWe have a race-condition! If two threads both called lock concurrently , it is possible that both threads would\nread m_locked as zero. Thus both threads would believe they have exclusive access to the lock and both threads\nwill continue.\nWe might attempt to reduce the CPU overhead a little by calling pthread_yield() inside the loop - pthread_yield\nsuggests to the operating system that the thread does not use the CPU for a short while, so the CPU may be\nassigned to threads that are waiting to run. This still leaves the race-condition. We need a better implementation.\nWe will talk about this later in the critical section part of this chapter. For now, we will talk about semaphores.\n7.1.4 Advanced: Implementing a Mutex with hardware\nWe can use C11 Atomics to do that perfectly! A complete solution is detailed here. This is a spinlock mutex, futex\nimplementations can be found online.\nFirst the data structure and initialization code.\ntypedef struct mutex_ {\n//Weneed some variable tosee ifthe lock islocked\natomic_int_least8_t lock ;\n//Amutex needs tokeep track ofits owner so\n//Another thread can\u2019tunlock it\npthread_t owner ;\n}mutex ;\n#define UNLOCKED 0\n#define LOCKED 1\n#define UNASSIGNED_OWNER 0\nint mutex_init(mutex* mtx) {\n//Some simple error checking\nif(!mtx) {\nreturn 0;\n}\n//Not thread -safe the user has totake care ofthis\natomic_init(&mtx- >lock, UNLOCKED) ;\nmtx- >owner = UNASSIGNED_OWNER ;\nreturn 1;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1606, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1b709b0a-b58e-4c4b-89b6-d26cb3ca61b8": {"__data__": {"id_": "1b709b0a-b58e-4c4b-89b6-d26cb3ca61b8", "embedding": null, "metadata": {"page_label": "136", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "34e9dd64-72e7-40ba-8c05-70c869a1ce6c", "node_type": "4", "metadata": {"page_label": "136", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c741884c1b677c16db805f93c4013cca41d8c45713277de77c5912de879bcecf", "class_name": "RelatedNodeInfo"}}, "text": "136 CHAPTER 7. SYNCHRONIZATION\nThis is the initialization code, nothing fancy here. We set the state of the mutex to unlocked and set the owner\nto locked.\nint mutex_lock(mutex* mtx) {\nint_least8_t zero = UNLOCKED ;\nwhile (!atomic_compare_exchange_weak_explicit\n(&mtx- >lock,\n&zero,\nLOCKED,\nmemory_order_seq_cst,\nmemory_order_seq_cst)) {\nzero = UNLOCKED ;\nsched_yield() ;//Use system calls for scheduling speed\n}\n//Wehave the lock now\nmtx- >owner = pthread_self() ;\nreturn 1;\n}\nWhat does this code do? It initializes a variable that we will keep as the unlocked state. Atomic Compare and\nExchange is an instruction supported by most modern architectures (on x86 it\u2019s lock cmpxchg ). The pseudocode\nfor this operation looks like this\nint atomic_compare_exchange_pseudo( int* addr1, int* addr2, int val) {\nif(*addr1 == *addr2) {\n*addr1 = val ;\nreturn 1;\n}else {\n*addr2 = *addr1 ;\nreturn 0;\n}\n}\nExcept it is all done atomically meaning in one uninterruptible operation. What does the weak part mean?\nAtomic instructions are prone to spurious failures meaning that there are two versions to these atomic functions\nastrong and a weak part, strong guarantees the success or failure while weak may fail even when the operation\nsucceeds. These are the same spurious failures that you\u2019ll see in condition variables below. We are using weak\nbecause weak is faster, and we are in a loop! That means we are okay if it fails a little bit more often because we\nwill keep spinning around anyway .\nInside the while loop, we have failed to grab the lock! We reset zero to unlocked and sleep for a little while.\nWhen we wake up we try to grab the lock again. Once we successfully swap, we are in the critical section! We set\nthe mutex\u2019s owner to the current thread for the unlock method and return successfully .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1793, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f47cac14-aea5-4cdb-8909-c47728ee03a4": {"__data__": {"id_": "f47cac14-aea5-4cdb-8909-c47728ee03a4", "embedding": null, "metadata": {"page_label": "137", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bed28dad-2521-4457-84de-5025f3aa9eec", "node_type": "4", "metadata": {"page_label": "137", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f204147ee36df6d8fff2cf193a21329303cd60aafa01324fe66fa72d0bf0bd6e", "class_name": "RelatedNodeInfo"}}, "text": "7.1. MUTEX 137\nHow does this guarantee mutual exclusion? When working with atomics we are unsure! But in this simple\nexample, we can because the thread that can successfully expect the lock to be UNLOCKED (0) and swap it to a\nLOCKED (1) state is considered the winner. How do we implement unlock?\nint mutex_unlock(mutex* mtx) {\nif(unlikely(pthread_self() != mtx- >owner)) {\nreturn 0;//Can\u2019tunlock amutex ifthe thread isn\u2019tthe owner\n}\nint_least8_t one = 1 ;\n//Critical section ends after this atomic\nmtx- >owner = UNASSIGNED_OWNER ;\nif(!atomic_compare_exchange_strong_explicit(\n&mtx- >lock,\n&one,\nUNLOCKED,\nmemory_order_seq_cst,\nmemory_order_seq_cst)) {\n//The mutex was never locked inthe first place\nreturn 0;\n}\nreturn 1;\n}\nTo satisfy the API, a thread can\u2019t unlock the mutex unless the thread is the one who owns it. Then we unassign\nthe mutex owner, because critical section is over after the atomic. We want a strong exchange because we don\u2019t\nwant to block. We expect the mutex to be locked, and we swap it to unlock. If the swap was successful, we\nunlocked the mutex. If the swap wasn\u2019t, that means that the mutex was UNLOCKED and we tried to switch it\nfrom UNLOCKED to UNLOCKED, preserving the behavior of unlock.\nWhat is this memory order business? We were talking about memory fences earlier, here it is! We won\u2019t go\ninto detail because it is outside the scope of this course but in the scope of this article. We need consistency to\nmake sure no loads or stores are ordered before or after. A program need to create dependency chains for more\nef\ufb01cient ordering.\n7.1.5 Semaphore\nA semaphore is another synchronization primitive. It is initialized to some value. Threads can either sem_wait or\nsem_post which lowers or increases the value. If the value reaches zero and a wait is called, the thread will be\nblocked until a post is called.\nUsing a semaphore is as easy as using a mutex. First, decide if on the initial value, for example the number\nof remaining spaces in an array . Unlike pthread mutex there are no shortcuts to creating a semaphore - use\nsem_init .\n#include <semaphore.h >", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2095, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7506bae8-0f48-4cf6-9561-583f5a05b14d": {"__data__": {"id_": "7506bae8-0f48-4cf6-9561-583f5a05b14d", "embedding": null, "metadata": {"page_label": "138", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "746e8702-e1d2-462f-b68b-a2a580c798e2", "node_type": "4", "metadata": {"page_label": "138", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9be9d796151da1f450511a91da6c02c5766655e2b4044f4eaad4086b4cc49243", "class_name": "RelatedNodeInfo"}}, "text": "138 CHAPTER 7. SYNCHRONIZATION\nsem_t s ;\nint main() {\nsem_init(&s, 0, 10) ;//returns -1(=FAILED )onOSX\nsem_wait(&s) ;//Could dothis 10times without blocking\nsem_post(&s) ;//Announce that we\u2019vefinished (and one more resource\nitem isavailable ;increment count )\nsem_destroy(&s) ;//release resources ofthe semaphore\n}\nWhen using a semaphore, wait and post can be called from different threads! Unlike a mutex, the increment\nand decrement can be from different threads.\nThis becomes especially useful if you want to use a semaphore to implement a mutex. A mutex is a semaphore\nthat always waits before it posts . Some textbooks will refer to a mutex as a binary semaphore. You do have\nto be careful to never add more than one to a semaphore or otherwise your mutex abstraction breaks. That is\nusually why a mutex is used to implement a semaphore and vice versa.\n\u2022Initialize the semaphore with a count of one.\n\u2022Replace pthread_mutex_lock with sem_wait\n\u2022Replace pthread_mutex_unlock with sem_post\nsem_t s ;\nsem_init(&s, 0, 1) ;\nsem_wait(&s) ;\n//Critical Section\nsem_post(&s) ;\nBut be warned, it isn\u2019t the same! A mutex can handle what we call lock inversion well. Meaning the following\ncode breaks with a traditional mutex, but produces a race condition with threads.\n//Thread 1\nsem_wait(&s) ;\n//Critical Section\nsem_post(&s) ;\n//Thread 2\n//Some threads want tosee the world burn\nsem_post(&s) ;\n//Thread 3\nsem_wait(&s) ;\n//Not thread -safe !\nsem_post(&s) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1450, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f749619e-6e28-4835-bee7-1cbb802c44d0": {"__data__": {"id_": "f749619e-6e28-4835-bee7-1cbb802c44d0", "embedding": null, "metadata": {"page_label": "139", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c6c17ada-9385-4879-943c-0dc4cfab4a51", "node_type": "4", "metadata": {"page_label": "139", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9f0981505a9254655be5cfcb5c505d4c27037b3ae69043b0f0050edae5223f04", "class_name": "RelatedNodeInfo"}}, "text": "7.1. MUTEX 139\nIf we replace it with mutex lock, it won\u2019t work now.\n//Thread 1\nmutex_lock(&s) ;\n//Critical Section\nmutex_unlock(&s) ;\n//Thread 2\n//Foiled !\nmutex_unlock(&s) ;\n//Thread 3\nmutex_lock(&s) ;\n//Now it\u2019sthread -safe\nmutex_unlock(&s) ;\nAlso, binary semaphores are different than mutexes because one thread can unlock a mutex from a different\nthread.\nSignal Safety\nAlso, sem_post is one of a handful of functions that can be correctly used inside a signal handler pthread_mutex_unlock\nis not. We can release a waiting thread that can now make all of the calls that we disallowed to call inside the\nsignal handler itself e.g. printf . Here is some code that utilizes this;\n#include <stdio.h >\n#include <pthread.h >\n#include <signal.h >\n#include <semaphore.h >\n#include <unistd.h >\nsem_t s ;\nvoid handler( int signal) {\nsem_post(&s) ;/*Release the Kraken !*/\n}\nvoid *singsong( void *param) {\nsem_wait(&s) ;\nprintf( \"Waiting until asignal releases ...\\ n\");\n}\nint main() {\nint ok = sem_init(&s, 0, 0 /*Initial value ofzero */);", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1032, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec04d862-2b1c-43cc-b3d4-3ae07749c72d": {"__data__": {"id_": "ec04d862-2b1c-43cc-b3d4-3ae07749c72d", "embedding": null, "metadata": {"page_label": "140", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "838f266c-8f34-48d1-9a8a-9b66a0cf9807", "node_type": "4", "metadata": {"page_label": "140", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7c17838ab0186223114f8536d0464629f1c1df635ff43b976f0077bc58763274", "class_name": "RelatedNodeInfo"}}, "text": "140 CHAPTER 7. SYNCHRONIZATION\nif(ok == -1) {\nperror( \"Could not create unnamed semaphore \");\nreturn 1;\n}\nsignal(SIGINT, handler) ;//Too simple !See Signals chapter\npthread_t tid ;\npthread_create(&tid, NULL, singsong, NULL) ;\npthread_exit(NULL) ;/*Process will exit when there are nomore\nthreads */\n}\nOther uses for semaphores are keeping track of empty spaces in arrays. We will discuss these in the thread-safe\ndata structures section.\n7.2 Condition Variables\nCondition variables allow a set of threads to sleep until woken up. The API allows either one or all threads to\nbe woken up. If a program only wakes one thread, the operating system will decide which thread to wake up.\nThreads don\u2019t wake threads other directly like by id. Instead, a thread \u2018signal\u2019s the condition variable, which then\nwill wake up one (or all) threads that are sleeping inside the condition variable.\nCondition variables are also used with a mutex and with a loop, so when woken up they have to check a\ncondition in a critical section. If a thread needs to be woken up outside of a critical section, there are other ways to\ndo this in POSIX. Threads sleeping inside a condition variable are woken up by calling pthread_cond_broadcast\n(wake up all) or pthread_cond_signal (wake up one). Note despite the function name, this has nothing to do\nwith POSIX signal s!\nOccasionally , a waiting thread may appear to wake up for no reason. This is called a spurious wakeup . If you\nread the hardware implementation of a mutex section, this is similar to the atomic failure of the same name.\nWhy do spurious wakeups happen? For performance. On multi-CPU systems, it is possible that a race condition\ncould cause a wake-up (signal) request to be unnoticed. The kernel may not detect this lost wake-up call but can\ndetect when it might occur. To avoid the potentially lost signal, the thread is woken up so that the program code\ncan test the condition again. If you want to know why , check out the appendix.\n7.3 Thread-Safe Data Structures\nNaturally , we want our data structures to be thread-safe as well! We can use mutexes and synchronization\nprimitives to make that happen. First a few de\ufb01nitions. Atomicity is when an operation is thread-safe. We have\natomic instructions in hardware by providing the lock pre\ufb01x\nlock ...", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2294, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a6974ac0-2dc0-405b-a97a-75d472007a6c": {"__data__": {"id_": "a6974ac0-2dc0-405b-a97a-75d472007a6c", "embedding": null, "metadata": {"page_label": "141", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6a869f76-60de-41ad-88ed-b1c56945f82e", "node_type": "4", "metadata": {"page_label": "141", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b00ce22cc02034c1bfecff26ebb4537709286c76900947fc150b59092f822c8d", "class_name": "RelatedNodeInfo"}}, "text": "7.3. THREAD-SAFE DATA STRUCTURES 141\nBut Atomicity also applies to higher orders of operations. We say a data structure operation is atomic if it happens\nall at once and successfully or not at all.\nAs such, we can use synchronization primitives to make our data structures thread-safe. For the most part,\nwe will be using mutexes because they carry more semantic meaning than a binary semaphore. Note, this is an\nintroduction. Writing high-performance thread-safe data structures requires its own book! Take for example the\nfollowing thread-unsafe stack.\n//Asimple fixed -sized stack (version 1)\n#define STACK_SIZE 20\nint count ;\ndouble values[STACK_SIZE] ;\nvoid push( double v){\nvalues[count ++] = v ;\n}\ndouble pop() {\nreturn values[--count] ;\n}\nint is_empty() {\nreturn count == 0 ;\n}\nVersion 1 of the stack is thread-unsafe because if two threads call push or pop at the same time then the results\nor the stack can be inconsistent. For example, imagine if two threads call pop at the same time then both threads\nmay read the same value, both may read the original count value.\nTo turn this into a thread-safe data structure we need to identify the critical sections of our code, meaning we\nneed to ask which section(s) of the code must only have one thread at a time. In the above example the push ,\npop, and is_empty functions access the same memory and all critical sections for the stack. While push (and\npop) is executing, the data structure is an inconsistent state, for example the count may not have been written to,\nso it may still contain the original value. By wrapping these methods with a mutex we can ensure that only one\nthread at a time can update (or read) the stack. A candidate \u2018solution\u2019 is shown below. Is it correct? If not, how\nwill it fail?\n//Anattempt atathread -safe stack (version 2)\n#define STACK_SIZE 20\nint count ;\ndouble values[STACK_SIZE] ;\npthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER ;\npthread_mutex_t m2 = PTHREAD_MUTEX_INITIALIZER ;\nvoid push( double v){\npthread_mutex_lock(&m1) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2019, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a7dd9efe-df6a-4145-aec3-9537ce37b2f9": {"__data__": {"id_": "a7dd9efe-df6a-4145-aec3-9537ce37b2f9", "embedding": null, "metadata": {"page_label": "142", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "26c61b21-edd2-45bc-9302-7081e47f61e4", "node_type": "4", "metadata": {"page_label": "142", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9b2574d4cdec28cd6eea7bc86e3409aea3490b3493f861f1e9dd576ce89a070e", "class_name": "RelatedNodeInfo"}}, "text": "142 CHAPTER 7. SYNCHRONIZATION\nvalues[count ++] = v ;\npthread_mutex_unlock(&m1) ;\n}\ndouble pop() {\npthread_mutex_lock(&m2) ;\ndouble v = values[--count] ;\npthread_mutex_unlock(&m2) ;\nreturn v;\n}\nint is_empty() {\npthread_mutex_lock(&m1) ;\nreturn count == 0 ;\npthread_mutex_unlock(&m1) ;\n}\nVersion 2 contains at least one error. Take a moment to see if you can the error(s) and work out the\nconsequence(s).\nIf three threads called push() at the same time, the lock m1ensures that only one thread at time manipulates\nthe stack on push or is_empty \u2013 Two threads will need to wait until the \ufb01rst thread completes A similar argument\napplies to concurrent calls to pop. However, Version 2 does not prevent push and pop from running at the same\ntime because push andpopuse two different mutex locks. The \ufb01x is simple in this case - use the same mutex lock\nfor both the push and pop functions.\nThe code has a second error. is_empty returns after the comparison and leaves the mutex unlocked. However,\nthe error would not be spotted immediately . For example, suppose one thread calls is_empty and a second thread\nlater calls push . This thread would mysteriously stop. Using debugger, you can discover that the thread is stuck\nat the lock() method inside the push method because the lock was never unlocked by the earlier is_empty call.\nThus an oversight in one thread led to problems much later in time in an arbitrary other thread. Let\u2019s try to rectify\nthese problems\n//Anattempt atathread -safe stack (version 3)\nint count ;\ndouble values[count] ;\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER ;\nvoid push( double v){\npthread_mutex_lock(&m) ;\nvalues[count ++] = v ;\npthread_mutex_unlock(&m) ;\n}\ndouble pop() {\npthread_mutex_lock(&m) ;\ndouble v = values[--count] ;\npthread_mutex_unlock(&m) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1783, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5769d982-3672-4ad5-b18b-61e32c18521c": {"__data__": {"id_": "5769d982-3672-4ad5-b18b-61e32c18521c", "embedding": null, "metadata": {"page_label": "143", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8a53a2ad-3546-4d7f-9e2b-f254537ebc76", "node_type": "4", "metadata": {"page_label": "143", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4855023ecb36b6e96ce1305286f7a45603c8da24433b38ef1ad5b19113400f4d", "class_name": "RelatedNodeInfo"}}, "text": "7.3. THREAD-SAFE DATA STRUCTURES 143\nreturn v;\n}\nint is_empty() {\npthread_mutex_lock(&m) ;\nint result = count == 0 ;\npthread_mutex_unlock(&m) ;\nreturn result ;\n}\nVersion 3 is thread-safe. We have ensured mutual exclusion for all of the critical sections. There are a few\nthings to note.\n\u2022is_empty is thread-safe but its result may already be out-of-date. The stack may no longer be empty by the\ntime the thread gets the result! This is usually why in thread-safe data structures, functions that return sizes\nare removed or deprecated.\n\u2022There is no protection against under\ufb02ow (popping on an empty stack) or over\ufb02ow (pushing onto an\nalready-full stack)\nThe last point can be \ufb01xed using counting semaphores. The implementation assumes a single stack. A more\ngeneral-purpose version might include the mutex as part of the memory structure and use pthread_mutex_init\nto initialize the mutex. For example,\n//Support for multiple stacks (each one has amutex )\ntypedef struct stack {\nint count ;\npthread_mutex_t m ;\ndouble *values ;\n}stack_t ;\nstack_t* stack_create( int capacity) {\nstack_t *result = malloc( sizeof (stack_t)) ;\nresult- >count = 0 ;\nresult- >values = malloc( sizeof (double ) * capacity) ;\npthread_mutex_init(&result- >m, NULL) ;\nreturn result ;\n}\nvoid stack_destroy(stack_t *s) {\nfree(s- >values) ;\npthread_mutex_destroy(&s- >m);\nfree(s) ;\n}\n//Warning nounderflow oroverflow checks !\nvoid push(stack_t *s, double v){\npthread_mutex_lock(&s- >m);", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1455, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e8eda7f7-09e2-468b-ad0a-a2065f1d5a72": {"__data__": {"id_": "e8eda7f7-09e2-468b-ad0a-a2065f1d5a72", "embedding": null, "metadata": {"page_label": "144", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4611c81c-c88f-440d-90c7-669b6d7d25df", "node_type": "4", "metadata": {"page_label": "144", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7cecc91dc02076e7846394a2bf44a7383d627aff4ffceedc340c3a0152c53bb3", "class_name": "RelatedNodeInfo"}}, "text": "144 CHAPTER 7. SYNCHRONIZATION\ns->values[(s- >count) ++] = v ;\npthread_mutex_unlock(&s- >m);\n}\ndouble pop(stack_t *s) {\npthread_mutex_lock(&s- >m);\ndouble v = s- >values[--(s- >count)] ;\npthread_mutex_unlock(&s- >m);\nreturn v;\n}\nint is_empty(stack_t *s) {\npthread_mutex_lock(&s- >m);\nint result = s- >count == 0 ;\npthread_mutex_unlock(&s- >m);\nreturn result ;\n}\nint main() {\nstack_t *s1 = stack_create(10 /*Max capacity */);\nstack_t *s2 = stack_create(10) ;\npush(s1, 3.141) ;\npush(s2, pop(s1)) ;\nstack_destroy(s2) ;\nstack_destroy(s1) ;\n}\nBefore we \ufb01x the problems with semaphores. How would we \ufb01x the problems with condition variables? Try it\nout before you look at the code in the previous section. We need to wait in push and pop if our stack is full or\nempty respectively . Attempted solution:\n//Assume cvisacondition variable\n//correctly initialized\nvoid push(stack_t *s, double v){\npthread_mutex_lock(&s- >m);\nif(s->count == 0) pthread_cond_wait(&s- >cv, &s- >m);\ns->values[(s- >count) ++] = v ;\npthread_mutex_unlock(&s- >m);\n}\ndouble pop(stack_t *s) {\npthread_mutex_lock(&s- >m);\nif(s->count == 0) pthread_cond_wait(&s- >cv, &s- >m);\ndouble v = s- >values[--(s- >count)] ;\npthread_mutex_unlock(&s- >m);", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1208, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "08964ac0-b99d-4d3a-adc6-91e69049df93": {"__data__": {"id_": "08964ac0-b99d-4d3a-adc6-91e69049df93", "embedding": null, "metadata": {"page_label": "145", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "70df3869-c245-40bb-a93b-1c25436bae83", "node_type": "4", "metadata": {"page_label": "145", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "2fc199e7c996636ed2511be3aad86917b278a83c1086976932ed6d773340eddb", "class_name": "RelatedNodeInfo"}}, "text": "7.3. THREAD-SAFE DATA STRUCTURES 145\nreturn v;\n}\nDoes the following solution work? Take a second before looking at the answer to spot the errors.\nSo did you catch all of them?\n1.The \ufb01rst one is a simple one. In push, our check should be against the total capacity , not zero.\n2.We only have if statement checks. wait() could spuriously wake up\n3.We never signal any of the threads! Threads could get stuck waiting inde\ufb01nitely .\nLet\u2019s \ufb01x those errors Does this solution work?\nvoid push(stack_t *s, double v){\npthread_mutex_lock(&s- >m);\nwhile (s->count == capacity) pthread_cond_wait(&s- >cv, &s- >m);\ns->values[(s- >count) ++] = v ;\npthread_mutex_unlock(&s- >m);\npthread_cond_signal(&s- >cv);\n}\ndouble pop(stack_t *s) {\npthread_mutex_lock(&s- >m);\nwhile (s->count == 0) pthread_cond_wait(&s- >cv, &s- >m);\ndouble v = s- >values[--(s- >count)] ;\npthread_cond_broadcast(&s- >cv);\npthread_mutex_unlock(&s- >m);\nreturn v;\n}\nThis solution doesn\u2019t work either! The problem is with the signal. Can you see why? What would you do to \ufb01x\nit?\nNow, how would we use counting semaphores to prevent over and under\ufb02ow? Let\u2019s discuss it in the next\nsection.\n7.3.1 Using Semaphores\nLet\u2019s use a counting semaphore to keep track of how many spaces remain and another semaphore to track the\nnumber of items in the stack. We will call these two semaphores sremain andsitems . Remember sem_wait will\nwait if the semaphore\u2019s count has been decremented to zero (by another thread calling sem_post).\n//Sketch #1\nsem_t sitems ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1501, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed8dddbb-7892-43b0-a92f-ec3b00e55259": {"__data__": {"id_": "ed8dddbb-7892-43b0-a92f-ec3b00e55259", "embedding": null, "metadata": {"page_label": "146", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ff4d22b3-bf1c-4586-8d64-256ff1110ea5", "node_type": "4", "metadata": {"page_label": "146", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ea56ee3e8fe2accdce24347d3b612b8b9d7393bfa7e2b9dac0242a40d24ceab8", "class_name": "RelatedNodeInfo"}}, "text": "146 CHAPTER 7. SYNCHRONIZATION\nsem_t sremain ;\nvoid stack_init() {\nsem_init(&sitems, 0, 0) ;\nsem_init(&sremain, 0, 10) ;\n}\ndouble pop() {\n//Wait until there \u2019satleast one item\nsem_wait(&sitems) ;\n...\nvoid push( double v){\n//Wait until there \u2019satleast one space\nsem_wait(&sremain) ;\n...\n}\nSketch #2 has implemented the post too early . Another thread waiting in push can erroneously attempt to\nwrite into a full stack. Similarly , a thread waiting in the pop() is allowed to continue too early .\n//Sketch #2(Error !)\ndouble pop() {\n//Wait until there \u2019satleast one item\nsem_wait(&sitems) ;\nsem_post(&sremain) ;//error !wakes uppushing ()thread too early\nreturn values[--count] ;\n}\nvoid push( double v){\n//Wait until there \u2019satleast one space\nsem_wait(&sremain) ;\nsem_post(&sitems) ;//error !wakes upapopping ()thread too early\nvalues[count ++] = v ;\n}\nSketch 3 implements the correct semaphore logic, but can you spot the error?\n//Sketch #3(Error !)\ndouble pop() {\n//Wait until there \u2019satleast one item\nsem_wait(&sitems) ;\ndouble v= values[--count] ;\nsem_post(&sremain) ;\nreturn v;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1080, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2865d37f-2bc8-478d-be59-0a91b6064bdb": {"__data__": {"id_": "2865d37f-2bc8-478d-be59-0a91b6064bdb", "embedding": null, "metadata": {"page_label": "147", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f6d69a42-c29f-479a-817e-23f51227b364", "node_type": "4", "metadata": {"page_label": "147", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "52c7ea90cc7cef7154f57dcb36719ebe8c1fb8df2f17eeeb1ad6a14bbd128abf", "class_name": "RelatedNodeInfo"}}, "text": "7.3. THREAD-SAFE DATA STRUCTURES 147\n}\nvoid push( double v){\n//Wait until there \u2019satleast one space\nsem_wait(&sremain) ;\nvalues[count ++] = v ;\nsem_post(&sitems) ;\n}\nSketch 3 correctly enforces buffer full and buffer empty conditions using semaphores. However, there is\nnomutual exclusion . Two threads can be in the critical section at the same time, which would corrupt the data\nstructure or least lead to data loss. The \ufb01x is to wrap a mutex around the critical section:\n//Simple single stack -see the above example onhow toconvert this\ninto multiple stacks .\n//Also arobust POSIX implementation would check for EINTR and error\ncodes ofsem_wait .\n//PTHREAD_MUTEX_INITIALIZER for statics (use pthread_mutex_init ()for\nstack /heap memory )\n#define SPACES 10\npthread_mutex_t m= PTHREAD_MUTEX_INITIALIZER ;\nint count = 0 ;\ndouble values[SPACES] ;\nsem_t sitems, sremain ;\nvoid init() {\nsem_init(&sitems, 0, 0) ;\nsem_init(&sremains, 0, SPACES) ;//10spaces\n}\ndouble pop() {\n//Wait until there \u2019satleast one item\nsem_wait(&sitems) ;\npthread_mutex_lock(&m) ;//CRITICAL SECTION\ndouble v= values[--count] ;\npthread_mutex_unlock(&m) ;\nsem_post(&sremain) ;//Hey world ,there \u2019satleast one space\nreturn v;\n}\nvoid push( double v){\n//Wait until there \u2019satleast one space\nsem_wait(&sremain) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1278, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e3848f5b-f0bf-4697-8554-1426b28d8dc3": {"__data__": {"id_": "e3848f5b-f0bf-4697-8554-1426b28d8dc3", "embedding": null, "metadata": {"page_label": "148", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "30e7205f-3ac3-4711-b58f-811ffe6f0be0", "node_type": "4", "metadata": {"page_label": "148", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "5a8c4fd995bcdfad33637c10b6748fa2aafac6b5e2b38dd4c67b5d52e8c98495", "class_name": "RelatedNodeInfo"}}, "text": "148 CHAPTER 7. SYNCHRONIZATION\npthread_mutex_lock(&m) ;//CRITICAL SECTION\nvalues[count ++] = v ;\npthread_mutex_unlock(&m) ;\nsem_post(&sitems) ;//Hey world ,there \u2019satleast one item\n}\n//Note arobust solution will need tocheck sem_wait \u2019sresult for\nEINTR (more about this later )\nWhat happens when we start inverting the lock and wait orders?\ndouble pop() {\npthread_mutex_lock(&m) ;\nsem_wait(&sitems) ;\ndouble v= values[--count] ;\npthread_mutex_unlock(&m) ;\nsem_post(&sremain) ;\nreturn v;\n}\nvoid push( double v){\nsem_wait(&sremain) ;\npthread_mutex_lock(&m) ;\nvalues[count ++] = v ;\npthread_mutex_unlock(&m) ;\nsem_post(&sitems) ;\n}\nRather than giving you the answer, we\u2019ll let you think about this. Is this a permissible way to lock and unlock?\nIs there a series of operations that could cause a race condition? How about deadlock? If there is, provide it. If\nthere isn\u2019t, provide a short justi\ufb01cation proof of why that won\u2019t happen.\n7.4 Software Solutions to the Critical Section\nAs already discussed, there are critical parts of our code that can only be executed by one thread at a time. We\ndescribe this requirement as \u2018mutual exclusion\u2019. Only one thread (or process) may have access to the shared\nresource. In multi-threaded programs, we can wrap a critical section with mutex lock and unlock calls:", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1301, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5553d4a7-8070-4348-8d2d-56d348eafa97": {"__data__": {"id_": "5553d4a7-8070-4348-8d2d-56d348eafa97", "embedding": null, "metadata": {"page_label": "149", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0dd0c550-a44a-4b85-9edf-4593ea71542e", "node_type": "4", "metadata": {"page_label": "149", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "eff23119b6cc04464b868f5bf9eebe89b1482e50d3553fcab6a4094aea1b6c71", "class_name": "RelatedNodeInfo"}}, "text": "7.4. SOFTWARE SOLUTIONS TO THE CRITICAL SECTION 149\npthread_mutex_lock() //one thread allowed atatime !(others will have\ntowait here )\n//... DoCritical Section stuff here !\npthread_mutex_unlock() //let other waiting threads continue\nHow would we implement these lock and unlock calls? Can we create a pure software algorithm that assures\nmutual exclusion? Here is our attempt from earlier.\npthread_mutex_lock(p_mutex_t *m) {\nwhile (m->lock) ;\nm->lock = 1 ;\n}\npthread_mutex_unlock(p_mutex_t *m) {\nm->lock = 0 ;\n}\nAs we touched on earlier, this implementation does not satisfy Mutual Exclusion even considering that threads\ncan unlock other threads locks. Let\u2019s take a close look at this \u2018implementation\u2019 from two threads running around\nthe same time.\nTo simplify the discussion, we consider only two threads. Note these arguments work for threads and processes\nand the classic CS literature discusses these problems in terms of two processes that need exclusive access to\na critical section or shared resource. Raising a \ufb02ag represents a thread /process\u2019s intention to enter the critical\nsection.\nThere are three main desirable properties that we desire in a solution to the critical section problem.\n1.Mutual Exclusion. The thread /process gets exclusive access. Others must wait until it exits the critical\nsection.\n2.Bounded Wait. A thread /process cannot get superseded by another thread in\ufb01nite amounts of time.\n3.Progress. If no thread /process is inside the critical section, the thread /process should be able to proceed\nwithout having to wait.\nWith these ideas in mind, let\u2019s examine another candidate solution that uses a turn-based \ufb02ag only if two\nthreads both required access at the same time.\n7.4.1 Naive Solutions\nRemember that the pseudo-code outlined below is part of a larger program. The thread or process will typically\nneed to enter the critical section many times during the lifetime of the process. So, imagine each example as\nwrapped inside a loop where for a random amount of time the thread or process is working on something else.\nIs there anything wrong with the candidate solution described below?\n//Candidate #1", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2139, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b20367da-475b-4d5a-ba5b-0f0e9aa19585": {"__data__": {"id_": "b20367da-475b-4d5a-ba5b-0f0e9aa19585", "embedding": null, "metadata": {"page_label": "150", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "70658702-f82c-42d4-ad07-e53301c7e050", "node_type": "4", "metadata": {"page_label": "150", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "84c27adfd47d6b30572ab2f20f44189f4de5b2267e478c4377c31cb305b74ffe", "class_name": "RelatedNodeInfo"}}, "text": "150 CHAPTER 7. SYNCHRONIZATION\nwait until your flag is lowered\nraise my flag\n//DoCritical Section stuff\nlower my flag\nAnswer: Candidate solution #1 also suffers from a race condition because both threads /processes could read\neach other\u2019s \ufb02ag value as lowered and continue.\nThis suggests we should raise the \ufb02ag before checking the other thread\u2019s \ufb02ag, which is candidate solution #2\nbelow.\n//Candidate #2\nraise my flag\nwait until your flag is lowered\n//DoCritical Section stuff\nlower my flag\nCandidate #2 satis\ufb01es mutual exclusion. It is impossible for two threads to be inside the critical section at the\nsame time. However, this code suffers from deadlock! Suppose two threads wish to enter the critical section at\nthe same time.\nTable 7.4: Candidate Solution #2 Analysis\nTime Thread 1 Thread 2\n1 Raise Flag\n2 Raise Flag\n3 Wait Wait\nBoth processes are now waiting for the other one to lower their \ufb02ags. Neither one will enter the critical section\nas both are now stuck forever! This suggests we should use a turn-based variable to try to resolve who should\nproceed.\n7.4.2 Turn-based solutions\nThe following candidate solution #3 uses a turn-based variable to politely allow one thread and then the other to\ncontinue\n//Candidate #3\nwait until my turn is myid\n//DoCritical Section stuff\nturn = yourid", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1300, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e329b516-3702-40e7-a848-845b2746b58a": {"__data__": {"id_": "e329b516-3702-40e7-a848-845b2746b58a", "embedding": null, "metadata": {"page_label": "151", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5069b1f4-1d39-41c0-8e17-767d13722f84", "node_type": "4", "metadata": {"page_label": "151", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "02f344b31decc71e666f2d7cb810f9690727189191ad270ea4b8f4f0dac4160c", "class_name": "RelatedNodeInfo"}}, "text": "7.5. WORKING SOLUTIONS 151\nCandidate #3 satis\ufb01es mutual exclusion. Each thread or process gets exclusive access to the Critical Section.\nHowever, both threads /processes must take a strict turn-based approach to use the critical section. They are forced\ninto an alternating critical section access pattern. If thread 1 wishes to read a hash table every millisecond, but\nanother thread writes to a hash table every second, then the reading thread would have to wait another 999ms\nbefore being able to read from the hash table again. This \u2018solution\u2019 is ineffective because our threads should be\nable to make progress and enter the critical section if no other thread is currently in the critical section.\n7.4.3 Turn and Flag solutions\nIs the following a correct solution to CSP?\n\\\\ Candidate #4\nraise my flag\nifyour flag is raised, wait until my turn\n//DoCritical Section stuff\nturn = yourid\nlower my flag\nAnalyzing these solutions is tricky . Even peer-reviewed papers on this speci\ufb01c subject contain incorrect\nsolutions [?]! At \ufb01rst glance, it appears to satisfy Mutual Exclusion, Bounded Wait and Progress The turn-based\n\ufb02ag is only used in the event of a tie, so Progress and Bounded Wait is allowed and mutual exclusion appears to\nbe satis\ufb01ed. Perhaps you can \ufb01nd a counter-example?\nCandidate #4 fails because a thread does not wait until the other thread lowers its \ufb02ag. After some thought or\ninspiration, the following scenario can be created to demonstrate how Mutual Exclusion is not satis\ufb01ed.\nImagine the \ufb01rst thread runs this code twice. The turn \ufb02ag now points to the second thread. While the \ufb01rst\nthread is still inside the Critical Section, the second thread arrives. The second thread can immediately continue\ninto the Critical Section!\nTable 7.5: Candidate Solution #4\nTime Turn Thread # 1 Thread # 2\n1 2 Raise my \ufb02ag\n2 2 If your \ufb02ag is raised, wait until my turn Raise my \ufb02ag\n3 2 //Do Critical Section Stuff If your \ufb02ag is raised, wait until my turn (TRUE!)\n4 2 //Do Critical Section Stuff Do Critical Section Stuff - OOPS\n7.5 Working Solutions\nThe \ufb01rst solution to the problem was Dekker\u2019s Solution. Dekker\u2019s Algorithm (1962) was the \ufb01rst provably correct\nsolution. Though, it was in an unpublished paper, so it was not discovered until later [1](this is an English\ntranscribed version released in 1965). A version of the algorithm is below.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2357, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b87d5ee2-641a-4316-b981-c22682295bd3": {"__data__": {"id_": "b87d5ee2-641a-4316-b981-c22682295bd3", "embedding": null, "metadata": {"page_label": "152", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6858ba3d-159f-44ef-b661-651263c7e3b5", "node_type": "4", "metadata": {"page_label": "152", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "245515ce175caffb4a332e38bc1e247e4b4f19bfd0260f75cfa40ef384396207", "class_name": "RelatedNodeInfo"}}, "text": "152 CHAPTER 7. SYNCHRONIZATION\nraise my flag\nwhile (your flag is raised) :\nifit is your turn to win :\nlower my flag\nwait while your turn\nraise my flag\n//DoCritical Section stuff\nset your turn to win\nlower my flag\nNotice how the process\u2019s \ufb02ag is always raised during the critical section no matter if the loop is iterated zero,\nonce or more times. Further, the \ufb02ag can be interpreted as an immediate intent to enter the critical section. Only\nif the other process has also raised the \ufb02ag will one process defer, lower their intent \ufb02ag and wait. Let\u2019s check the\nconditions.\n1.Mutual Exclusion. Let\u2019s try to sketch a simple proof. The loop invariant is that at the start of checking the\ncondition, your \ufb02ag has to be raised \u2013 this is by exhaustion. Since the only way that a thread can leave the\nloop is by having the condition be false, the \ufb02ag must be raised for the entirety of the critical section. Since\nthe loop prevents a thread from exiting while the other thread\u2019s \ufb02ag is raised and a thread has its \ufb02ag raised\nin the critical section, the other thread can\u2019t enter the critical section at the same time.\n2.Bounded Wait. Assuming that the critical section ends in \ufb01nite time, a thread once it has left the critical\nsection cannot then get the critical section back. The reason being is the turn variable is set to the other\nthread, meaning that that thread now has priority . That means a thread cannot be superseded in\ufb01nitely by\nanother thread.\n3.Progress. If the other thread isn\u2019t in the critical section, it will simply continue with a simple check. We didn\u2019t\nmake any statement about if threads are randomly stopped by the system scheduler. This is an idealized\nscenario where threads will keep executing instructions.\n7.5.1 Peterson\u2019s Solution\nPeterson published his novel and surprisingly simple solution in 1981 [2]. A version of his algorithm is shown\nbelow that uses a shared variable turn .\n//Candidate #5\nraise my flag\nturn = other_thread_id\nwhile (your flag is up and turn is other_thread_id)\nloop\n//DoCritical Section stuff\nlower my flag", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2056, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6ab665b3-0d0b-41c4-9a8a-7bc2452bfa45": {"__data__": {"id_": "6ab665b3-0d0b-41c4-9a8a-7bc2452bfa45", "embedding": null, "metadata": {"page_label": "153", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7a739bd0-22f9-4e85-a4f9-0646e4800563", "node_type": "4", "metadata": {"page_label": "153", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8a7149d7920f5fe75ed7f2f16f93a95d750edcb3522b50be8a4d0275124b66f5", "class_name": "RelatedNodeInfo"}}, "text": "7.6. IMPLEMENTING COUNTING SEMAPHORE 153\nThis solution satis\ufb01es Mutual Exclusion, Bounded Wait and Progress. If thread #2 has set turn to 2 and is\ncurrently inside the critical section. Thread #1 arrives, sets the turn back to 1 and now waits until thread 2 lowers\nthe \ufb02ag.\n1.Mutual Exclusion. Let\u2019s try to sketch a simple proof again. A thread doesn\u2019t get into the critical section until\nthe turn variable is yours or the other thread\u2019s \ufb02ag isn\u2019t up. If the other thread\u2019s \ufb02ag isn\u2019t up, it isn\u2019t trying\nto enter the critical section. That is the \ufb01rst action the thread does and the last action the thread undoes. If\nthe turn variable is set to this thread, that means that the other thread has given the control to this thread.\nSince my \ufb02ag is raised and the turn variable is set, the other thread has to wait in the loop until the current\nthread is done.\n2.Bounded Wait. After one thread lowers, a thread waiting in the while loop will leave because the \ufb01rst\ncondition is broken. This means that threads cannot win all the time.\n3.Progress. If no other thread is contesting, other thread\u2019s \ufb02ags are not up. That means that a thread can go\npast the while loop and do critical section items.\nUnfortunately , we can\u2019t implement a software mutex in the same way today because of out of order instructions.\nCheck the appendix for a solution to the problem.\n7.6 Implementing Counting Semaphore\nNow that we have a solution to the critical section problem, We can reasonably implement a mutex. How would\nwe implement other synchronization primitives? Let\u2019s start with a semaphore. To implement a semaphore with\nef\ufb01cient CPU usage, we will say that we have implemented a condition variable. Implementing an O(1) space\ncondition variable using only a mutex is not trivial, or at least an O(1) heap condition variable is not trivial. We\ndon\u2019t want to call malloc while implementing a primitive, or we may deadlock!\n\u2022We can implement a counting semaphore using condition variables.\n\u2022Each semaphore needs a count, a condition variable and a mutex\ntypedef struct sem_t {\nssize_t count ;\npthread_mutex_t m ;\npthread_condition_t cv ;\n}sem_t ;\nImplement sem_init to initialize the mutex and condition variable\nint sem_init(sem_t *s, int pshared, int value) {\nif(pshared) {\nerrno = ENOSYS /*\u2019Not implemented \u2019*/;\nreturn -1;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2309, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0fd0fb93-8547-40e8-abe2-fe7444b3bfc8": {"__data__": {"id_": "0fd0fb93-8547-40e8-abe2-fe7444b3bfc8", "embedding": null, "metadata": {"page_label": "154", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e68fa4c5-c89a-414e-bb92-2820e59103a9", "node_type": "4", "metadata": {"page_label": "154", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "71601779c06807860f409e6fb71f55c7a843ad2754b222aa4f35e963e6ae8da2", "class_name": "RelatedNodeInfo"}}, "text": "154 CHAPTER 7. SYNCHRONIZATION\ns->count = value ;\npthread_mutex_init(&s- >m, NULL) ;\npthread_cond_init(&s- >cv, NULL) ;\nreturn 0;\n}\nOur implementation of sem_post needs to increment the count. We will also wake up any threads sleeping\ninside the condition variable. Notice we lock and unlock the mutex so only one thread can be inside the critical\nsection at a time.\nvoid sem_post(sem_t *s) {\npthread_mutex_lock(&s- >m);\ns->count ++;\npthread_cond_signal(&s- >cv);\n/*Awoken thread must acquire the lock ,soitwill also have towait\nuntil wecall unlock */\npthread_mutex_unlock(&s- >m);\n}\nOur implementation of sem_wait may need to sleep if the semaphore\u2019s count is zero. Just like sem_post ,\nwe wrap the critical section using the lock, so only one thread can be executing our code at a time. Notice if\nthe thread does need to wait then the mutex will be unlocked, allowing another thread to enter sem_post and\nawaken us from our sleep!\nAlso notice that even if a thread is woken up before it returns from pthread_cond_wait , it must re-acquire\nthe lock, so it will have to wait until sem_post \ufb01nishes.\nvoid sem_wait(sem_t *s) {\npthread_mutex_lock(&s- >m);\nwhile (s->count == 0) {\npthread_cond_wait(&s- >cv, &s- >m);/*unlock mutex ,wait ,relock\nmutex */\n}\ns->count-- ;\npthread_mutex_unlock(&s- >m);\n}\nThat is a complete implementation of a counting semaphore Notice that we are calling sem_post every single\ntime. In practice, this means sem_post would unnecessary call pthread_cond_signal even if there are no\nwaiting threads. A more ef\ufb01cient implementation would only call pthread_cond_signal when necessary i.e.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1610, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6c8c11a5-9335-4296-854e-d38f77889450": {"__data__": {"id_": "6c8c11a5-9335-4296-854e-d38f77889450", "embedding": null, "metadata": {"page_label": "155", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "dbeabe24-38d9-4ff1-8221-db3589a23fb3", "node_type": "4", "metadata": {"page_label": "155", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3435eece8fac210228db79b79d196cf98e619e06a9cb81b56dfb063f63b68a30", "class_name": "RelatedNodeInfo"}}, "text": "7.7. BARRIERS 155\n/*Did weincrement from zero toone-time tosignal athread sleeping\ninside sem_post */\nif(s->count == 1) /*Wake upone waiting thread !*/\npthread_cond_signal(&s- >cv);\n7.6.1 Other semaphore considerations\n\u2022A production semaphore implementation may include a queue to ensure fairness and priority . Meaning, we\nwake up the highest-priority and /or longest sleeping thread.\n\u2022An advanced use of sem_init allows semaphores to be shared across processes. Our implementation only\nworks for threads inside the same process. We could \ufb01x this by setting the condition variable and mutex\nattributes.\nImplementing a condition variable with a mutex is complex, so we\u2019ve left that in the appendix.\n7.7 Barriers\nSuppose we wanted to perform a multi-threaded calculation that has two stages, but we don\u2019t want to advance to\nthe second stage until the \ufb01rst stage is completed. We could use a synchronization method called a barrier . When\na thread reaches a barrier, it will wait at the barrier until all the threads reach the barrier, and then they\u2019ll all\nproceed together.\nThink of it like being out for a hike with some friends. You make a mental note of how many friends you have\nand agree to wait for each other at the top of each hill. Say you\u2019re the \ufb01rst one to reach the top of the \ufb01rst hill.\nYou\u2019ll wait there at the top for your friends. One by one, they\u2019ll arrive at the top, but nobody will continue until\nthe last person in your group arrives. Once they do, you\u2019ll all proceed.\nPthreads has a function pthread_barrier_wait() that implements this. You\u2019ll need to declare a pthread_barrier_t\nvariable and initialize it with pthread_barrier_init() .pthread_barrier_init() takes the number of threads\nthat will be participating in the barrier as an argument. Here is a sample program using barriers.\n#define _GNU_SOURCE\n#include <stdio.h >\n#include <stdlib.h >\n#include <unistd.h >\n#include <pthread.h >\n#include <time.h >\n#define THREAD_COUNT 4\npthread_barrier_t mybarrier ;\nvoid * threadFn( void *id_ptr) {\nint thread_id = *( int*)id_ptr ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2048, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9a59bcf2-1690-42c4-a3ee-dcdc6a07eb1e": {"__data__": {"id_": "9a59bcf2-1690-42c4-a3ee-dcdc6a07eb1e", "embedding": null, "metadata": {"page_label": "156", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b255843f-1d69-4fbe-a89f-d4fb76cfc6c3", "node_type": "4", "metadata": {"page_label": "156", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4e7d5d4ab44f181a9d5aa7ef7f20fdb1ae28e19016d2d95efdaa5e8e1670a257", "class_name": "RelatedNodeInfo"}}, "text": "156 CHAPTER 7. SYNCHRONIZATION\nint wait_sec = 1 + rand() % 5 ;\nprintf( \"thread %d:Wait for %dseconds .\\n\", thread_id, wait_sec) ;\nsleep(wait_sec) ;\nprintf( \"thread %d:I\u2019mready ...\\ n\", thread_id) ;\npthread_barrier_wait(&mybarrier) ;\nprintf( \"thread %d:going !\\n\", thread_id) ;\nreturn NULL ;\n}\nint main() {\nint i;\npthread_t ids[THREAD_COUNT] ;\nint short_ids[THREAD_COUNT] ;\nsrand(time(NULL)) ;\npthread_barrier_init(&mybarrier, NULL, THREAD_COUNT + 1) ;\nfor (i=0 ;i<THREAD_COUNT ;i++){\nshort_ids[i] = i ;\npthread_create(&ids[i], NULL, threadFn, &short_ids[i]) ;\n}\nprintf( \"main ()isready .\\n\");\npthread_barrier_wait(&mybarrier) ;\nprintf( \"main ()isgoing !\\n\");\nfor (i=0 ;i<THREAD_COUNT ;i++){\npthread_join(ids[i], NULL) ;\n}\npthread_barrier_destroy(&mybarrier) ;\nreturn 0;\n}\nNow let\u2019s implement our own barrier and use it to keep all the threads in sync in a large calculation. Here is\nour thought process,\n1.Threads do \ufb01rst calculation (use and change values in data)\n2.Barrier! Wait for all threads to \ufb01nish \ufb01rst calculation before continuing\n3.Threads do second calculation (use and change values in data)", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1105, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ef4d6e32-ee49-40da-8ea6-de0126ebc7cc": {"__data__": {"id_": "ef4d6e32-ee49-40da-8ea6-de0126ebc7cc", "embedding": null, "metadata": {"page_label": "157", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5342c86e-c4f6-4594-9a01-ecb17f9b248b", "node_type": "4", "metadata": {"page_label": "157", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "115612a7613b80e379701d4b36071330853ce083584a2cf6a31d602081168547", "class_name": "RelatedNodeInfo"}}, "text": "7.7. BARRIERS 157\nThe thread function has four main parts-\n//double data [256][8192]\nvoid *calc( void *arg) {\n/*Domypart ofthe first calculation */\n/*Isthis the last thread tofinish ?Ifsowake upall the other\nthreads !*/\n/*Otherwise wait until the other threads have finished part one */\n/*Domypart ofthe second calculation */\n}\nOur main thread will create the 16 threads, and we will divide each calculation into 16 separate pieces. Each\nthread will be given a unique value (0,1,2,..15), so it can work on its own block. Since a (void*) type can hold\nsmall integers, we will pass the value of iby casting it to a void pointer.\n#define N (16)\ndouble data[256][8192] ;\nint main() {\npthread_t ids[N] ;\nfor(int i = 0 ;i<N;i++){\npthread_create(&ids[i], NULL, calc, ( void *) i) ;\n}\n//...\n}\nNote, we will never dereference this pointer value as an actual memory location.\nWe will cast it straight back to an integer.\nvoid *calc( void *ptr) {\n//Thread 0will work onrows 0..15, thread 1onrows 16..31\nint x, y, start = N * ( int) ptr ;\nint end = start + N ;\nfor(x = start ;x<end;x++){\nfor (y = 0 ;y<8192 ;y++){\n/*docalc #1*/\n}\n}\n}\nAfter calculation 1 completes, we need to wait for the slower threads unless we are the last thread! So, keep\ntrack of the number of threads that have arrived at our barrier \u2018checkpoint\u2019.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1309, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04270f5b-207f-46eb-93c7-f761b3db6743": {"__data__": {"id_": "04270f5b-207f-46eb-93c7-f761b3db6743", "embedding": null, "metadata": {"page_label": "158", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "50788a88-2280-4b4e-b0d3-30e0cabc936c", "node_type": "4", "metadata": {"page_label": "158", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "3d9aa71f77b4ef63cdb40777e0ae58fee5718e93d2634d9fdc77a4fe79f28dd4", "class_name": "RelatedNodeInfo"}}, "text": "158 CHAPTER 7. SYNCHRONIZATION\n//Global :\nint remain = N ;\n//After calc #1code :\nremain-- ;//Wefinished\nif(remain == 0) {/*I\u2019mlast !-Time for everyone towake up!*/}\nelse {\nwhile (remain != 0) {/*spin spin spin */}\n}\nHowever, the code has a few \ufb02aws. One is two threads might try to decrement remain . The other is the loop\nis a busy loop. We can do better! Let\u2019s use a condition variable and then we will use a broadcast /signal functions\nto wake up the sleeping threads.\nA reminder, a condition variable is similar to a house! Threads go there to sleep ( pthread_cond_wait ). A\nthread can choose to wake up one thread ( pthread_cond_signal ) or all of them ( pthread_cond_broadcast ).\nIf there are no threads currently waiting then these two calls have no effect.\nA condition variable version is usually similar to a busy loop incorrect solution - as we will show next. First,\nlet\u2019s add a mutex and condition global variables and don\u2019t forget to initialize them in main .\n//global variables\npthread_mutex_t m ;\npthread_cond_t cv ;\nint main() {\npthread_mutex_init(&m, NULL) ;\npthread_cond_init(&cv, NULL) ;\nWe will use the mutex to ensure that only one thread modi\ufb01es remain at a time. The last arriving thread needs\nto wake up allsleeping threads - so we will use pthread_cond_broadcast(cv) notpthread_cond_signal\npthread_mutex_lock(&m) ;\nremain-- ;\nif(remain == 0) {\npthread_cond_broadcast(&cv) ;\n}\nelse {\nwhile (remain != 0) {\npthread_cond_wait(&cv, &m) ;\n}\n}\npthread_mutex_unlock(&m) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1489, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "435b4035-f184-4fe5-8a29-79c637b3c590": {"__data__": {"id_": "435b4035-f184-4fe5-8a29-79c637b3c590", "embedding": null, "metadata": {"page_label": "159", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "93db66c9-b14f-40ed-bcb4-cf5710d62d8f", "node_type": "4", "metadata": {"page_label": "159", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8ca851a00e0642a01eb2b0a1204d60a3b6b25245f9b22976753ccdbb7a72cf62", "class_name": "RelatedNodeInfo"}}, "text": "7.7. BARRIERS 159\nWhen a thread enters pthread_cond_wait , it releases the mutex and sleeps. After, the thread will be woken\nup. Once we bring a thread back from its sleep, before returning it must wait until it can lock the mutex. Notice\nthat even if a sleeping thread wakes up early , it will check the while loop condition and re-enter wait if necessary .\nThe above barrier is not reusable . Meaning that if we stick it into any old calculation loop there is a good\nchance that the code will encounter a condition where the barrier either deadlocks or thread races ahead one\niteration faster. Why is that? Because of the ambitious thread.\nWe will assume that one thread is much faster than all the other threads. With the barrier API, this thread\nshould be waiting, but it may not be. To make it concrete, let\u2019s look at this code\nvoid barrier_wait(barrier *b) {\npthread_mutex_lock(&b- >m);\n//Ifitis0before decrement ,weshould beon\n//another iteration right ?\nif(b->remain == 0) b- >remain = NUM_THREADS ;\nb->remain-- ;\nif(b->remain == 0) {\npthread_cond_broadcast(&cv) ;\n}\nelse {\nwhile (b->remain != 0) {\npthread_cond_wait(&cv, &m) ;\n}\n}\npthread_mutex_unlock(&b- >m);\n}\nfor (/*... */){\n//Some calc\nbarrier_wait(b) ;\n}\nWhat happens if a thread becomes ambitious. Well\n1.Many other threads wait on the condition variable\n2.The last thread broadcasts.\n3.A single thread leaves the while loop.\n4.This single thread performs its calculation before any other threads even wake up\n5.Reset the number of remaining threads and goes back to sleep.\nAll the other threads who should\u2019ve woken up never do and our implementation deadlocks. How would you\ngo about solving this? Hint: If multiple threads call barrier_wait in a loop then one can guarantee that they\nare on the same iteration.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1778, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b37fec70-4122-4ccb-b0d4-83715c08b2e3": {"__data__": {"id_": "b37fec70-4122-4ccb-b0d4-83715c08b2e3", "embedding": null, "metadata": {"page_label": "160", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4b52f1c5-74b9-4641-8048-2a73c819321d", "node_type": "4", "metadata": {"page_label": "160", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7c84d722047b238ad0ec19518063e6d27618153a0b02387507c3536843da9e79", "class_name": "RelatedNodeInfo"}}, "text": "160 CHAPTER 7. SYNCHRONIZATION\n7.7.1 Reader Writer Problem\nImagine you had a key-value map data structure that is used by many threads. Multiple threads should be able to\nlook up (read) values at the same time provided the data structure is not being written to. The writers are not so\ngregarious. To avoid data corruption, only one thread at a time may modify ( write ) the data structure and no\nreaders may be reading at that time.\nThis is an example of the Reader Writer Problem . Namely , how can we ef\ufb01ciently synchronize multiple readers\nand writers such that multiple readers can read together, but a writer gets exclusive access?\nAn incorrect attempt is shown below (\u201clock\u201d is a shorthand for pthread_mutex_lock ):\n7.7.2 Attempt #1\nvoid read() {\nlock(&m)\n//doread stuff\nunlock(&m)\n}\nvoid write() {\nlock(&m)\n//dowrite stuff\nunlock(&m)\n}\nAt least our \ufb01rst attempt does not suffer from data corruption. Readers must wait while a writer is writing and\nvice versa! However, readers must also wait for other readers. Let\u2019s try another implementation.\n7.7.3 Attempt #2:\nvoid read() {\nwhile (writing) {/*spin */}\nreading = 1\n//doread stuff\nreading = 0\n}\nvoid write() {\nwhile (reading || writing) {/*spin */}\nwriting = 1\n//dowrite stuff\nwriting = 0", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1247, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9871f313-e4c1-4c77-8b12-6e1c5f7943b5": {"__data__": {"id_": "9871f313-e4c1-4c77-8b12-6e1c5f7943b5", "embedding": null, "metadata": {"page_label": "161", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e931c90e-c109-435e-80f4-63f676108ddd", "node_type": "4", "metadata": {"page_label": "161", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "4fcac2d4e2c15092a36e49cc27ac523de220b392a720ca6fc95f44f986021720", "class_name": "RelatedNodeInfo"}}, "text": "7.7. BARRIERS 161\n}\nOur second attempt suffers from a race condition. Imagine if two threads both called read andwrite or both\ncalled write at the same time. Both threads would be able to proceed! Secondly , we can have multiple readers\nand multiple writers, so let\u2019s keep track of the total number of readers or writers Which brings us to attempt #3.\n7.7.4 Attempt #3\nRemember that pthread_cond_wait performs Three actions. Firstly , it atomically unlocks the mutex and then\nsleeps (until it is woken by pthread_cond_signal orpthread_cond_broadcast ). Thirdly , the awoken thread\nmust re-acquire the mutex lock before returning. Thus only one thread can actually be running inside the critical\nsection de\ufb01ned by the lock and unlock() methods.\nImplementation #3 below ensures that a reader will enter the cond_wait if any writers are writing.\nread() {\nlock(&m)\nwhile (writing)\ncond_wait(&cv, &m)\nreading ++;\n/*Read here !*/\nreading--\ncond_signal(&cv)\nunlock(&m)\n}\nHowever, only one reader a time can read because candidate #3 did not unlock the mutex. A better version\nunlocks before reading.\nread() {\nlock(&m) ;\nwhile (writing)\ncond_wait(&cv, &m)\nreading ++;\nunlock(&m)\n/*Read here !*/\nlock(&m)\nreading--\ncond_signal(&cv)\nunlock(&m)", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1233, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "abf92290-8f8b-459d-8900-f4ae73097e04": {"__data__": {"id_": "abf92290-8f8b-459d-8900-f4ae73097e04", "embedding": null, "metadata": {"page_label": "162", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "141dfc70-0054-487b-ba69-abaa0c4c07bf", "node_type": "4", "metadata": {"page_label": "162", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f4ca76cbff206c9dd5ebbff50639952e64b74e19049f74c0f7fd4433bd060067", "class_name": "RelatedNodeInfo"}}, "text": "162 CHAPTER 7. SYNCHRONIZATION\n}\nDoes this mean that a writer and read could read and write at the same time? No! First of all, remember\ncond_wait requires the thread re-acquire the mutex lock before returning. Thus only one thread can be executing\ncode inside the critical section (marked with **) at a time!\nread() {\nlock(&m) ;\n**while (writing)\n** cond_wait(&cv, &m)\n** reading ++;\nunlock(&m)\n/*Read here !*/\nlock(&m)\n** reading--\n** cond_signal(&cv)\nunlock(&m)\n}\nWriters must wait for everyone. Mutual exclusion is assured by the lock.\nwrite() {\nlock(&m) ;\n**while (reading || writing)\n** cond_wait(&cv, &m) ;\n** writing ++;\n**\n**/*Write here !*/\n** writing-- ;\n** cond_signal(&cv) ;\nunlock(&m) ;\n}\nCandidate #3 above also uses pthread_cond_signal . This will only wake up one thread. If many readers\nare waiting for the writer to complete, only one sleeping reader will be awoken from their slumber. The reader\nand writer should use cond_broadcast so that all threads should wake up and check their while-loop condition.\n7.7.5 Starving writers\nCandidate #3 above suffers from starvation. If readers are constantly arriving then a writer will never be able to\nproceed (the \u2018reading\u2019 count never reduces to zero). This is known as starvation and would be discovered under\nheavy loads. Our \ufb01x is to implement a bounded-wait for the writer. If a writer arrives they will still need to wait", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1390, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "17b69e14-978a-439f-964b-173695a81a68": {"__data__": {"id_": "17b69e14-978a-439f-964b-173695a81a68", "embedding": null, "metadata": {"page_label": "163", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6a1bd7c6-3f1c-40ef-8f7a-8ecb8a6d117e", "node_type": "4", "metadata": {"page_label": "163", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "ed06526524ee77ca8858802597fe4e45a0c3f16816faa888f33c10340eb31ad2", "class_name": "RelatedNodeInfo"}}, "text": "7.7. BARRIERS 163\nfor existing readers however future readers must be placed in a \u201cholding pen\u201d and wait for the writer to \ufb01nish.\nThe \u201cholding pen\u201d can be implemented using a variable and a condition variable so that we can wake up the\nthreads once the writer has \ufb01nished.\nThe plan is that when a writer arrives, and before waiting for current readers to \ufb01nish, register our intent to\nwrite by incrementing a counter \u2018writer\u2019\nwrite() {\nlock()\nwriter ++\nwhile (reading || writing)\ncond_wait\nunlock()\n...\n}\nAnd incoming readers will not be allowed to continue while writer is nonzero. Notice \u2018writer\u2019 indicates a writer\nhas arrived, while \u2018reading\u2019 and \u2018writing\u2019 counters indicate there is an active reader or writer.\nread() {\nlock()\n//readers that arrive *after *the writer arrived will have towait\nhere !\nwhile (writer)\ncond_wait(&cv,&m)\n//readers that arrive while there isanactive writer\n//will also wait .\nwhile (writing)\ncond_wait(&cv,&m)\nreading ++\nunlock\n...\n}\n7.7.6 Attempt #4\nBelow is our \ufb01rst working solution to the Reader-Writer problem. Note if you continue to read about the \u201cReader\nWriter problem\u201d then you will discover that we solved the \u201cSecond Reader Writer problem\u201d by giving writers\npreferential access to the lock. This solution is not optimal. However, it satis\ufb01es our original problem of N active\nreaders, single active writer, and avoiding starvation of the writer if there is a constant stream of readers.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1430, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "54bb80c8-d30b-408b-b3ed-efd1b50e5502": {"__data__": {"id_": "54bb80c8-d30b-408b-b3ed-efd1b50e5502", "embedding": null, "metadata": {"page_label": "164", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d7b2d760-9668-494a-8e8f-af6f7c53f00b", "node_type": "4", "metadata": {"page_label": "164", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "dbd87a19865f10f58fd2a1a3c527f7df7ba133af1c9e9c75135417d2501ade6a", "class_name": "RelatedNodeInfo"}}, "text": "164 CHAPTER 7. SYNCHRONIZATION\nCan you identify any improvements? For example, how would you improve the code so that we only woke up\nreaders or one writer?\nint writers ;//Number writer threads that want toenter the critical\nsection (some orall ofthese may beblocked )\nint writing ;//Number ofthreads that are actually writing inside the\nC.S.(can only bezero orone)\nint reading ;//Number ofthreads that are actually reading inside the\nC.S.\n//ifwriting !=0 then reading must bezero (and vice versa )\nreader() {\nlock(&m)\nwhile (writers)\ncond_wait(&turn, &m)\n//Noneed towait while (writing here )because wecan only exit the\nabove loop\n//when writing iszero\nreading ++\nunlock(&m)\n//perform reading here\nlock(&m)\nreading--\ncond_broadcast(&turn)\nunlock(&m)\n}\nwriter() {\nlock(&m)\nwriters ++\nwhile (reading || writing)\ncond_wait(&turn, &m)\nwriting ++\nunlock(&m)\n//perform writing here\nlock(&m)\nwriting--\nwriters--\ncond_broadcast(&turn)\nunlock(&m)\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 940, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "60de55e1-e51e-4b81-8ea7-946d54350255": {"__data__": {"id_": "60de55e1-e51e-4b81-8ea7-946d54350255", "embedding": null, "metadata": {"page_label": "165", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bb094c39-8be6-40ed-9575-dfb2ca8e9cfb", "node_type": "4", "metadata": {"page_label": "165", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c342fd663507851858c584c85491be4a8a36d7edf99382043d05c55a94c204b0", "class_name": "RelatedNodeInfo"}}, "text": "7.8. RING BUFFER 165\n1514\n13\n120\n11\n10\n987654321C\nD\nE\nFbu\ner[out]\nbu\ner[in]\nFigure 7.1: Ring Buffer Visualization\n7.8 Ring Buffer\nA ring buffer is a simple, usually \ufb01xed-sized, storage mechanism where contiguous memory is treated as if it is\ncircular, and two index counters keep track of the current beginning and end of the queue. As array indexing is\nnot circular, the index counters must wrap around to zero when moved past the end of the array . As data is added\n(enqueued) to the front of the queue or removed (dequeued) from the tail of the queue, the current items in the\nbuffer form a train that appears to circle the track\nA simple (single-threaded) implementation is shown below. Note, enqueue and dequeue do not guard against\nunder\ufb02ow or over\ufb02ow. It\u2019s possible to add an item when the queue is full and possible to remove an item when\nthe queue is empty . If we added 20 integers (1, 2, 3, . . . , 20) to the queue and did not dequeue any items then\nvalues, 17,18,19,20 would overwrite the 1,2,3,4 . We won\u2019t \ufb01x this problem right now, instead of when we\ncreate the multi-threaded version we will ensure enqueue-ing and dequeue-ing threads are blocked while the ring\nbuffer is full or empty respectively .\nvoid *buffer[16] ;\nunsigned int in = 0, out = 0 ;\nvoid enqueue( void *value) {/*Add one item tothe front ofthe queue */\nbuffer[in] = value ;\nin++;/*Advance the index for next time */\nif(in == 16) in = 0 ;/*Wrap around !*/\n}\nvoid *dequeue() {/*Remove one item tothe end ofthe queue .*/\nvoid *result = buffer[out] ;\nout++;\nif(out == 16) out = 0 ;\nreturn result ;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1580, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bea2fead-015b-49a8-9613-f57bc9165a89": {"__data__": {"id_": "bea2fead-015b-49a8-9613-f57bc9165a89", "embedding": null, "metadata": {"page_label": "166", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "09bfd729-7e4c-4dc6-8c49-4e6bd9f34a97", "node_type": "4", "metadata": {"page_label": "166", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "1d35b5e0f08679bf67029c6476a3228c5a24550b7e898255503bb6a12b8540eb", "class_name": "RelatedNodeInfo"}}, "text": "166 CHAPTER 7. SYNCHRONIZATION\n7.8.1 Ring Buffer Gotchas\nIt\u2019s tempting to write the enqueue or dequeue method in the following compact form.\n//Nisthe capacity ofthe buffer\nvoid enqueue( void *value)\nb[ (in ++) % N ] = value ;\n}\nThis method would appear to work but contains a subtle bug. With more than four billion enqueue operations,\nthe int value of inwill over\ufb02ow and wrap around to 0! Thus, you might end up writing into b[0] for example!\nA compact form is correct uses bit masking provided N is a power of two. (16,32,64,. . . )\nb[ (in ++) & (N-1) ] = value ;\nThis buffer does not yet prevent overwrites. For that, we\u2019ll turn to our multi-threaded attempt that will block a\nthread until there is space or there is at least one item to remove.\n7.8.2 Multithreaded Correctness\nThe following code is an incorrect implementation. What will happen? Will enqueue and/ordequeue block? Is\nmutual exclusion satis\ufb01ed? Can the buffer under\ufb02ow? Can the buffer over\ufb02ow? For clarity , pthread_mutex is\nshortened to p_mand we assume sem_wait cannot be interrupted.\n#define N 16\nvoid *b[N]\nint in = 0, out = 0\np_m_t lock\nsem_t s1,s2\nvoid init() {\np_m_init(&lock, NULL)\nsem_init(&s1, 0, 16)\nsem_init(&s2, 0, 0)\n}\nenqueue( void *value) {\np_m_lock(&lock)\n//Hint :Wait while zero .Decrement and return\nsem_wait( &s1 )\nb[ (in ++) & (N-1) ] = value", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1332, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d9134d78-b28b-49a1-8779-cad4bc172302": {"__data__": {"id_": "d9134d78-b28b-49a1-8779-cad4bc172302", "embedding": null, "metadata": {"page_label": "167", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "796abaf7-a83b-4a50-8494-12b9a0b3f009", "node_type": "4", "metadata": {"page_label": "167", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "cbf79c061f4210c8132c991e9d9526d36856d9691e7fa348e51445e6d6ba8fa0", "class_name": "RelatedNodeInfo"}}, "text": "7.8. RING BUFFER 167\n//Hint :Increment .Will wake upawaiting thread\nsem_post(&s1)\np_m_unlock(&lock)\n}\nvoid *dequeue() {\np_m_lock(&lock)\nsem_wait(&s2)\nvoid *result = b[(out ++) & (N-1) ]\nsem_post(&s2)\np_m_unlock(&lock)\nreturn result\n}\n7.8.3 Analysis\nBefore reading on, see how many mistakes you can \ufb01nd. Then determine what would happen if threads called the\nenqueue and dequeue methods.\n\u2022The enqueue method waits and posts on the same semaphore (s1) and similarly with enqueue and (s2)\ni.e. we decrement the value and then immediately increment the value, so by the end of the function the\nsemaphore value is unchanged!\n\u2022The initial value of s1 is 16, so the semaphore will never be reduced to zero - enqueue will not block if the\nring buffer is full - so over\ufb02ow is possible.\n\u2022The initial value of s2 is zero, so calls to dequeue will always block and never return!\n\u2022The order of mutex lock and sem_wait will need to be swapped; however, this example is so broken that\nthis bug has no effect!\n7.8.4 Another Analysis\nThe following code is an incorrect implementation. What will happen? Will enqueue and/ordequeue block? Is\nmutual exclusion satis\ufb01ed? Can the buffer under\ufb02ow? Can the buffer over\ufb02ow? For clarity pthread_mutex is\nshortened to p_mand we assume sem_wait cannot be interrupted.\nvoid *b[16]\nint in = 0, out = 0\np_m_t lock\nsem_t s1, s2\nvoid init() {\nsem_init(&s1,0,16)\nsem_init(&s2,0,0)\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1398, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "35fb3914-4223-437c-a1c1-89bf3d3aa68e": {"__data__": {"id_": "35fb3914-4223-437c-a1c1-89bf3d3aa68e", "embedding": null, "metadata": {"page_label": "168", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0a76efa1-c7ee-4930-99e2-6295784ad09e", "node_type": "4", "metadata": {"page_label": "168", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "e7dc706de69993114be8953c758f9d052ad8e275d611ccf8199f54a0c8a26f9b", "class_name": "RelatedNodeInfo"}}, "text": "168 CHAPTER 7. SYNCHRONIZATION\nenqueue( void *value) {\nsem_wait(&s2)\np_m_lock(&lock)\nb[ (in ++) & (N-1) ] = value\np_m_unlock(&lock)\nsem_post(&s1)\n}\nvoid *dequeue() {\nsem_wait(&s1)\np_m_lock(&lock)\nvoid *result = b[(out ++) & (N-1)]\np_m_unlock(&lock)\nsem_post(&s2)\nreturn result ;\n}\nHere are a few problems that we hope you\u2019ve found.\n\u2022The initial value of s2 is 0. Thus enqueue will block on the \ufb01rst call to sem_wait even though the buffer is\nempty!\n\u2022The initial value of s1 is 16. Thus dequeue will not block on the \ufb01rst call to sem_wait even though the buffer\nis empty - Under\ufb02ow! The dequeue method will return invalid data.\n\u2022The code does not satisfy Mutual Exclusion. Two threads can modify inoroutat the same time! The code\nappears to use mutex lock. Unfortunately , the lock was never initialized with pthread_mutex_init() or\nPTHREAD_MUTEX_INITIALIZER - so the lock may not work ( pthread_mutex_lock may simply do nothing)\n7.8.5 Correct implementation of a ring buffer\nAs the mutex lock is stored in global (static) memory it can be initialized with PTHREAD_MUTEX_INITIALIZER . If\nwe had allocated space for the mutex on the heap, then we would have used pthread_mutex_init(ptr, NULL)\n#include <pthread.h >\n#include <semaphore.h >\n//Nmust be2^i\n#define N (16)\nvoid *b[N]\nint in = 0, out = 0\np_m_t lock = PTHREAD_MUTEX_INITIALIZER", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1335, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bbfe787b-8334-4aef-8b19-4d57d7ef6e3a": {"__data__": {"id_": "bbfe787b-8334-4aef-8b19-4d57d7ef6e3a", "embedding": null, "metadata": {"page_label": "169", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5854b555-e73c-4661-ac22-519badc131ce", "node_type": "4", "metadata": {"page_label": "169", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "7728eae40165a0bddac4c6180877bc43f1a98cb159338004691090057bf29833", "class_name": "RelatedNodeInfo"}}, "text": "7.8. RING BUFFER 169\nsem_t countsem, spacesem\nvoid init() {\nsem_init(&countsem, 0, 0)\nsem_init(&spacesem, 0, 16)\n}\nThe enqueue method is shown below. Make sure to note.\n1.The lock is only held during the critical section (access to the data structure).\n2.A complete implementation would need to guard against early returns from sem_wait due to POSIX signals.\nenqueue( void *value) {\n//wait ifthere isnospace left :\nsem_wait( &spacesem )\np_m_lock(&lock)\nb[ (in ++) & (N-1) ] = value\np_m_unlock(&lock)\n//increment the count ofthe number ofitems\nsem_post(&countsem)\n}\nThedequeue implementation is shown below. Notice the symmetry of the synchronization calls to enqueue .\nIn both cases, the functions \ufb01rst wait if the count of spaces or count of items is zero.\nvoid *dequeue() {\n//Wait ifthere are noitems inthe buffer\nsem_wait(&countsem)\np_m_lock(&lock)\nvoid *result = b[(out ++) & (N-1)]\np_m_unlock(&lock)\n//Increment the count ofthe number ofspaces\nsem_post(&spacesem)\nreturn result\n}\nFood for thought:", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1002, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bc3cbcdc-b8cb-4433-ba0d-1cfeabfb28da": {"__data__": {"id_": "bc3cbcdc-b8cb-4433-ba0d-1cfeabfb28da", "embedding": null, "metadata": {"page_label": "170", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e9276e96-4fea-4383-a464-5876d3bcfa28", "node_type": "4", "metadata": {"page_label": "170", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "6c89b6aab13b619305252d0ed54a3f777a5018e679d804b7375f7b7ae36aafb2", "class_name": "RelatedNodeInfo"}}, "text": "170 CHAPTER 7. SYNCHRONIZATION\n\u2022What would happen if the order of pthread_mutex_unlock andsem_post calls were swapped?\n\u2022What would happen if the order of sem_wait andpthread_mutex_lock calls were swapped?\n7.9 Extra: Process Synchronization\nYou thought that you were using different processes, so you don\u2019t have to synchronize? Think again! You may not\nhave race conditions within a process but what if your process needs to interact with the system around it? Let\u2019s\nconsider a motivating example\nvoid write_string( const char *data) {\nint fd = open( \"my_file .txt\", O_WRONLY) ;\nwrite(fd, data, strlen(data)) ;\nclose(fd) ;\n}\nint main() {\nif(!fork()) {\nwrite_string( \"key1 :value1 \");\nwait(NULL) ;\n}else {\nwrite_string( \"key2 :value2 \");\n}\nreturn 0;\n}\nIf none of the system calls fail then we should get something that looks like this given the \ufb01le was empty to\nbegin with.\nkey1: value1\nkey2: value2\nkey2: value2\nkey1: value1", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 923, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8dde49a8-13cc-4270-a51c-4c08049909b7": {"__data__": {"id_": "8dde49a8-13cc-4270-a51c-4c08049909b7", "embedding": null, "metadata": {"page_label": "171", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3890bc5e-c149-4fab-8844-d6444f43e232", "node_type": "4", "metadata": {"page_label": "171", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d915a93bb5961fbca659629f8bdd3ab9ddb554ee60f3f0c39d8611f7b6cd3747", "class_name": "RelatedNodeInfo"}}, "text": "7.9. EXTRA: PROCESS SYNCHRONIZATION 171\n7.9.1 Interruption\nBut, there is a hidden nuance. Most system calls can be interrupted meaning that the operating system can\nstop an ongoing system call because it needs to stop the process. So barring fork wait open andclose from\nfailing \u2013 they typically go to completion \u2013 what happens if write fails? If write fails and no bytes are written, we\ncan get something like key1: value1 orkey2: value2 . This is data loss which is incorrect but won\u2019t corrupt\nthe \ufb01le. What happens if write gets interrupted after a partial write? We get all sorts of madness. For example,\nkey2: key1: value1\n7.9.2 Solution\nA program can create a mutex before fork-ing - however the child and parent process will not share virtual memory\nand each one will have a mutex independent of the other. Advanced note: There are advanced options using\nshared memory that allow a child and parent to share a mutex if it\u2019s created with the correct options and uses a\nshared memory segment. See stackover\ufb02ow example\nSo what should we do? We should use a shared mutex! Consider the following code.\npthread_mutex_t * mutex = NULL ;\npthread_mutexattr_t attr ;\nvoid write_string( const char *data) {\npthread_mutex_lock(mutex) ;\nint fd = open( \"my_file .txt\", O_WRONLY) ;\nint bytes_to_write = strlen(data), written = 0 ;\nwhile (written <bytes_to_write) {\nwritten += write(fd, data + written, bytes_to_write - written) ;\n}\nclose(fd) ;\npthread_mutex_unlock(mutex) ;\n}\nint main() {\npthread_mutexattr_init(&attr) ;\npthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED) ;\npmutex = mmap (NULL, sizeof (pthread_mutex_t),\nPROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0) ;\npthread_mutex_init(pmutex, &attrmutex) ;\nif(!fork()) {\nwrite_string( \"key1 :value1 \");\nwait(NULL) ;\npthread_mutex_destroy(pmutex) ;\npthread_mutexattr_destroy(&attrmutex) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1845, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f8e15691-4060-401a-953b-67af8d6a64e4": {"__data__": {"id_": "f8e15691-4060-401a-953b-67af8d6a64e4", "embedding": null, "metadata": {"page_label": "172", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0f4062a4-9e47-4ce5-82a8-7b871e60bea0", "node_type": "4", "metadata": {"page_label": "172", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "69633c79aecfc4bf14f576704bc9e43bb0da6cf73cdf4d30e50384bc8cb9d50f", "class_name": "RelatedNodeInfo"}}, "text": "172 CHAPTER 7. SYNCHRONIZATION\nmunmap(( void *)pmutex, sizeof (*pmutex)) ;\n}else {\nwrite_string( \"key2 :value2 \");\n}\nreturn 0;\n}\nWhat the code does in main is initialize a process shared mutex using a piece of shared memory . You will \ufb01nd\nout what this call to mmap does later \u2013 assume for the time being that it creates memory that is shared between\nprocesses. We can initialize a pthread_mutex_t in that special piece of memory and use it as normal. To counter\nwrite failing, we have put the write call inside a while loop that keeps writing so long as there are bytes left to\nwrite. Now if all the other system calls function, there should be more race conditions.\nMost programs try to avoid this problem entirely by writing to separate \ufb01les, but it is good to know that there\nare mutexes across processes, and they are useful. A program can use all of the primitives that were mentioned\npreviouslty! Barriers, semaphores, and condition variables can all be initialized on a shared piece of memory and\nused in similar ways to their multithreading counterparts.\n\u2022You don\u2019t have to worry about arbitrary memory addresses becoming race condition candidates. Only areas\nthat speci\ufb01cally mapped are in danger.\n\u2022You get the nice isolation of processes so if one process fails the system can maintain intact.\n\u2022When you have a lot of threads, creating a process might ease the system load\nThere are other ways to synchronize as well, check out goroutines or higher orders of synchronization in the\nappendix.\n7.10 External Resources\nGuiding questions for the man pages\n\u2022How is a recursive mutex different than a default mutex?\n\u2022How is mutex trylock different than mutex lock?\n\u2022Why would a mutex lock fail? What\u2019s an example?\n\u2022What happens if a thread tries to destroy a locked mutex?\n\u2022Can a thread copy the underlying bytes of a mutex instead of using a pointer?\n\u2022What is the lifecycle of a semaphore?\n\u2022pthread_mutex_lock man page\n\u2022pthread_mutex_init man page\n\u2022sem_init\n\u2022sem_wait\n\u2022sem_post\n\u2022sem_destroy", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1996, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bba7c29d-2ea1-411f-be51-3d4b357d4d29": {"__data__": {"id_": "bba7c29d-2ea1-411f-be51-3d4b357d4d29", "embedding": null, "metadata": {"page_label": "173", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2dff44f0-219e-48ff-9041-a33b8a37d2ee", "node_type": "4", "metadata": {"page_label": "173", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9c98bfa5db70b433c4a86a1012834b266b38a9f518722d0082962a58d621ab5b", "class_name": "RelatedNodeInfo"}}, "text": "7.11. TOPICS 173\n7.11 Topics\n\u2022Atomic operations\n\u2022Critical Section\n\u2022Producer Consumer Problem\n\u2022Using Condition Variables\n\u2022Using Counting Semaphore\n\u2022Implementing a barrier\n\u2022Implementing a ring buffer\n\u2022Using pthread_mutex\n\u2022Implementing producer consumer\n\u2022Analyzing multi-threaded coded\n7.12 Questions\n\u2022What is atomic operation?\n\u2022Why will the following not work in parallel code\n//Inthe global section\nsize_t a ;\n//Inpthread function\nfor(int i = 0 ;i<100000000 ;i++) a++;\nAnd this will?\n//Inthe global section\natomic_size_t a ;\n//Inpthread function\nfor(int i = 0 ;i<100000000 ;i++) atomic_fetch_add(a, 1) ;\n\u2022What are some downsides to atomic operations? What would be faster: keeping a local variable or many\natomic operations?\n\u2022What is the critical section?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 754, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cd97072e-0bb0-4f90-a57b-c86930656291": {"__data__": {"id_": "cd97072e-0bb0-4f90-a57b-c86930656291", "embedding": null, "metadata": {"page_label": "174", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2b9f704a-3e4b-4d63-84e2-84310f2675b8", "node_type": "4", "metadata": {"page_label": "174", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "f2f6cff2db2005785659a22bf782766132e58d165bffa071710676966b8dec82", "class_name": "RelatedNodeInfo"}}, "text": "174 CHAPTER 7. SYNCHRONIZATION\n\u2022Once you have identi\ufb01ed a critical section, what is one way of assuring that only one thread will be in the\nsection at a time?\n\u2022Identify the critical section here\nstruct linked_list ;\nstruct node ;\nvoid add_linked_list(linked_list *ll, void * elem) {\nnode* packaged = new_node(elem) ;\nif(ll- >head) {\nll->head =\n}else {\npackaged- >next = ll- >head ;\nll->head = packaged ;\nll->size ++;\n}\n}\nvoid * pop_elem(linked_list *ll, size_t index) {\nif(index >= ll- >size) return NULL ;\nnode *i, *prev ;\nfor(i = ll- >head ;i && index ;i = i- >next, index--) {\nprev = i ;\n}\n//ipoints tothe element weneed topop,prev before\nif(prev- >next) prev- >next = prev- >next- >next ;\nll->size-- ;\nvoid * elem = i- >elem ;\ndestroy_node(i) ;\nreturn elem ;\n}\n\u2022How tight can you make the critical section?\n\u2022What is a producer consumer problem? How might the above be a producer consumer problem be used in\nthe above section? How is a producer consumer problem related to a reader writer problem?\n\u2022What is a condition variable? Why is there an advantage to using one over a while loop?\n\u2022Why is this code dangerous?\nif(not_ready) {\npthread_cond_wait(&cv, &mtx) ;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1167, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4672f06b-ba93-4364-84f8-9d706787bdde": {"__data__": {"id_": "4672f06b-ba93-4364-84f8-9d706787bdde", "embedding": null, "metadata": {"page_label": "175", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "20cbb7c1-cc96-4ad3-8ff3-e25288a11f87", "node_type": "4", "metadata": {"page_label": "175", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "240916a63e69e81240ca9c6098dc34f7980ad901e6985b9a9b47964a821b632a", "class_name": "RelatedNodeInfo"}}, "text": "7.12. QUESTIONS 175\n\u2022What is a counting semaphore? Give me an analogy to a cookie jar /pizza box /limited food item.\n\u2022What is a thread barrier?\n\u2022Use a counting semaphore to implement a barrier.\n\u2022Write up a Producer /Consumer queue, How about a producer consumer stack?\n\u2022Give me an implementation of a reader-writer lock with condition variables, make a struct with whatever\nyou need, it needs to be able to support the following functions\ntypedef struct {\n}rw_lock_t ;\nvoid reader_lock(rw_lock_t* lck) {\n}\nvoid writer_lock(rw_lock_t* lck) {\n}\nvoid reader_unlock(rw_lock_t* lck) {\n}\nvoid writer_unlock(rw_lock_t* lck) {\n}\nThe only speci\ufb01cation is that in between reader_lock andreader_unlock , no writers can write. In\nbetween the writer locks, only one writer may be writing at a time.\n\u2022Write code to implement a producer consumer using ONLY three counting semaphores. Assume there can\nbe more than one thread calling enqueue and dequeue. Determine the initial value of each semaphore.\n\u2022Write code to implement a producer consumer using condition variables and a mutex. Assume there can be\nmore than one thread calling enqueue and dequeue.\n\u2022Use CVs to implement add(unsigned int) and subtract(unsigned int) blocking functions that never allow the\nglobal value to be greater than 100.\n\u2022Use CVs to implement a barrier for 15 threads.\n\u2022What does the following code do?\nvoid main() {", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1379, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1d969a9f-492b-4650-a18f-eec48cfd03d2": {"__data__": {"id_": "1d969a9f-492b-4650-a18f-eec48cfd03d2", "embedding": null, "metadata": {"page_label": "176", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a610f46e-cbbf-4f5a-9b4e-9ee79ae31d36", "node_type": "4", "metadata": {"page_label": "176", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "341cba8ddd98c6f4874478de69031508bb06e47322258556ef748c30b6327f52", "class_name": "RelatedNodeInfo"}}, "text": "176 CHAPTER 7. SYNCHRONIZATION\npthread_mutex_t mutex ;\npthread_cond_t cond ;\npthread_mutex_init(&mutex, NULL) ;\npthread_cond_init(&cond, NULL) ;\npthread_cond_broadcast(&cond) ;\npthread_cond_wait(&cond,&mutex) ;\nreturn 0;\n}\n\u2022Is the following code correct? If it isn\u2019t, could you \ufb01x it?\nextern int money ;\nvoid deposit( int amount) {\npthread_mutex_lock(&m) ;\nmoney += amount ;\npthread_mutex_unlock(&m) ;\n}\nvoid withdraw( int amount) {\nif(money <amount) {\npthread_cond_wait(&cv) ;\n}\npthread_mutex_lock(&m) ;\nmoney -= amount ;\npthread_mutex_unlock(&m) ;\n}\n\u2022Sketch how to use a binary semaphore as a mutex. Remember in addition to mutual exclusion, a mutex can\nonly ever be unlocked by the thread who called it.\nsem_t sem ;\nvoid lock() {\n}\nvoid unlock() {\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 752, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b468cc24-15df-4797-840e-bbb3ee659919": {"__data__": {"id_": "b468cc24-15df-4797-840e-bbb3ee659919", "embedding": null, "metadata": {"page_label": "177", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0307de24-6a4c-41cf-8b56-e1aea18f578c", "node_type": "4", "metadata": {"page_label": "177", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "d792c298c56a42676c015c6c1ec833ea05209651052341e27f099eb460fac3c6", "class_name": "RelatedNodeInfo"}}, "text": "BIBLIOGRAPHY 177\n\u2022How many of the following statements are true?\n\u2013There can be multiple active readers\n\u2013There can be multiple active writers\n\u2013When there is an active writer the number of active readers must be zero\n\u2013If there is an active reader the number of active writers must be zero\n\u2013A writer must wait until the current active readers have \ufb01nished\nBibliography\n[1]T .J. Dekker and Edsgar Dijkstra. Over de sequentialiteit van procesbeschrijvingen, 1965. URL http://www.\ncs.utexas.edu/users/EWD/transcriptions/EWD00xx/EWD35.html .\n[2]Gary L. Peterson. Myths about the mutual exclusion problem. Inf. Process. Lett. , 12:115\u2013116, 1981.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 637, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a6ee7a9a-e4b5-4943-a916-c97bb8e152b2": {"__data__": {"id_": "a6ee7a9a-e4b5-4943-a916-c97bb8e152b2", "embedding": null, "metadata": {"page_label": "115", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cc6d33e0-1200-4bef-9303-05d032d40d90", "node_type": "4", "metadata": {"page_label": "115", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "c03bfe9b09227a07cbde801288af58ada07e9146ca75cf0f7c17145c3ac3a7fe", "class_name": "RelatedNodeInfo"}}, "text": "6\nThreads\nIf you think your programs crashing before, wait until they crash\nten times as fast\nA thread is short for \u2018thread-of-execution\u2019. It represents the sequence of instructions that the CPU has and\nwill execute. To remember how to return from function calls, and to store the values of automatic variables and\nparameters a thread uses a stack. Almost weirdly , a thread is a process, meaning that creating a thread is similar\ntofork , except there is no copying meaning no copy on write. What this allows is for a process to share the\nsame address space, variables, heap, \ufb01le descriptors and etc. The actual system call to create a thread is similar\ntofork . It\u2019s clone . We won\u2019t go into the speci\ufb01cs, but you can read the man pages keeping in mind that it is\noutside the direct scope of this course. LWP or Lightweight Processes or threads are preferred to forking for a\nlot of scenarios because there is a lot less overhead creating them. But in some cases, notably python uses this,\nmultiprocessing is the way to make your code faster.\n6.1 Processes vs threads\nCreating separate processes is useful when\n\u2022When more security is desired. For example, Chrome browser uses different processes for different tabs.\n\u2022When running an existing and complete program then a new process is required, for example starting \u2018gcc\u2019.\n\u2022When you are running into synchronization primitives and each process is operating on something in the\nsystem.\n\u2022When you have too many threads \u2013 the kernel tries to schedule all the threads near each other which could\ncause more harm than good.\n\u2022When you don\u2019t want to worry about race conditions\n\u2022When the amount of communication is minimal enough that simple IPC needs to be used.\nOn the other hand, creating threads is more useful when\n\u2022You want to leverage the power of a multi-core system to do one task\n115", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1838, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5db8e253-aa58-4f03-a325-d88580aac457": {"__data__": {"id_": "5db8e253-aa58-4f03-a325-d88580aac457", "embedding": null, "metadata": {"page_label": "116", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7395be4c-cb51-4d67-867a-6154e39a6151", "node_type": "4", "metadata": {"page_label": "116", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "bb04ebbfb3351d07265a0f0a9890a8876fbedee8f21be43c6f929fdea5f3571f", "class_name": "RelatedNodeInfo"}}, "text": "116 CHAPTER 6. THREADS\n\u2022When you can\u2019t deal with the overhead of processes\n\u2022When you want communication between the processes simpli\ufb01ed\n\u2022When you want to threads to be part of the same process\n6.2 Thread Internals\nYour main function and other functions has automatic variables. We will store them in memory using a stack and\nkeep track of how large the stack is by using a simple pointer (the \u201cstack pointer\u201d). If the thread calls another\nfunction, we move our stack pointer down, so that we have more space for parameters and automatic variables.\nOnce it returns from a function, we can move the stack pointer back up to its previous value. We keep a copy of\nthe old stack pointer value - on the stack! This is why returning from a function is quick. It\u2019s easy to \u2018free\u2019 the\nmemory used by automatic variables because the program needs to change the stack pointer.\nIn a multi-threaded program, there are multiple stacks but only one address space. The pthread library\nallocates some stack space and uses the clone function call to start the thread at that stack address.\nReserved\nSpace\n1st Thread's\nStackStack\n1\n2nd Thread's\nStackStack\n2\nFigure 6.1: Thread stack visualization\nA program can have more than one thread running inside a process. The programget the \ufb01rst thread for free!\nIt runs the code you write inside \u2018main\u2019. If a program need more threads, it can call pthread_create to create a\nnew thread using the pthread library . You\u2019ll need to pass a pointer to a function so that the thread knows where\nto start.\nThe threads all live inside the same virtual memory because they are part of the same process. Thus they can\nall see the heap, the global variables, and the program code.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1692, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7707a09e-f561-4f4e-a488-e896c0bd021c": {"__data__": {"id_": "7707a09e-f561-4f4e-a488-e896c0bd021c", "embedding": null, "metadata": {"page_label": "117", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "994b4c38-83a4-4c99-8386-b634332dbcfa", "node_type": "4", "metadata": {"page_label": "117", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b08d7418aeb750d06eeb36544478df340459cc0ee415cfcb5bd7f0085f185ea9", "class_name": "RelatedNodeInfo"}}, "text": "6.3. SIMPLE USAGE 117\nReserved\nSpace\n1st Thread's\nStack\n2nd Thread's\nStack\n1int *aint *b\nHeap\nFigure 6.2: Threads pointing to the same place in the heap\nThus, a program can have two (or more) CPUs working on your program at the same time and inside the\nsame process. It\u2019s up to the operating system to assign the threads to CPUs. If a program has more active threads\nthan CPUs, the kernel will assign the thread to a CPU for a short duration or until it runs out of things to do and\nthen will automatically switch the CPU to work on another thread. For example, one CPU might be processing the\ngame AI while another thread is computing the graphics output.\n6.3 Simple Usage\nTo use pthreads, include pthread.h and compile and link with -pthread or-lpthread compiler option. This\noption tells the compiler that your program requires threading support. To create a thread, use the function\npthread_create . This function takes four arguments:\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\nvoid *(*start_routine) ( void *), void *arg) ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1052, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "618365eb-7831-4fee-b96d-d49720a0f8a8": {"__data__": {"id_": "618365eb-7831-4fee-b96d-d49720a0f8a8", "embedding": null, "metadata": {"page_label": "118", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0823693c-ea54-4e40-98f4-ee062c4d3b7c", "node_type": "4", "metadata": {"page_label": "118", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "61984d667c292a4bc729181dde9ff426d76067dde7465b2952b778ebe292f947", "class_name": "RelatedNodeInfo"}}, "text": "118 CHAPTER 6. THREADS\n\u2022The \ufb01rst is a pointer to a variable that will hold the id of the newly created thread.\n\u2022The second is a pointer to attributes that we can use to tweak and tune some of the advanced features of\npthreads.\n\u2022The third is a pointer to a function that we want to run\n\u2022Fourth is a pointer that will be given to our function\nThe argument void *(*start_routine) (void *) is dif\ufb01cult to read! It means a pointer that takes a\nvoid * pointer and returns a void * pointer. It looks like a function declaration except that the name of the\nfunction is wrapped with (* .... )\n#include <stdio.h >\n#include <pthread.h >\nvoid *busy( void *ptr) {\n//ptr will point to\"Hi\"\nputs( \"Hello World \");\nreturn NULL ;\n}\nint main() {\npthread_t id ;\npthread_create(&id, NULL, busy, \"Hi\");\nvoid *result ;\npthread_join(id, &result) ;\n}\nIn the above example, the result will be NULL because the busy function returned NULL . We need to pass the\naddress-of result because pthread_join will be writing into the contents of our pointer.\nIn the man pages, it warns that programmers should use pthread_t as an opaque type and not look at the\ninternals. We do ignore that often, though.\n6.4 Pthread Functions\nHere are some common pthread functions.\n\u2022pthread_create . Creates a new thread. Every thread gets a new stack. If a program calls pthread_create\ntwice, Your process will contain three stacks - one for each thread. The \ufb01rst thread is created when the\nprocess start, the other two after the create. Actually , there can be more stacks than this, but let\u2019s keep\nit simple. The important idea is that each thread requires a stack because the stack contains automatic\nvariables and the old CPU PC register, so that it can go back to executing the calling function after the\nfunction is \ufb01nished.\n\u2022pthread_cancel stops a thread. Note the thread may still continue. For example, it can be terminated", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1883, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "da6bdc19-c30c-4e76-a483-316b61143905": {"__data__": {"id_": "da6bdc19-c30c-4e76-a483-316b61143905", "embedding": null, "metadata": {"page_label": "119", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a11be51c-c7c1-4050-8bd8-ee8f478a7109", "node_type": "4", "metadata": {"page_label": "119", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "68bed4aaebbb43576c1e6cd54dbb5085511a2268e591de74b553a836f249541e", "class_name": "RelatedNodeInfo"}}, "text": "6.4. PTHREAD FUNCTIONS 119\nwhen the thread makes an operating system call (e.g. write ). In practice, pthread_cancel is rarely used\nbecause a thread won\u2019t clean up open resources like \ufb01les. An alternative implementation is to use a boolean\n(int) variable whose value is used to inform other threads that they should \ufb01nish and clean up.\n\u2022pthread_exit(void *) stops the calling thread meaning the thread never returns after calling pthread_exit .\nThe pthread library will automatically \ufb01nish the process if no other threads are running. pthread_exit(...)\nis equivalent to returning from the thread\u2019s function; both \ufb01nish the thread and also set the return value\n(void *pointer) for the thread. Calling pthread_exit in the main thread is a common way for simple\nprograms to ensure that all threads \ufb01nish. For example, in the following program, the myfunc threads\nwill probably not have time to get started. On the other hand exit() exits the entire process and sets the\nprocess\u2019 exit value. This is equivalent to return (); in the main method. All threads inside the process\nare stopped. Note the pthread_exit version creates thread zombies; however, this is not a long-running\nprocess, so we don\u2019t care.\nint main() {\npthread_t tid1, tid2 ;\npthread_create(&tid1, NULL, myfunc, \"Jabberwocky \");\npthread_create(&tid2, NULL, myfunc, \"Vorpel \");\nif(keep_threads_going) {\npthread_exit(NULL) ;\n}else {\nexit(42) ;//orreturn 42;\n}\n//Nocode isrun after exit\n}\n\u2022pthread_join() waits for a thread to \ufb01nish and records its return value. Finished threads will continue to\nconsume resources. Eventually , if enough threads are created, pthread_create will fail. In practice, this is\nonly an issue for long-running processes but is not an issue for simple, short-lived processes as all thread\nresources are automatically freed when the process exits. This is equivalent to turning your children into\nzombies, so keep this in mind for long-running processes. In the exit example, we could also wait on all the\nthreads.\n//...\nvoid * result ;\npthread_join(tid1, &result) ;\npthread_join(tid2, &result) ;\nreturn 42;\n//...\nThere are many ways to exit threads. Here is a non-complete list.\n\u2022Returning from the thread function", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2200, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3e46a656-60fd-4686-82fa-3ff9b95706b8": {"__data__": {"id_": "3e46a656-60fd-4686-82fa-3ff9b95706b8", "embedding": null, "metadata": {"page_label": "120", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "41e8389e-9056-4db3-aabc-7101af07b372", "node_type": "4", "metadata": {"page_label": "120", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "796a01e752556b1d53016061a7121c6c3921bd28a0f79a687dabc24bbf92eccb", "class_name": "RelatedNodeInfo"}}, "text": "120 CHAPTER 6. THREADS\n\u2022Calling pthread_exit\n\u2022Canceling the thread with pthread_cancel\n\u2022Terminating the process through a signal.\n\u2022calling exit() orabort()\n\u2022Returning from main\n\u2022Executing another program\n\u2022Unplugging your computer\n\u2022Some unde\ufb01ned behavior can terminate your threads, it is unde\ufb01ned behavior\n6.5 Race Conditions\nRace conditions are whenever the outcome of a program is determined by its sequence of events determined by\nthe processor. This means that the execution of the code is non-deterministic. Meaning that the same program\ncan run multiple times and depending on how the kernel schedules the threads could produce inaccurate results.\nThe following is the canonical race condition.\nvoid *thread_main( void *p) {\nint *p_int = ( int*) p ;\nint x = *p_int ;\nx += x ;\n*p_int = x ;\nreturn NULL ;\n}\nint main() {\nint data = 1 ;\npthread_t one, two ;\npthread_create(&one, NULL, thread_main, &data) ;\npthread_create(&two, NULL, thread_main, &data) ;\npthread_join(one, NULL) ;\npthread_join(two, NULL) ;\nprintf( \"%d\\n\", data) ;\nreturn 0;\n}\nBreaking down the assembly there are many different accesses of the code. We will assume that data is stored\nin the eaxregister. The code to increment is the following with no optimization (assume int_ptr contains eax).\nmov eax,DWORD PTR [rbp-4] ;Loads int_ptr", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1306, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "738c18ff-7e08-46a8-9fc3-c257f2e370f3": {"__data__": {"id_": "738c18ff-7e08-46a8-9fc3-c257f2e370f3", "embedding": null, "metadata": {"page_label": "121", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "488a1e20-70b7-442a-ba09-c1b234618e5e", "node_type": "4", "metadata": {"page_label": "121", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "8d7af74be629dbae1a00e47d8898fcb9aaade9b29451483b626d8929e61f61e8", "class_name": "RelatedNodeInfo"}}, "text": "6.5. RACE CONDITIONS 121\nadd eax,eax ;Does the addition\nmov DWORD PTR [rbp-4], eax ;Stores it back\nConsider this access pattern.\nint dataThread 1Thread 2 x = 1 x += x\n1*p = x\n1 2x = 2 x += x *p = x\n2 2 4\nFigure 6.3: Thread access - not a race condition\nThis access pattern will cause the variable data to be 4. The problem is when the instructions are executed in\nparallel.\nint dataThread 1Thread 2 x = 1 x += x\n1*p = x\n1 2x = 1 x += x *p = x\n2\nFigure 6.4: Thread access - race condition\nThis access pattern will cause the variable data to be 2. This is unde\ufb01ned behavior and a race condition. What\nwe want is one thread to access the part of the code at a time.\nBut when compiled with -O2, assembly output is a single instruction.\nshl dword ptr [rdi] # Optimized way of doing the add\nShouldn\u2019t that \ufb01x it? It is a single assembly instruction so no interleaving? It doesn\u2019t \ufb01x the problems that the\nhardware itself may experience a race condition because we as programmers didn\u2019t tell the hardware to check for\nit. The easiest way is to add the lock pre\ufb01x [1, p. 1120 ].\nBut we don\u2019t want to be coding in assembly! We need to come up with a software solution to this problem.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1175, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3c213e4a-a2ec-4b29-9f05-7ed77e2d7ed8": {"__data__": {"id_": "3c213e4a-a2ec-4b29-9f05-7ed77e2d7ed8", "embedding": null, "metadata": {"page_label": "122", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9efe6404-82a3-4af7-8203-65ebb280dfd8", "node_type": "4", "metadata": {"page_label": "122", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "b1c98710b29948800cb0d60b61ba10d9ef3efb7e49e218fef714655aa5e43539", "class_name": "RelatedNodeInfo"}}, "text": "122 CHAPTER 6. THREADS\nA day at the races\nHere is another small race condition. The following code is supposed to start ten threads with the integers 0\nthrough 9 inclusive. However, when run prints out 1 7 8 8 8 8 8 8 8 10 ! Or seldom does it print out what\nwe expect. Can you see why?\n#include <pthread.h >\nvoid * myfunc( void * ptr) {\nint i = *(( int *) ptr) ;\nprintf( \"%d\", i) ;\nreturn NULL ;\n}\nint main() {\n//Each thread gets adifferent value ofitoprocess\nint i;\npthread_t tid ;\nfor(i =0 ;i<10;i++){\npthread_create(&tid, NULL, myfunc, &i) ;//ERROR\n}\npthread_exit(NULL) ;\n}\nThe above code suffers from a race condition - the value of i is changing. The new threads start later in the\nexample output the last thread starts after the loop has \ufb01nished. To overcome this race-condition, we will give\neach thread a pointer to its own data area. For example, for each thread we may want to store the id, a starting\nvalue and an output value. We will instead treat i as a pointer and cast it by value.\nvoid * myfunc( void * ptr) {\nint data = (( int) ptr) ;\nprintf( \"%d\", data) ;\nreturn NULL ;\n}\nint main() {\n//Each thread gets adifferent value ofitoprocess\nint i;\npthread_t tid ;\nfor(i =0 ;i<10;i++){\npthread_create(&tid, NULL, myfunc, ( void *)i) ;\n}\npthread_exit(NULL) ;\n}", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1270, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a4392b60-3f95-4521-9ad3-8b52dc627c86": {"__data__": {"id_": "a4392b60-3f95-4521-9ad3-8b52dc627c86", "embedding": null, "metadata": {"page_label": "123", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "15c74424-8f12-4162-9180-6fbd21284850", "node_type": "4", "metadata": {"page_label": "123", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "afacbcfe4416ea866e12ee38531455074ed0e57993f0ac49fb31d711c6e448fa", "class_name": "RelatedNodeInfo"}}, "text": "6.5. RACE CONDITIONS 123\nRace conditions aren\u2019t in our code. They can be in provided code Some functions like asctime ,getenv ,\nstrtok ,strerror not thread-safe. Let\u2019s look at a simple function that is also not \u2018thread-safe\u2019. The result buffer\ncould be stored in global memory . This is good in a single-threaded program. We wouldn\u2019t want to return a\npointer to an invalid address on the stack, but there\u2019s only one result buffer in the entire memory . If two threads\nwere to use it at the same time, one would corrupt the other.\nchar *to_message( int num) {\nstatic char result [256] ;\nif(num <10) sprintf(result, \"%d:blah blah \", num) ;\nelse strcpy(result, \"Unknown \");\nreturn result ;\n}\nThere are ways around this like using synchronization locks, but \ufb01rst let\u2019s do this by design. How would you\n\ufb01x the function above? You can change any of the parameters and any return types. Here is one valid solution.\nint to_message_r( int num, char *buf, size_t nbytes) {\nsize_t written ;\nif(num <10) {\nwritten = snprintf(buf, nbtytes, \"%d:blah blah \", num) ;\n}else {\nstrncpy(buf, \"Unknown \", nbytes) ;\nbuf[nbytes] = \u2019\\0\u2019;\nwritten = strlen(buf) + 1 ;\n}\nreturn written <= nbytes ;\n}\nInstead of making the function responsible for the memory , we made the caller responsible! A lot of programs,\nand hopefully your programs, have minimal communication needed. Often a malloc call is less work than locking\na mutex or sending a message to another thread.\n6.5.1 Don\u2019t Cross the Streams\nA program can fork inside a process with multiple threads! However, the child process only has a single thread,\nwhich is a clone of the thread that called fork . We can see this as a simple example, where the background\nthreads never print out a second message in the child process.\n#include <pthread.h >\n#include <stdio.h >\n#include <unistd.h >", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1817, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5afd04b2-3893-4d3d-bcde-a06dbdc4e3ff": {"__data__": {"id_": "5afd04b2-3893-4d3d-bcde-a06dbdc4e3ff", "embedding": null, "metadata": {"page_label": "124", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "35c4e781-aee3-4688-a2ea-2b75da09a5ce", "node_type": "4", "metadata": {"page_label": "124", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "80821463854a482d03f832bfcbd18097fda092b29822bb8736ff9864da0094e5", "class_name": "RelatedNodeInfo"}}, "text": "124 CHAPTER 6. THREADS\nstatic pid_t child = -2 ;\nvoid *sleepnprint( void *arg) {\nprintf( \"%d:%sstarting up...\\ n\", getpid(), ( char *) arg) ;\nwhile (child == -2) {sleep(1) ;}/*Later wewill use condition\nvariables */\nprintf( \"%d:%sfinishing ...\\ n\",getpid(), ( char *)arg) ;\nreturn NULL ;\n}\nint main() {\npthread_t tid1, tid2 ;\npthread_create(&tid1,NULL, sleepnprint, \"New Thread One\");\npthread_create(&tid2,NULL, sleepnprint, \"New Thread Two\");\nchild = fork() ;\nprintf( \"%d:%s\\n\",getpid(), \"fork ()ing complete \");\nsleep(3) ;\nprintf( \"%d:%s\\n\",getpid(), \"Main thread finished \");\npthread_exit(NULL) ;\nreturn 0;/*Never executes */\n}\n8970:New Thread One starting up...\n8970:fork()ing complete\n8973:fork()ing complete\n8970:New Thread Two starting up...\n8970:New Thread Two finishing...\n8970:New Thread One finishing...\n8970:Main thread finished\n8973:Main thread finished\nIn practice, creating threads before forking can lead to unexpected errors because (as demonstrated above)\nthe other threads are immediately terminated when forking. Another thread might have locked a mutex like by\ncalling malloc and never unlock it again. Advanced users may \ufb01nd pthread_atfork useful however we suggest\na program avoid creating threads before forking unless you fully understand the limitations and dif\ufb01culties of this\napproach.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1313, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "66d34a3a-f51e-4dcf-b049-b88de6d02bff": {"__data__": {"id_": "66d34a3a-f51e-4dcf-b049-b88de6d02bff", "embedding": null, "metadata": {"page_label": "125", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3323c86c-d8ea-4a1b-b619-905945b89771", "node_type": "4", "metadata": {"page_label": "125", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "2fa0cfe91789c31b0c396004419950e6bf7498fec5652877c5ff92032d323884", "class_name": "RelatedNodeInfo"}}, "text": "6.5. RACE CONDITIONS 125\n6.5.2 Embarrassingly Parallel Problems\nThe study of parallel algorithms has exploded over the past few years. An embarrassingly parallel problem is any\nproblem that needs little effort to turn parallel. A lot of them have some synchronization concepts with them but\nnot always. You already know a parallelizable algorithm, Merge Sort!\nvoid merge_sort( int *arr, size_t len) {\nif(len >1){\n//Merge Sort the left half\n//Merge Sort the right half\n//Merge the two halves\n}\nWith your new understanding of threads, all you need to do is create a thread for the left half, and one for the\nright half. Given that your CPU has multiple real cores, you will see a speedup following Amdahl\u2019s Law. The time\ncomplexity analysis gets interesting here as well. The parallel algorithm runs in O(log3(n))running time because\nwe have the analysis assumes that we have a lot of cores.\nIn practice though, we typically do two changes. One, once the array gets small enough, we ditch the Parallel\nMerge Sort algorithm and do conventional sort that works fast on small arrays, usually cache coherency rules at\nthis level. The other thing that we know is that CPUs don\u2019t have in\ufb01nite cores. To get around that, we typically\nkeep a worker pool. You won\u2019t see the speedup right away because of things like cache coherency and scheduling\nextra threads. Over the bigger pieces of code though, you will start to see speedups.\nAnother embarrassingly parallel problem is parallel map. Say we want to apply a function to an entire array ,\none element at a time.\nint *map( int (*func)( int),int *arr, size_t len) {\nint *ret = malloc(len* sizeof (*arr)) ;\nfor(size_t i = 0 ;i<len;++i){\nret[i] = func(arr[i]) ;\n}\nreturn ret;\n}\nSince none of the elements depend on any other element, how would you go about parallelizing this? What\ndo you think would be the best way to split up the work between threads.\nCheck out thread scheduling in the appendix for more ways to schedule.\n6.5.3 Other Problems\nFrom Wikipedia\n\u2022Serving static \ufb01les on a web server to multiple users at once.\n\u2022The Mandelbrot set, Perlin noise, and similar images, where each point is calculated independently .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2166, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8af7c035-1d3e-475c-bfe2-90c04e25145e": {"__data__": {"id_": "8af7c035-1d3e-475c-bfe2-90c04e25145e", "embedding": null, "metadata": {"page_label": "126", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b7dcb9b2-58b4-438c-8f68-dc78c7846e5e", "node_type": "4", "metadata": {"page_label": "126", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "a8738e489fd02c3e487e1bd0e1470516efcf3a3dc34d65e81fd336abcc5558b5", "class_name": "RelatedNodeInfo"}}, "text": "126 CHAPTER 6. THREADS\n\u2022Rendering of computer graphics. In computer animation, each frame may be rendered independently (see\nparallel rendering).\n\u2022Brute-force searches in cryptography .\n\u2022Notable real-world examples include distributed.net and proof-of-work systems used in cryptocurrency .\n\u2022BLAST searches in bioinformatics for multiple queries (but not for individual large queries)\n\u2022Large scale facial recognition systems that compare thousands of arbitrary acquired faces (e.g., a security\nor surveillance video via closed-circuit television) with a similarly large number of previously stored faces\n(e.g., a rogues gallery or similar watch list).\n\u2022Computer simulations comparing many independent scenarios, such as climate models.\n\u2022Evolutionary computation meta-heuristics such as genetic algorithms.\n\u2022Ensemble calculations of numerical weather prediction.\n\u2022Event simulation and reconstruction in particle physics.\n\u2022The marching squares algorithm\n\u2022Sieving step of the quadratic sieve and the number \ufb01eld sieve.\n\u2022Tree growth step of the random forest machine learning technique.\n\u2022Discrete Fourier Transform where each harmonic is independently calculated.\n6.5.4 Advanced: Lightweight Processes?\nIn the beginning of the chapter, we mentioned that threads are processes. What do we mean by that? You can\ncreate a thread like a process Take a look at the example code below\n//8KiB stacks\n#define STACK_SIZE (8 * 1024 * 1024)\nint thread_start( void *arg) {\n//Just like the pthread function\nputs( \"Hello Clone !\")\n//This share the same heap and address space !\nreturn 0;\n}\nint main() {\n//Allocate stack space for the child\nchar *child_stack = malloc(STACK_SIZE) ;\n//Remember stacks work bygrowing down ,soweneed\n//togive the top ofthe stack\nchar *stack_top = stack + STACK_SIZE ;", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1777, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0f8f1865-989b-433e-8cc5-6b261fd7f023": {"__data__": {"id_": "0f8f1865-989b-433e-8cc5-6b261fd7f023", "embedding": null, "metadata": {"page_label": "127", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "529b6c59-00b2-49b2-8f78-9c6f8a599516", "node_type": "4", "metadata": {"page_label": "127", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "9359471661eea66c04c8cb516df9e52665004e8835443901dd07a58d95e9cf93", "class_name": "RelatedNodeInfo"}}, "text": "6.5. RACE CONDITIONS 127\n//clone create thread\npid_t pid = clone(thread_start, stack_top, SIGCHLD, NULL) ;\nif(pid == -1) {\nperror( \"clone \");\nexit(1) ;\n}\nprintf( \"Child pid %ld\\n\", (long ) pid) ;\n//Wait like any child\nif(waitpid(pid, NULL, 0) == -1) {\nperror( \"waitpid \");\nexit(1) ;\n}\nreturn 0;\n}\nIt seems pretty simple right? Why not use this functionality? First, there is a decent bit of boilerplate code.\nIn addition, pthreads are part of the POSIX standard and have de\ufb01ned functionality . Pthreads let a program set\nvarious attributes \u2013 some that resemble the option in clone \u2013 to customize your thread. But as we mentioned\nearlier, with each later of abstraction for portability reasons we lose some functionality . clone can do some neat\nthings like keeping different parts of your heap the same while creating copies of other pages. A program has\n\ufb01ner control of scheduling because it is a process with the same mappings.\nAt no time in this course should you be using clone. But in the future, know that it is a perfectly viable\nalternative to fork. You have to be careful and research edge cases.\n6.5.5 Further Reading\nGuiding questions\n\u2022What is the \ufb01rst argument to pthread create?\n\u2022What is the start routing in pthread create? How about arg?\n\u2022Why might pthread create fail?\n\u2022What are a few things that threads share in a process? What are a few things that threads have different?\n\u2022How can a thread uniquely identify itself?\n\u2022What are some examples of non thread safe library functions? Why might they not be thread safe?\n\u2022How can a program stop a thread?\n\u2022How can a program get back a thread\u2019s \"return value\"?\n\u2022man page\n\u2022pthread reference guide\n\u2022Concise third party sample code explaining create, join and exit", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1722, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6fd13afb-fd96-4db4-8d61-9ead203607c2": {"__data__": {"id_": "6fd13afb-fd96-4db4-8d61-9ead203607c2", "embedding": null, "metadata": {"page_label": "128", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e6b9c5a7-76aa-4b07-bb00-182bb17f2260", "node_type": "4", "metadata": {"page_label": "128", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}, "hash": "905ecae6091a9c6d8a59a86b5838576f97cf7b77b1849cbdff3e3ecc835a7fc2", "class_name": "RelatedNodeInfo"}}, "text": "128 CHAPTER 6. THREADS\n6.6 Topics\n\u2022pthread life-cycle\n\u2022Each thread has a stack\n\u2022Capturing return values from a thread\n\u2022Using pthread_join\n\u2022Using pthread_create\n\u2022Using pthread_exit\n\u2022Under what conditions will a process exit\n6.7 Questions\n\u2022What happens when a pthread gets created?\n\u2022Where is each thread\u2019s stack?\n\u2022How does a program get a return value given a pthread_t ? What are the ways a thread can set that return\nvalue? What happens if a program discards the return value?\n\u2022Why is pthread_join important (think stack space, registers, return values)?\n\u2022What does pthread_exit do if it is not the last thread? What other functions are called when after calling\npthread_exit?\n\u2022Give me three conditions under which a multi-threaded process will exit. Are there any more?\n\u2022What is an embarrassingly parallel problem?\nBibliography\n[1]Part Guide. Intel\u00ae 64 and ia-32 architectures software developers manual. Volume 3B: System programming\nGuide, Part , 2, 2011.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 958, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"b84895b9-6f90-4975-9e13-02044300f26a": {"node_ids": ["7ffe0d6e-0824-4b30-832e-da3aef08a3ff", "602d80fc-d4ab-40de-8af1-19ab3c85fc7a"], "metadata": {"page_label": "1", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "076fe90a-05da-43e4-88f6-01ba95c8d719": {"node_ids": ["871adc23-b7b6-43bd-9349-bb5c72464e91", "0639d255-56c4-4ac2-978d-ac20e39c47c4"], "metadata": {"page_label": "2", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "1e5f4b71-4211-4934-bab2-20839a1eaf52": {"node_ids": ["e99898fa-794f-44e5-b667-999a2b6f5431", "31611764-f065-42ac-a804-c800eba90d2c"], "metadata": {"page_label": "3", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "02d81911-24f6-4111-acfd-138239bfe6e3": {"node_ids": ["ec4aee05-21e3-4da7-b065-9af72dd1015a", "b34259db-7339-46e8-b9da-91543f6072d2"], "metadata": {"page_label": "4", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "204eda0e-0a38-4f2a-af79-6c57b8fc0c05": {"node_ids": ["1be1b294-05bf-4d25-9c53-20d2f2fc8be9"], "metadata": {"page_label": "5", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "68e2c518-050f-454a-936f-33033c6dc12e": {"node_ids": ["a29cc3f6-0465-40f9-be43-7041a2686f30", "3def7a1b-a1ba-4680-b88c-fbb1f5904f8c"], "metadata": {"page_label": "6", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ff580322-4bf2-4ffa-a4ed-0582ce3217dc": {"node_ids": ["abf02d24-4bf5-4b83-8d89-d7ab8ec3b0b5", "e6dfc4ae-972a-428b-9698-0a633e459fb2"], "metadata": {"page_label": "7", "file_name": "Linux VM info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Linux VM info.pdf", "file_type": "application/pdf", "file_size": 119912, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "30a9c6cc-73d7-4486-ac5c-b40e3bb0fb27": {"node_ids": ["255b23a2-8409-40e0-a8d8-92d7af6ae648", "f50705fa-7fd9-48f3-98b5-9922a51ea0a3"], "metadata": {"page_label": "1", "file_name": "Peer Tutoring info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Peer Tutoring info.pdf", "file_type": "application/pdf", "file_size": 17090, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d1257edc-1b8b-4a4b-b71d-bebccabaf357": {"node_ids": ["107517f8-a175-49df-ae13-599e0bb0042b"], "metadata": {"page_label": "1", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7e02a3b6-4f11-44dd-a46b-65153f2a6615": {"node_ids": ["67b0b59c-100a-401d-adde-5cea369ef8e9"], "metadata": {"page_label": "2", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "293289f5-cef4-443c-9aa6-90a0d2625f2f": {"node_ids": ["36025681-6282-4404-986c-d44c342f6fd5"], "metadata": {"page_label": "3", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6904ae89-36c0-4f9f-9605-365747dac5e7": {"node_ids": ["20933971-29cf-4e40-9766-49e8887c5d1e"], "metadata": {"page_label": "4", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8bb66c66-9021-4ce4-9279-3dd0432ac1e8": {"node_ids": ["ba695c7f-4ddc-4985-9879-f9b95762ec03"], "metadata": {"page_label": "5", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f4218aa6-08f5-43d9-9655-9b58a33d2068": {"node_ids": ["ca46a54f-b287-40b1-a9a4-d6a97cf0c7b7"], "metadata": {"page_label": "6", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "20abee10-fba9-42c1-b65f-817e871648f4": {"node_ids": ["613bca0a-5ba4-4ea6-ad43-429dcba5b7fe"], "metadata": {"page_label": "7", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "bf24c37a-3f3b-48c0-8447-dc2e38a19f71": {"node_ids": ["baf1e610-4526-47c7-af7c-7f7583751f68"], "metadata": {"page_label": "8", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c85c5020-e0f2-4b45-853b-87085be3569f": {"node_ids": ["701b5773-47a3-4803-997e-8ee5607583d6"], "metadata": {"page_label": "9", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "392b824c-3e31-457b-9b2d-33c0dae061e4": {"node_ids": ["904efe8a-f578-46df-b7b6-bcdd06262bd1"], "metadata": {"page_label": "10", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e170daba-74a2-497a-bdd7-4da84ff21e8e": {"node_ids": ["133a796b-9c78-400f-8fd2-9f77f85a80b8"], "metadata": {"page_label": "11", "file_name": "Syllabus info.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/Syllabus info.pdf", "file_type": "application/pdf", "file_size": 121151, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "fc825bf2-ed57-4898-b758-79f8e272eaa2": {"node_ids": ["94585289-8d07-470e-9b71-82e1b4024687"], "metadata": {"page_label": "324", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e44e1708-fa1a-4e97-be98-7f43f4eb361a": {"node_ids": ["5a30a69b-a419-4a73-8dfa-1e3d97ebc0c6"], "metadata": {"page_label": "325", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8cccc794-d1e2-47e7-b770-1956fab8942a": {"node_ids": ["ed70dfde-19d6-46a5-9891-a329c02f9af2"], "metadata": {"page_label": "326", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d0d481c5-a8a6-40cd-bd59-ab47cb6de26d": {"node_ids": ["98ebb1c2-1437-4045-a5ca-44740f952a03"], "metadata": {"page_label": "327", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "cea8dda1-dd4d-4a41-900a-409eb619daa0": {"node_ids": ["16cd6dd9-e80e-48c1-a0fd-6ff5ee351566"], "metadata": {"page_label": "328", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "90e4869f-66ca-400a-9179-f09ca6b1ed8f": {"node_ids": ["8e25f32d-7f79-4ea7-8201-cb13362f4a16"], "metadata": {"page_label": "329", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "051b9327-424d-4380-8850-65707eab7580": {"node_ids": ["1d70d226-442c-4872-a50f-ac778cf1e0b5"], "metadata": {"page_label": "330", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "56da1b7e-55cd-4559-9cfc-a341588f3709": {"node_ids": ["aab0b21c-710d-4cda-99d3-b3b6a11b4909"], "metadata": {"page_label": "331", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "41aae94c-6c33-4f89-bfdc-17bef1b1b595": {"node_ids": ["0c9ce1c2-f8b0-4fa6-b153-6e513510d2c3"], "metadata": {"page_label": "332", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9dc87bfc-33c2-4cc5-971c-132f9941654e": {"node_ids": ["5495b377-23fa-4910-81ed-50fa61522076"], "metadata": {"page_label": "333", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "fb61839b-72af-415e-9157-612f7318e55c": {"node_ids": ["159c69a2-b9fc-476c-a5d3-059981abd0af"], "metadata": {"page_label": "334", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "89ee9942-c3b9-4bf0-aab6-bd9db6ca16f1": {"node_ids": ["7646e76e-84f5-4902-afab-a184a50ae987"], "metadata": {"page_label": "335", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "bdb69170-6db0-4358-a368-82df7cef9c8d": {"node_ids": ["159936ab-de8f-4392-b3ed-fafd84c95604"], "metadata": {"page_label": "336", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b5eaaec0-c9a6-452a-908d-46dc7e67609c": {"node_ids": ["58a26b75-12a1-4b2a-b489-851d81976092"], "metadata": {"page_label": "337", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "74b3311b-bd41-4da3-914f-f741221735f1": {"node_ids": ["cce19518-909c-4615-86ed-9ad1fafb3b38"], "metadata": {"page_label": "338", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d50d414c-102e-4555-8c3c-def649484c91": {"node_ids": ["bb65157b-db10-4def-9b5d-20e3ccf9ab8b"], "metadata": {"page_label": "339", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "700879ea-fa69-47f0-a484-f59e5a33222a": {"node_ids": ["7d93967a-a2cb-497b-a84a-2ebe92ac5c92"], "metadata": {"page_label": "340", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6419b92c-682e-456d-8f81-e870e89e41d1": {"node_ids": ["ab81c9ac-97ca-4608-9176-b482eb3485a1"], "metadata": {"page_label": "341", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "74543c26-6735-4e29-8b30-0c83c37e4eb2": {"node_ids": ["85c8f08f-1796-408c-9fc5-a42cd02b5677"], "metadata": {"page_label": "342", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9accf485-e076-4427-b5dd-3e83b1de851d": {"node_ids": ["e7f6602a-36f9-4d3c-b3a3-214944fb8b47"], "metadata": {"page_label": "343", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5e041b9d-da2b-4ae4-8f23-df603251e755": {"node_ids": ["f134613a-31f9-4792-bc53-f43f8ababd02"], "metadata": {"page_label": "344", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ce5260da-9638-4b8f-bac7-54c602e4fca5": {"node_ids": ["3a0fd6f6-592c-478b-8aee-05e83cb5a9a1"], "metadata": {"page_label": "345", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "80178348-8193-4427-95fd-ca2042100e79": {"node_ids": ["8aabe95a-727c-476b-b1d9-11b453d6aebf"], "metadata": {"page_label": "346", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3d5517b7-faaa-4fbe-a09a-34657858603b": {"node_ids": ["86cba470-f618-4f30-a537-5863665cef42"], "metadata": {"page_label": "347", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3a491e0e-6d33-4494-ad06-2bfff5d0225c": {"node_ids": ["f13ecdb8-eb87-4115-ad66-1bfe6e1773cc"], "metadata": {"page_label": "348", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "557a1ac1-ce42-4e6a-8ad2-ecaaa091f7e2": {"node_ids": ["22a32777-ac96-431e-89f3-091b1719ad3f"], "metadata": {"page_label": "349", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6826ac6f-6e81-4ec2-bd50-887e6c471ed1": {"node_ids": ["d49455ae-54e6-47ed-9c98-e9bfcc4c7ac3"], "metadata": {"page_label": "350", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "2dfb7df0-30d9-4b21-8bb7-1583c22c6b07": {"node_ids": ["198938e6-a1d5-4518-97d0-04d279484e7c"], "metadata": {"page_label": "351", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6d7bc0af-6401-4680-abe9-1f944917c234": {"node_ids": ["70166911-5fb1-4a1a-8485-1994a475961d"], "metadata": {"page_label": "352", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7eb43954-0af3-4d23-8ced-7f4543102e31": {"node_ids": ["aa059345-ec07-4762-a581-5d4022738b80"], "metadata": {"page_label": "353", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6c94dc17-010b-497e-894d-4758e39d23ab": {"node_ids": ["ec73a79f-fc30-4c41-86a1-4cf887ba31e7"], "metadata": {"page_label": "354", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c9a5f1d4-7d47-4b7f-a050-d0384b21fe31": {"node_ids": ["eec79c67-3ef0-48b1-a83e-192d1d91e2a1"], "metadata": {"page_label": "355", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "af70ebff-f208-4650-b5c8-eaead32a44a0": {"node_ids": ["b9eb5cb3-d221-4222-8259-c4541015fa82"], "metadata": {"page_label": "356", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "2571ee34-738c-43d4-a92e-f6d7b66148ec": {"node_ids": ["9bcc5764-5a2f-4c6f-84e0-02c9190072d4"], "metadata": {"page_label": "357", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "236806b3-e949-4f50-8f30-10ace87c0a7c": {"node_ids": ["051e0217-b9b0-4bef-a2a6-c69d32ccb9b8"], "metadata": {"page_label": "358", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e02d000e-5d4f-4162-9018-dc239e5a201a": {"node_ids": ["b79dabd0-8a1a-40e6-b12e-53bcd781eabe"], "metadata": {"page_label": "359", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5022be93-401a-42ea-9d11-5c29572f28e4": {"node_ids": ["78307ee3-ffae-40db-a952-c140c264a4bf"], "metadata": {"page_label": "360", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ef37abf2-926d-4796-803a-3155467dd223": {"node_ids": ["17b96e04-09d3-48c3-b94a-680085856207"], "metadata": {"page_label": "361", "file_name": "appendix.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/appendix.pdf", "file_type": "application/pdf", "file_size": 322832, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9917ef51-320a-4cd9-898b-94b7f904bac8": {"node_ids": ["a9be4e21-a963-44bc-bf13-07bf8d8cbe82"], "metadata": {"page_label": "7", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "1cd9b5f2-c02d-476a-bbec-b7eaac8b2cf7": {"node_ids": ["e5ba8d10-6a04-4fcb-91b6-5435cd292e1c"], "metadata": {"page_label": "8", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "090ddc9c-e65e-406e-9e27-792be73779ce": {"node_ids": ["fa29066c-8cca-4828-896e-313c50e4d4d0"], "metadata": {"page_label": "9", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c7893d4a-0f97-46ab-9641-3d0473554ff1": {"node_ids": ["11fe3572-3869-4e39-bc45-5af527a859c7"], "metadata": {"page_label": "10", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ddd96ceb-6a08-43ac-a3d6-5569bbb8dde6": {"node_ids": ["8da9ddc3-b1d6-467f-8822-f60301ea3cfc"], "metadata": {"page_label": "11", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f3399d71-ee43-4a02-b705-e9b6e70b5627": {"node_ids": ["d31821ef-d476-4626-a7d1-d616530d5049"], "metadata": {"page_label": "12", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "1fedf418-8bae-4881-a258-779292d1fa46": {"node_ids": ["4320f7dd-1184-4e8e-8a31-446eacc8d6ec"], "metadata": {"page_label": "13", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a197d6ef-9836-4481-9a8d-ebf806025f07": {"node_ids": ["7c018814-41ae-4a24-9559-c80116b6ff84"], "metadata": {"page_label": "14", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ee128075-15b9-4494-95e8-69f842e66b19": {"node_ids": ["b706542c-36ab-43f3-812a-09f1d5a835b9"], "metadata": {"page_label": "15", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4647b4cd-37af-4431-a3ae-504c2dcf74d2": {"node_ids": ["37a5ee0a-30ae-4d0a-b0c1-5a93c879697b"], "metadata": {"page_label": "16", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6a0ca485-6c93-417d-9da3-b62a23fe1ccc": {"node_ids": ["6272fc67-9183-4bdd-885f-bf81d36db1dd"], "metadata": {"page_label": "17", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0e23cc10-5021-46b0-801a-841b98e1733f": {"node_ids": ["32c494f2-1d06-443a-b591-1e00106114ed"], "metadata": {"page_label": "18", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "aa7beeae-4f91-4376-8787-d80a21562319": {"node_ids": ["0785ae11-f7f6-42b8-b245-498d3b95ba5c"], "metadata": {"page_label": "19", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e563227a-515b-4e2f-b835-c1c6954d38ee": {"node_ids": ["ee7efc66-d099-4091-900c-e2da76cfb457"], "metadata": {"page_label": "20", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "dcfc93af-a56b-4019-b44f-4272b9291044": {"node_ids": ["439b4c0b-582d-41e6-b379-c1af78a8c972"], "metadata": {"page_label": "21", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f509fb39-5993-4e40-9a4b-bdf976e45be8": {"node_ids": ["abdd009c-0e6c-461f-ae95-d339a599785e"], "metadata": {"page_label": "22", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c5c69c69-713b-4a2b-a855-e620b2469bf2": {"node_ids": ["92eb5feb-8e27-44e0-a601-01afa9af26c2"], "metadata": {"page_label": "23", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "21b93e6b-daab-4c30-83ea-d7c09466d58d": {"node_ids": ["fe12dcef-2f2d-4e5e-9c9c-a01a8640374a"], "metadata": {"page_label": "24", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "44bc7c3b-6672-4636-954d-d24b9d933841": {"node_ids": ["2483e054-85d1-4f30-8b1e-7f1b7e8800f0"], "metadata": {"page_label": "25", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "56f9e0ba-4f3e-4fdc-8829-7ab05a87e493": {"node_ids": ["b2791746-967c-4734-9013-5c6e7de5489a"], "metadata": {"page_label": "26", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "17ed935a-f655-433e-b0f0-3585bcaf87b9": {"node_ids": ["077bf166-95b1-41fb-a0bb-bc780e2a82d2"], "metadata": {"page_label": "27", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "da86aa0a-3ee6-428e-a336-5f70c0681132": {"node_ids": ["3595dc72-3215-4622-9525-d56a5b947943"], "metadata": {"page_label": "28", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a8896d80-cf5a-4214-8f05-e7ea877dee95": {"node_ids": ["7a70b554-eff8-4b0e-a35a-973f0f518200"], "metadata": {"page_label": "29", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "cecf2247-2f43-4d26-ac26-c05c35d78ea2": {"node_ids": ["27ccb3ba-c898-472c-81bd-bf9b6c874136"], "metadata": {"page_label": "30", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5b5be961-b8de-4475-88d8-022399d68eb5": {"node_ids": ["997915f9-7a8d-4ba0-af4b-4cebcfbd3761"], "metadata": {"page_label": "31", "file_name": "background.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/background.pdf", "file_type": "application/pdf", "file_size": 258804, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "bf708e73-028f-4fa9-8a5e-47cf94aa6ba2": {"node_ids": ["98cc8976-1db4-4043-b48b-1cc68787f71f"], "metadata": {"page_label": "178", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "114632de-9b30-46f5-a3a7-bcee359ddf7d": {"node_ids": ["7573d4c1-dbf8-4501-a402-00ed0c4b9d81"], "metadata": {"page_label": "179", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8c106819-d756-47f1-874c-d6e955242785": {"node_ids": ["5dd9444e-cfd6-430b-8dab-aec1786e1b96"], "metadata": {"page_label": "180", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "cb95103d-b41b-43b0-956a-dac43d64fb70": {"node_ids": ["92efb306-b55e-4564-915e-855359719d79"], "metadata": {"page_label": "181", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "2c1ceec5-b0c6-4b1e-9617-bba50e0170cc": {"node_ids": ["6b7be912-5f70-43d4-93dc-64134f580a58"], "metadata": {"page_label": "182", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "26830022-9ff3-4fb0-81b0-d4b5c9e5321d": {"node_ids": ["3da0cb07-530b-485e-a8d5-26cd10e10ab6"], "metadata": {"page_label": "183", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3e17fed6-e802-4f8a-bad3-1cb66691e67a": {"node_ids": ["08e1120f-d6ea-4191-a07f-8ff0ef4cdbe6"], "metadata": {"page_label": "184", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e45f51b1-2a7a-481f-8ccb-d153a9213491": {"node_ids": ["85a6f611-f1ee-417f-85de-a755354d345b"], "metadata": {"page_label": "185", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9167fb89-433d-4762-b746-a232f845d992": {"node_ids": ["a8a43c0a-47e6-4012-821c-0114c37bfea3"], "metadata": {"page_label": "186", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b9f290f9-4b77-48cd-9335-619aa436cb73": {"node_ids": ["62a5874a-6ceb-43f9-b621-def05f21946c"], "metadata": {"page_label": "187", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ccafac37-112b-4763-ae18-85c43f5567c5": {"node_ids": ["11deeedb-f29f-40f1-9531-f6c19befbbf1"], "metadata": {"page_label": "188", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6aa6ddc9-85ac-44b3-a5dc-b737e01d9b70": {"node_ids": ["cc00db61-2db4-427b-8e61-92d5b584569b"], "metadata": {"page_label": "189", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "14239045-30eb-4dd9-91fb-11aab4a3ef27": {"node_ids": ["9c16a282-639e-4e96-b176-a17801c93a63"], "metadata": {"page_label": "190", "file_name": "deadlock.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/deadlock.pdf", "file_type": "application/pdf", "file_size": 382165, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4608da6f-0ad0-4231-b0cd-ece358a687a7": {"node_ids": ["6081f2ff-0462-4966-94f1-df044ebbc5e3"], "metadata": {"page_label": "257", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "39fb1508-64b5-4849-acaf-f6ce430c6596": {"node_ids": ["677abf42-8c04-43a2-a067-b91398340fbf"], "metadata": {"page_label": "258", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "87d52158-91ec-4e54-973d-dc499b24f210": {"node_ids": ["517b13be-a40b-463d-b372-beafafc4785b"], "metadata": {"page_label": "259", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "bafc3091-f305-47af-b0ba-b563498e9bd6": {"node_ids": ["2cee24e0-f557-49f0-8e0d-222488c4d97f"], "metadata": {"page_label": "260", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "efc2fe1b-45fd-4c10-be41-7bf03b69e1c1": {"node_ids": ["3f65437e-847d-418f-b885-985f2f79e4ca"], "metadata": {"page_label": "261", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3346a9d4-3cfa-40ed-8052-4befab2915e3": {"node_ids": ["7c6e9c89-adf4-44b5-ab4e-9932ccc80279"], "metadata": {"page_label": "262", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e540e024-a838-4dd0-ad68-5a7d5e927088": {"node_ids": ["9ce697af-9d98-4b9a-a043-c0f6adaf317d"], "metadata": {"page_label": "263", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "2b553800-957d-4f68-94d7-bca9a054fdd0": {"node_ids": ["3bca96f8-8999-4b64-b966-d601cbf71c2a"], "metadata": {"page_label": "264", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7f401720-59ec-4d44-8364-f6df8a5c8649": {"node_ids": ["9b3d6fc4-bc67-4a19-902e-056eb533ea4b"], "metadata": {"page_label": "265", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "15d15e79-4fe0-4306-b06d-f32c3bb1ae3e": {"node_ids": ["b11b705e-67e0-4446-b138-32a7d1874a21"], "metadata": {"page_label": "266", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "bc4bbee5-e8db-4b52-b29a-da25a6faca46": {"node_ids": ["85188aa8-3974-4dee-b1d0-e640d3752bad"], "metadata": {"page_label": "267", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e1d8cf19-4dd6-4682-8e28-520b502de329": {"node_ids": ["924233a9-09c8-4c10-a28f-83324d8108f2"], "metadata": {"page_label": "268", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0ce00458-a9fb-40d3-a306-0ef1d34190ef": {"node_ids": ["d99a8b89-e12f-415e-b511-c8eadefb0648"], "metadata": {"page_label": "269", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3a1856b2-b6b6-4205-bf0d-852eca18c0ad": {"node_ids": ["d7be4361-5548-467c-9aee-922c8c01c2a1"], "metadata": {"page_label": "270", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "457c1c42-ade1-4b82-845e-44e59115c28d": {"node_ids": ["a1e91f87-2783-4dca-8e4d-d1a98c8eb242"], "metadata": {"page_label": "271", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "03bae95b-083b-4d2b-bafc-b1573ea5a6c5": {"node_ids": ["477b8e43-e6d0-40ed-90ff-670b5fc7e925"], "metadata": {"page_label": "272", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8f662ad1-2c47-4939-a066-f72699dc706e": {"node_ids": ["acdbfbc5-0267-47d6-92c4-059695bffda1"], "metadata": {"page_label": "273", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5d0d79f9-8443-4827-a00f-d877c124c94a": {"node_ids": ["0df18f33-aa85-4ca0-8bd7-743969d8d807"], "metadata": {"page_label": "274", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "80184271-f926-4a49-86d5-97be07677f66": {"node_ids": ["d403fd87-cd04-41a4-91f8-3033ce0a9bdf"], "metadata": {"page_label": "275", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c775a736-baf5-4116-bdba-5968271262e9": {"node_ids": ["016ab5cf-685e-4bc6-80b2-4389ecf03535"], "metadata": {"page_label": "276", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "eca13ed7-1787-46fc-8d41-2a1f8ece1ae7": {"node_ids": ["c27b2e73-8b3f-409b-b2e4-9fcbf5122bb7"], "metadata": {"page_label": "277", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6904bba4-c48a-4801-885a-a32484b981fe": {"node_ids": ["848c723b-1c70-42c3-b6bd-eaae13ae0ea9"], "metadata": {"page_label": "278", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "38151ae5-019f-4f99-b324-7df5ed92b5c9": {"node_ids": ["dad43463-3492-4dd7-b83e-eef46b9b33e2"], "metadata": {"page_label": "279", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "971d8269-c87e-4c17-a49d-fcc3deea8074": {"node_ids": ["66e3258b-1d3c-43b7-b577-dafe91bfbd63"], "metadata": {"page_label": "280", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7c24d009-5108-42f1-9092-ced92f6f122a": {"node_ids": ["c5959a23-2d6c-4417-87db-d43ac7f8f559", "ce41bafc-e1af-4f03-b452-f0a8d1c0df26"], "metadata": {"page_label": "281", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a581ae2a-654b-4cb6-9aad-64526a04f76a": {"node_ids": ["9133e626-bf32-45f9-9076-2e3607725f55"], "metadata": {"page_label": "282", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0276b75e-f3d1-49ee-b4fc-236aa4d0de82": {"node_ids": ["62198fb0-1d6b-443a-b60e-739d738233c2"], "metadata": {"page_label": "283", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "04c8efb9-91db-4be8-8990-c5905fe3b4f3": {"node_ids": ["93a8ecff-c04f-4c40-ae4a-68e4ee49e9bd"], "metadata": {"page_label": "284", "file_name": "filesystems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/filesystems.pdf", "file_type": "application/pdf", "file_size": 292316, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "fe6ba256-f571-4f60-a6d6-2f5d76fbc4f2": {"node_ids": ["3a1a71ec-69c4-4542-b32b-2a0ffad7b137"], "metadata": {"page_label": "321", "file_name": "honors.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/honors.pdf", "file_type": "application/pdf", "file_size": 127370, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8fdd045c-b452-4d92-91bf-9b299c248a24": {"node_ids": ["1286b271-f7c6-4594-8619-f120cfe391cf"], "metadata": {"page_label": "322", "file_name": "honors.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/honors.pdf", "file_type": "application/pdf", "file_size": 127370, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "234721b9-6b02-4866-8e80-213ba2c1459b": {"node_ids": ["dab7fc72-61d6-4d47-a6fb-8bafcf9c4747"], "metadata": {"page_label": "323", "file_name": "honors.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/honors.pdf", "file_type": "application/pdf", "file_size": 127370, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0ba40b67-ae26-4674-9e9a-acb2a56f3394": {"node_ids": ["b15f9cb3-4e37-4d07-95f0-d8165dde5203"], "metadata": {"page_label": "32", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d02311e9-d5bd-4e06-b784-322e73f26c57": {"node_ids": ["29485d82-043c-42f7-bf1b-5c093797ca72"], "metadata": {"page_label": "33", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "785d8154-8807-44df-9dd6-af769b07f0aa": {"node_ids": ["9160406c-4317-42de-83bd-b02c29f09cce"], "metadata": {"page_label": "34", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c5997d7a-b89d-4b61-8761-2507394e40a0": {"node_ids": ["d4aa39c5-267b-4fd1-8a78-f250d52223e2"], "metadata": {"page_label": "35", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "19e93801-918d-4282-9a4b-30cddf48c0da": {"node_ids": ["50671a7a-f068-4e5c-a625-50e14bdfb738"], "metadata": {"page_label": "36", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0063fd8e-5d1b-4add-8c82-045fe6ff6f3a": {"node_ids": ["52827f85-7134-4794-b1c0-96a1eb266f2b"], "metadata": {"page_label": "37", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8b50b211-4d4b-4821-a539-16359be8f707": {"node_ids": ["6cbfa301-f914-4db1-b2cd-a0e7b3ab8609"], "metadata": {"page_label": "38", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "dfd067fe-0603-49d5-a708-cafac975920b": {"node_ids": ["ed4c75bb-678b-4403-8321-b02e7953532d"], "metadata": {"page_label": "39", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c5c165ea-2e69-4106-b490-3e88aa7a6cf1": {"node_ids": ["6898adb5-101b-48d4-a2bb-f0c32f673c96"], "metadata": {"page_label": "40", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3e1357db-0d6c-417a-ac58-5a204ea30351": {"node_ids": ["6c755554-2e0a-4ce0-a45a-b107ac0836db"], "metadata": {"page_label": "41", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "bb8cb03c-b84d-45c8-8111-1ea6652c5e10": {"node_ids": ["cec21d6f-04e2-474e-ada7-ce40a5410507"], "metadata": {"page_label": "42", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9f9ea3b1-e133-45f9-925b-a881bd94f9bd": {"node_ids": ["9ad0da2c-2865-455c-94ef-4ec35f1eb79b"], "metadata": {"page_label": "43", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "53956d4c-29dd-4108-9497-1da36dc63c6f": {"node_ids": ["75cdd08e-a2e1-4721-8dab-9cf2a00c7b78"], "metadata": {"page_label": "44", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "762165b3-cf30-40a1-9890-05b1bd6a7aa0": {"node_ids": ["78d91caa-36f4-424a-af48-414b7a4548f5"], "metadata": {"page_label": "45", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ee687696-8b4d-46fe-858f-496a3d4dda20": {"node_ids": ["a66f8708-11b5-4beb-b3fa-ae79a71c16ae"], "metadata": {"page_label": "46", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d4476196-7a25-4dfb-939c-657bf8852838": {"node_ids": ["c65d8bcb-eab9-42cb-b1d8-0c910b867f28"], "metadata": {"page_label": "47", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8b8b6da9-a36f-440d-90c8-f6434dffb4d2": {"node_ids": ["18c5cb38-7dec-441c-aba3-45cd9ae7a57a"], "metadata": {"page_label": "48", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6650b649-d903-4435-bf1b-d7a26e61fe86": {"node_ids": ["f999694d-be96-4621-b713-7e9e15915870"], "metadata": {"page_label": "49", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c2fd7088-d6e0-430a-babd-5f72b6b5aa9d": {"node_ids": ["771bdba7-42f5-452b-83a1-2ee8b27882df"], "metadata": {"page_label": "50", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e690c4d2-8baf-4595-9640-e564cc8d472b": {"node_ids": ["cc68e32d-5c6b-4472-842a-71495f0bfcc1"], "metadata": {"page_label": "51", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "05747e15-8e37-488f-9692-e33ef86e8ce0": {"node_ids": ["d21cfd19-30ba-4210-b470-b9bccf74f1cf"], "metadata": {"page_label": "52", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "69f5ee2e-4e66-47ca-8e65-dc1010d73b0b": {"node_ids": ["17c3ea39-de87-4f56-817f-5ce8e3cd8248"], "metadata": {"page_label": "53", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "33ad6aa0-b2ef-4e06-b5df-a26aeb760b34": {"node_ids": ["7b5bf126-0a4e-49f3-80b4-530f7ec84131"], "metadata": {"page_label": "54", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5be53cfa-ce6c-4f79-b84e-0144051b36df": {"node_ids": ["fe5af126-fb62-46be-b02d-10ea2f80b1f5"], "metadata": {"page_label": "55", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "48e829f2-6f0b-40bc-91e3-d3e60df8dbf2": {"node_ids": ["f1c16bba-8c7c-4ed8-a837-b52c8d2686ff"], "metadata": {"page_label": "56", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7359bfb4-f319-4cec-9fa4-5ff20b7d1356": {"node_ids": ["078ab933-ead9-4998-87c8-74150d9ed248"], "metadata": {"page_label": "57", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7a7b53a5-e10b-4db9-b62a-a4fb8e73c083": {"node_ids": ["245ce618-bd18-478c-bfcf-18d9555140ee"], "metadata": {"page_label": "58", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5f40c19d-e13d-4ecd-84ca-53b30f4ca2b1": {"node_ids": ["ec653924-a576-4a59-876d-4057a73f9878"], "metadata": {"page_label": "59", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "04f47935-4eb2-413c-a396-3ee88762431a": {"node_ids": ["83a94922-b1cc-45de-beb0-b4060a4b1005"], "metadata": {"page_label": "60", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9abc826b-aaac-4f70-92e4-56573e5d8295": {"node_ids": ["8af00d5c-5958-418e-9a32-f9ab00c63441"], "metadata": {"page_label": "61", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "bf77a913-0cbd-4f71-b224-5f9c204e497b": {"node_ids": ["e28efa31-8a17-46a2-a1e2-37f4d0a73cf0"], "metadata": {"page_label": "62", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d8697d45-c8d6-46b2-81b4-061c436099d9": {"node_ids": ["ccea796f-fc4e-4228-9eae-6e4a61c8f2e2"], "metadata": {"page_label": "63", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5a64a2df-968e-4f10-a4d0-38d68d4b22f9": {"node_ids": ["2cf8df8a-dffc-4088-94a1-fe1daed08f1b"], "metadata": {"page_label": "64", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "672c52db-1169-4d88-9422-a873ce53b643": {"node_ids": ["c30c87ee-cf45-4a7c-adcf-cb1a8efee26e"], "metadata": {"page_label": "65", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "fef06e5c-c24b-430a-92f0-4e1b10b3ccdf": {"node_ids": ["19f47f77-aee3-40b9-a68b-dfb2135cc2ef"], "metadata": {"page_label": "66", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "98dc8c61-0938-40a0-bcd1-865c86dd1d6f": {"node_ids": ["e5f6d7f7-9670-40ed-a15c-ac7e233ce616"], "metadata": {"page_label": "67", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e777113e-ee66-495a-8484-fa5a32bcc454": {"node_ids": ["d9030338-2be4-4856-bb1e-64a2a9fdf852"], "metadata": {"page_label": "68", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6f6c2f5f-6b4c-4296-a8b1-a9ec10497351": {"node_ids": ["3f0d11df-538c-4959-b75d-17647f4acd23"], "metadata": {"page_label": "69", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "66108743-8e72-4c8f-a2a5-34d8b61b174f": {"node_ids": ["18ee8e8a-cdf5-42ca-9347-1dd8a2cb028a"], "metadata": {"page_label": "70", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "521e1d8b-fbaf-4ab2-b69b-2e48b8230a7a": {"node_ids": ["6b383aa2-ffd3-40a1-8248-b54e1d570312"], "metadata": {"page_label": "71", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e36849d0-c59d-42ce-8dca-b23571fb2860": {"node_ids": ["42ca0333-0ae1-4717-8ca5-aa48833657e4"], "metadata": {"page_label": "72", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3fd3611c-2a79-4be7-8fc6-a7deced046e0": {"node_ids": ["6bb00794-0153-45d9-b27c-8439d0de0d46"], "metadata": {"page_label": "73", "file_name": "introc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/introc.pdf", "file_type": "application/pdf", "file_size": 344062, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "666b246d-da04-463f-a8e9-c11b622f7fc3": {"node_ids": ["0d5cd916-fd99-4b68-ab4c-99cd55bc8fc5"], "metadata": {"page_label": "191", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e5fe52ac-d081-419e-8b6b-b6d548f3d0cb": {"node_ids": ["451ff369-0ffe-43ce-8c47-5435c31f8cc4"], "metadata": {"page_label": "192", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "17da1750-e889-43c4-b7b3-35be6ee52db0": {"node_ids": ["26d9bc63-0878-463e-be6c-c08ab76d96ff"], "metadata": {"page_label": "193", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ddaf3c7c-18e8-4213-b2c5-d99f960bef47": {"node_ids": ["77ed7a80-857a-4560-a0e8-f0cda970db00"], "metadata": {"page_label": "194", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "221eeb34-7b96-4f24-82ab-7881bc01e7ea": {"node_ids": ["6a9fa445-5130-4aa2-8032-db67cc547efe"], "metadata": {"page_label": "195", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7f5f8800-2f00-4524-a28f-0f0746e72ab0": {"node_ids": ["e04a2bf7-fabc-4c4f-81b2-8f117c6c1649"], "metadata": {"page_label": "196", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4164172b-ca9e-42f0-89ba-bc7e969461cf": {"node_ids": ["b2e4f21c-cb75-46fd-85c4-ad51674a7140"], "metadata": {"page_label": "197", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e0f9db8d-428c-424f-8a25-ca6c429119e0": {"node_ids": ["0c4216d6-de23-4054-83bd-868e84f849f4"], "metadata": {"page_label": "198", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7b2ba05b-7a15-424c-ad27-c400e81550a6": {"node_ids": ["8311a3a7-add2-48a5-9526-704de163ff79"], "metadata": {"page_label": "199", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a1614889-9620-4646-9cd9-2887e75271f7": {"node_ids": ["3f1c05f1-8e44-4306-83b7-c9a63b6f13b8"], "metadata": {"page_label": "200", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0f1a1264-ec42-4ed5-948a-64a1883b02ee": {"node_ids": ["d34314bb-13be-4ded-bea4-4b151595da5f"], "metadata": {"page_label": "201", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9c8a1a6f-0bdb-4f4d-8081-8c911d3bf814": {"node_ids": ["1c16e524-caca-4bf9-ad43-8bce687bc1da"], "metadata": {"page_label": "202", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0fa3cadb-bdee-4e32-9bbf-6f4544a28df4": {"node_ids": ["c3038e20-909c-4975-8f2e-f8d6981f0324"], "metadata": {"page_label": "203", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "86b27ff7-96bf-45fd-a18e-4c5a531270cd": {"node_ids": ["7508c5f0-c125-4c7d-8958-2077c3110e1f"], "metadata": {"page_label": "204", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4a967455-ff90-443b-aac0-f253d5cad787": {"node_ids": ["aa507699-fdd4-444d-9652-69e50dd48c78"], "metadata": {"page_label": "205", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "47bafb77-7ede-4031-88a9-d1a15f1b4174": {"node_ids": ["00e5ffb9-21cc-463c-b548-34d571d5095c"], "metadata": {"page_label": "206", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6bb9f562-08b4-482c-879b-f5204c24863c": {"node_ids": ["77dc5ea3-67f1-46c5-8b25-18654893767b"], "metadata": {"page_label": "207", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "020c9962-814c-4544-b47d-bd5e088dc0d6": {"node_ids": ["79e79cc2-8e5c-4d49-bd0a-7d96b1ea98b1"], "metadata": {"page_label": "208", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3589c68e-a936-4f7c-a72f-b52d267396ae": {"node_ids": ["b1daa9c1-6268-484b-ba91-072c936296b6"], "metadata": {"page_label": "209", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "cc07f000-f142-4a45-a1c6-3c973f3ab86d": {"node_ids": ["407468c5-c892-4e1d-8488-10b04bb5cc28"], "metadata": {"page_label": "210", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3e31bb1e-7bca-4f6b-ba14-043a85d9b35f": {"node_ids": ["b45ca332-fa0a-4457-bc18-1ea1396ad35d"], "metadata": {"page_label": "211", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "cf35a497-039f-4925-b96b-0853163d220e": {"node_ids": ["8c3f08ff-0645-46d8-b39f-a201d280897b"], "metadata": {"page_label": "212", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3973cf5e-04b2-4f24-8bf1-86bfd34c0766": {"node_ids": ["db6a0687-1441-437f-995e-6c4eb8eb2f1c"], "metadata": {"page_label": "213", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "76c870a1-9718-401d-a4b8-31c12741fb34": {"node_ids": ["10e12f1c-8b48-49d4-ab6a-56bc06fa4f41"], "metadata": {"page_label": "214", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a931dbc2-698d-468d-a59a-ac3ef6a6ed5d": {"node_ids": ["e4e85057-d88d-4b01-80b1-d21bfc22595d"], "metadata": {"page_label": "215", "file_name": "ipc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/ipc.pdf", "file_type": "application/pdf", "file_size": 306385, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "beba3d6a-0c00-41ad-8245-0795732d0820": {"node_ids": ["7780dfff-26aa-423f-80db-7ecfcd68c66a"], "metadata": {"page_label": "98", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "422d5eba-01e0-463b-9950-66defc80145d": {"node_ids": ["0d7ae8b6-5030-4348-9273-a1ce4400ca20"], "metadata": {"page_label": "99", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5b4fd09f-cf8a-40d7-a32b-4c05b37fb621": {"node_ids": ["919e7b9b-909f-4dbd-9884-f26c86cc0e60"], "metadata": {"page_label": "100", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "90cd8423-ad69-4429-b027-53fad49f1557": {"node_ids": ["fd255e85-c96f-4be8-8510-b9972ab07405"], "metadata": {"page_label": "101", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "2f24ccb9-6097-4d2b-ba05-cf6a835d6cf8": {"node_ids": ["c1bd448e-09ff-4285-84ee-a49053f29bae"], "metadata": {"page_label": "102", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b01ffb6e-6570-4e73-97f9-ea92357b20a0": {"node_ids": ["48a36d01-fbba-4ee0-a779-8002a3745055"], "metadata": {"page_label": "103", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "80efb101-c438-4a56-9570-247a51f2d5b5": {"node_ids": ["999607f1-8b17-4060-8e8c-20ef8efcaa5f"], "metadata": {"page_label": "104", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b23e1269-93f4-4c88-b3b1-37058eafacf2": {"node_ids": ["97b9fb50-6fd7-4374-88c7-3b3dc47578d1"], "metadata": {"page_label": "105", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "83632113-3b93-4dbe-8baa-5492636c0cad": {"node_ids": ["fc44d2dd-aef1-4b43-9cc6-59d130ca6d93"], "metadata": {"page_label": "106", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8ab14ae7-3e5a-47ff-87cc-29d655c0f217": {"node_ids": ["69d174a5-e926-43c1-b75e-d94e330792d3"], "metadata": {"page_label": "107", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b1c36591-ecdc-469b-acee-2323ddd22057": {"node_ids": ["4fc31d55-0109-4f4c-96d7-6d6d45537ae7"], "metadata": {"page_label": "108", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8b61f980-b631-4fa1-bcb3-4545ef71f0e2": {"node_ids": ["3ddb8602-8d83-4149-bb79-8b931417e4f8"], "metadata": {"page_label": "109", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "62807149-20bb-4ea0-88a9-b388296a678b": {"node_ids": ["8693f4f8-51f1-4936-af4a-9aec63cbf336"], "metadata": {"page_label": "110", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4239e245-38c5-48bf-8c5e-5ab54771505a": {"node_ids": ["29a972bf-47cb-4a45-8421-07873bb6cb4e"], "metadata": {"page_label": "111", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5dc95019-dd8a-4163-ba49-8a86f9bab2be": {"node_ids": ["40f6b157-58dd-4879-8d02-6cddca160578"], "metadata": {"page_label": "112", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b210da89-1cc5-4301-8579-b769944ca6c7": {"node_ids": ["bb1c3834-e822-46a2-9654-67ed0c7a0650"], "metadata": {"page_label": "113", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "835380c0-696a-46f4-ae60-27ff7743de58": {"node_ids": ["0aeeecfd-2c76-41fc-adbd-6544fc936760"], "metadata": {"page_label": "114", "file_name": "malloc.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/malloc.pdf", "file_type": "application/pdf", "file_size": 278967, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d19893bb-b70c-41e9-b28f-e963217d0772": {"node_ids": ["ad0dd0eb-f04b-4d4e-8a81-cfdb1c644f8a"], "metadata": {"page_label": "225", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "534eec77-5499-42ab-a7cc-6e08916763ae": {"node_ids": ["28c34bd1-c5f6-4ddf-a984-7031ef7e6141"], "metadata": {"page_label": "226", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ea20ea8f-b79c-43f6-8de4-4a863a9d5c36": {"node_ids": ["f994cd55-5e3d-4866-a09c-724b2e5c8911"], "metadata": {"page_label": "227", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "421728b7-8c71-49b4-b01c-db40d671cc7e": {"node_ids": ["af858b52-7aca-42fd-93cd-72c1bbd520e8"], "metadata": {"page_label": "228", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4bb40782-9d07-4fd6-9471-5594a5ece7f9": {"node_ids": ["593dc5f5-1409-4e84-87bb-d3211cdadbbc"], "metadata": {"page_label": "229", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9d9790f9-0c0d-4abd-a9b2-cac5867c3cb2": {"node_ids": ["a53494d2-18bc-4974-b11d-b5bc346bf6ae"], "metadata": {"page_label": "230", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a7a1fac0-f06c-46c7-a259-40c3a0447dc9": {"node_ids": ["8d8e919b-5563-4849-94c3-397b166476a2"], "metadata": {"page_label": "231", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0513a6ff-37d1-49e2-996f-e00190978814": {"node_ids": ["8baf1cec-3823-47a6-9915-5eb8b2a531a7"], "metadata": {"page_label": "232", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d163693a-db12-4f49-80f4-20720b5d771a": {"node_ids": ["e9fee898-bac3-4c9b-9ccf-697f55c4b76c"], "metadata": {"page_label": "233", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "04e90bd5-78b8-4576-baad-68fca27cb845": {"node_ids": ["393fd87b-db4d-4079-ade3-bd64d9a629e5"], "metadata": {"page_label": "234", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "51aad2c8-e317-409c-acc2-6c68a59b386d": {"node_ids": ["9bcf0375-2f27-4609-a9ed-c32d6ecea9d2"], "metadata": {"page_label": "235", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "355a0b1d-e050-4e4e-8118-e13795aecd31": {"node_ids": ["4fdf45c8-d8c6-4a47-afcb-dabb3f624306"], "metadata": {"page_label": "236", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "2aa3f0ba-12df-4f3a-ac5a-6dc7763d04cd": {"node_ids": ["2f6dff31-e8f9-4543-bfe4-79aecbf87d39"], "metadata": {"page_label": "237", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ffb92656-4510-4f1d-a9a8-6daf413e70ec": {"node_ids": ["24253d98-a89b-4f85-bd8c-89782a193bcd"], "metadata": {"page_label": "238", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "991644ea-d5cb-43ab-9a3f-f18e7b808f76": {"node_ids": ["23e3e992-2796-422d-b59b-12b7a933c4a3"], "metadata": {"page_label": "239", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "26739b1e-9b08-4610-bd98-2c3d1e56b1df": {"node_ids": ["fbfcd7a6-967d-4c74-bf2a-b2ca457349c0"], "metadata": {"page_label": "240", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3d64891d-cbfb-479a-acc5-7c2439671a15": {"node_ids": ["a63a7445-23b5-4364-bef9-b25d6175d40b"], "metadata": {"page_label": "241", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "adb98f3b-d644-4796-86d1-fdcd0a21d197": {"node_ids": ["80660fb5-3b2a-4a58-b318-213b8803fae8"], "metadata": {"page_label": "242", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b36374c6-dd3c-47d9-b0c4-e1da34b314ac": {"node_ids": ["a1afa5c9-b630-41d4-a131-4ebfd857c431"], "metadata": {"page_label": "243", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c496cf3f-db7c-4676-96e3-985300013278": {"node_ids": ["b3cb46e9-82c7-4e43-92ee-b723a886cb76"], "metadata": {"page_label": "244", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3936185a-e789-4c20-9a73-0436893c3cf5": {"node_ids": ["01a131bf-931b-41c0-b9a8-d0b787b60b1b"], "metadata": {"page_label": "245", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d489f49e-eb06-4d55-bedc-9fcde8ebfa8b": {"node_ids": ["0e7b9a01-5615-4c29-944c-6006634acbe7"], "metadata": {"page_label": "246", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "1167e740-3499-4055-80d8-2b1e36c0db47": {"node_ids": ["89b7b66a-1610-4e8b-ab23-afb22c3a0b82"], "metadata": {"page_label": "247", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5d2fa64f-63ad-4567-937f-80cd736792cb": {"node_ids": ["8390c7ad-db5d-42ab-85fd-fb64a86090a9"], "metadata": {"page_label": "248", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "61ca1e37-ff76-487d-89b5-0e104b4f162f": {"node_ids": ["f006e955-5ac8-4f98-b1ca-e7e4c1ea1c2d"], "metadata": {"page_label": "249", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "45f1e8bc-cd76-454a-9209-6481d61aaf2f": {"node_ids": ["b152d274-605e-4e2d-84eb-5ab56cf61540"], "metadata": {"page_label": "250", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9124a20b-faf2-4a4e-b484-4be817e719e3": {"node_ids": ["fe1108ab-fe1a-438f-8cd5-07474c5960c7"], "metadata": {"page_label": "251", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f36f125b-1496-4cd6-9a71-ce3fae0223fd": {"node_ids": ["d07c65fc-95a1-40f4-a865-36f8045c68f8"], "metadata": {"page_label": "252", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b52adccf-20ac-4702-83b4-4427290b3b6e": {"node_ids": ["5978a372-0d7b-4eae-bc52-80ab6a639828"], "metadata": {"page_label": "253", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "16543eeb-ac14-4029-8648-f26aa526e10f": {"node_ids": ["16952eee-7490-43c4-9896-815f12f07593"], "metadata": {"page_label": "254", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5d5400c7-c8b7-4bcd-b06b-43121fa9a67c": {"node_ids": ["64c51607-5fe3-458d-8c87-d0d7251ba8c7"], "metadata": {"page_label": "255", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4fc8c988-dfcf-4bdc-81aa-ace38e2be9be": {"node_ids": ["2713b3fb-a4d5-4f7e-8b71-e5080c6721ac"], "metadata": {"page_label": "256", "file_name": "networking.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/networking.pdf", "file_type": "application/pdf", "file_size": 288947, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e8976e21-25dc-4b16-ad08-a19d677726d6": {"node_ids": ["d054fb83-36a1-4310-a9df-35148fb693a8"], "metadata": {"page_label": "362", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3491a0f8-7885-424a-9421-b76b94c74c39": {"node_ids": ["c768791e-4045-4f8d-bfc5-8ecf2a2b6b81"], "metadata": {"page_label": "363", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "1e4f4924-aa33-45d5-a297-f62a3ad8f904": {"node_ids": ["8020715c-97ec-4ac5-99b0-05d78c71bb15"], "metadata": {"page_label": "364", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "74ba0371-961a-455d-80f1-aa3516b441ce": {"node_ids": ["335cbb26-9966-4ac6-a138-c9b9a3884534"], "metadata": {"page_label": "365", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a951f138-1070-4ed3-9f72-4d54ac44b4f8": {"node_ids": ["452f3e00-5a78-497b-a165-01720ec02ee2"], "metadata": {"page_label": "366", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "74b15e6b-e45a-42e9-9501-c1c9de739b29": {"node_ids": ["914e0e80-d7c8-4955-847a-f85596cd5183"], "metadata": {"page_label": "367", "file_name": "post_mortems.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/post_mortems.pdf", "file_type": "application/pdf", "file_size": 135404, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c103fa70-4986-4919-87ad-5c0afc65a55c": {"node_ids": ["bf494829-b7b3-481a-b998-7565694b2d80"], "metadata": {"page_label": "74", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "1bd0666f-a984-45fb-8d43-bbe717549c59": {"node_ids": ["230370d4-410d-47ab-9da7-25d4e7706ad4"], "metadata": {"page_label": "75", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f9057212-8280-49f5-8633-560064ca7e85": {"node_ids": ["4e55b646-ac3c-464b-af17-d8c464b756db"], "metadata": {"page_label": "76", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "73d30326-d346-444b-8427-60423669af22": {"node_ids": ["c3523cc5-97f1-42c5-9908-9aa9278ccd00"], "metadata": {"page_label": "77", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ddc5011c-48e6-4995-9116-b1dabcf29a6e": {"node_ids": ["e8d5ef94-5438-431f-b189-1b030835e3a0"], "metadata": {"page_label": "78", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0048b2ab-bbec-41a3-825a-237df653dc3f": {"node_ids": ["b4196a97-3292-46dd-b1aa-44f17496bb6e"], "metadata": {"page_label": "79", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b263ad4e-acba-44ee-858c-66516c49a1a7": {"node_ids": ["c22de179-a7d6-4071-9e68-a5227d532349"], "metadata": {"page_label": "80", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f1e400dd-661c-4f6d-b041-d5af93ab6a14": {"node_ids": ["7c2f83e6-174c-4275-9517-3c469d213c78"], "metadata": {"page_label": "81", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d1caed6c-ee34-4245-b916-a15da6b54bc2": {"node_ids": ["d7075920-6a29-4e5b-b4ce-72493e3f5a6b"], "metadata": {"page_label": "82", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b1bf2f8d-6b8d-475c-a0d8-42bf64e1c085": {"node_ids": ["4b78f1e4-4133-4c3c-9639-ecf807fa4e33"], "metadata": {"page_label": "83", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "fdd13f4c-1205-4d85-908f-2501d10b8439": {"node_ids": ["667d02ee-b67e-44f0-9aaa-1fe6590506db"], "metadata": {"page_label": "84", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0042a8be-64ad-41a8-842c-38e95d1a43e4": {"node_ids": ["6eacf695-85ee-48b3-a4f7-ca1e140bfb4d"], "metadata": {"page_label": "85", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d312320e-84f0-4848-b89e-678f0e249b16": {"node_ids": ["400d7f02-5c03-41cd-b9c2-742beec562fa"], "metadata": {"page_label": "86", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f19b4a22-e22d-4574-80ce-78857f8dd971": {"node_ids": ["0c8e0ec4-2d06-4902-b6cc-13a814900857"], "metadata": {"page_label": "87", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c813164e-7534-45ca-b9d0-689c537fd914": {"node_ids": ["74d929e5-12c6-417f-9a9b-f651b68359b5"], "metadata": {"page_label": "88", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "cba44fcb-580b-4544-92c7-ec1282434a12": {"node_ids": ["179c3b6d-2363-483d-8c35-06bc67d6440d"], "metadata": {"page_label": "89", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4d594d2e-fc1a-43e3-9943-125e8794d69d": {"node_ids": ["016d1b68-259b-406f-9269-ccb615f2ca2e"], "metadata": {"page_label": "90", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "33ef6d4e-4ec5-458f-94f2-a65b4d005832": {"node_ids": ["7aaba711-3a58-49f2-ae87-a8296b1ab22f"], "metadata": {"page_label": "91", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f68544ad-0038-43c6-9a8b-53e0ee19c017": {"node_ids": ["da042b45-2a4b-4464-9b43-5cb49453ad65"], "metadata": {"page_label": "92", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f90a875c-76d8-42ec-9e84-91cdbabf3749": {"node_ids": ["fb9b6b0a-30bf-4b98-8047-0a9cf8413382"], "metadata": {"page_label": "93", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "05e5fddb-4fc1-4ce4-8203-d3c12b06876e": {"node_ids": ["6de0d041-cd0d-4482-ae08-1d1a4c4ee88b"], "metadata": {"page_label": "94", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "34114b5c-f30a-49eb-913b-4c029b66924b": {"node_ids": ["8d13f3f6-55c2-4a37-bbab-0e7d15fb91cb"], "metadata": {"page_label": "95", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "24d0e59e-7c0e-4d9c-8694-862da5bd9c9e": {"node_ids": ["611db140-d289-46bb-93b9-758b7c5263b5"], "metadata": {"page_label": "96", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "22b3f44f-4ad1-4d34-a82d-571c2b577b6e": {"node_ids": ["fb7a946c-0d8a-4d10-a835-8b91d0ad0228"], "metadata": {"page_label": "97", "file_name": "processes.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/processes.pdf", "file_type": "application/pdf", "file_size": 387983, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "1a76c8e1-ebca-4586-a5da-e59a20636cca": {"node_ids": ["3dc626c7-34d3-4384-bba6-1cec5b7e2f01"], "metadata": {"page_label": "306", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3672e5cf-e2c6-4a0a-b5f2-20e5bdc4187b": {"node_ids": ["0272bb7d-543e-4907-8cd9-7116ecefde79"], "metadata": {"page_label": "307", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "172c2c71-ee13-4afb-ba6a-0fd681edc954": {"node_ids": ["e4cda223-39a2-48cb-9461-39644f748f69"], "metadata": {"page_label": "308", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "53a407b0-b77c-42d7-b003-4e4980be6e11": {"node_ids": ["27430c41-6220-4835-9a4b-285e1d962ac6"], "metadata": {"page_label": "309", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8a597797-d489-45be-9578-b1f11480e9fd": {"node_ids": ["f882ea27-9ec0-4efb-adf0-7b9295f866b0"], "metadata": {"page_label": "310", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "00a8a64f-a260-4723-9ca2-905e109f75ce": {"node_ids": ["768e1e44-5820-468f-b202-57f26cedde5c"], "metadata": {"page_label": "311", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "47c0629d-452f-4451-87b6-06af971fa3e0": {"node_ids": ["e436db12-919e-4822-b6de-ccdc2f304527"], "metadata": {"page_label": "312", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d37b295f-ea6c-4bee-a644-19a1951d38c9": {"node_ids": ["3843a229-4552-4fe9-8f45-6ae1e7ef2dca"], "metadata": {"page_label": "313", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4f65aa5a-c28e-473a-8ebc-46652cce472a": {"node_ids": ["e4ee90e4-a1ad-42bb-b18d-725b148b77d7"], "metadata": {"page_label": "314", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7f23e810-8db4-4937-a758-99e6a5459297": {"node_ids": ["77f6c88d-5aeb-4e3b-af72-b3a4e0c36520"], "metadata": {"page_label": "315", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "49fbf5fc-83f9-461f-9835-416e44914a4c": {"node_ids": ["d90c905e-65bd-40d6-a389-b68605888b9a"], "metadata": {"page_label": "316", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "076682ff-baaa-4474-8b2d-d2a31e7d0f6e": {"node_ids": ["c2906f00-c702-49c5-b6aa-4ca6f302ad06"], "metadata": {"page_label": "317", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "802109ea-1595-4395-9f9f-8d08ec973ce6": {"node_ids": ["f589a889-a384-439a-abe4-5ba2370d3a7a"], "metadata": {"page_label": "318", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ec51867a-8144-4cbb-9a1e-cd08f30ea021": {"node_ids": ["de1f07df-a9d6-4021-9c3a-9ac6a28e8155"], "metadata": {"page_label": "319", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c3f5dd12-57a6-4a0c-a35f-a2c956b303fa": {"node_ids": ["47a9ecf0-6a3c-4240-bc0e-28384d17d41c"], "metadata": {"page_label": "320", "file_name": "review.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/review.pdf", "file_type": "application/pdf", "file_size": 181480, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a8f88bf6-abb2-4231-8cbd-de26991d3960": {"node_ids": ["11128841-fc44-4c17-af9d-39e5ee259e26"], "metadata": {"page_label": "216", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "cff4897c-4ac5-4f1b-839c-860ae2dc8940": {"node_ids": ["509c8708-14ec-456e-98c7-4e68d50a74ea"], "metadata": {"page_label": "217", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "2191a06e-6b93-4504-a434-41d54402c08a": {"node_ids": ["ea400ccf-8c9e-4329-abb4-135793cfc07c"], "metadata": {"page_label": "218", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d7b9d93c-ac45-4c8e-bd66-696ebfec0b95": {"node_ids": ["d8e53a0d-2be6-4956-baee-f5c74efed7ac"], "metadata": {"page_label": "219", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0f3b430f-d94e-4094-8987-a82abc37cbef": {"node_ids": ["c14c84d0-7db0-4319-98d0-c207622d0da9"], "metadata": {"page_label": "220", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c7900d1f-274a-424d-a9e7-9fa10579c4e5": {"node_ids": ["542ad568-fb21-4d3f-9bef-0d4d1b9aa60e"], "metadata": {"page_label": "221", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b6564d06-a3d1-4a35-a6bf-bb075580aca3": {"node_ids": ["34192754-6eec-4218-988b-e15051ab5a8b"], "metadata": {"page_label": "222", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "883da25f-2f2f-4aeb-a855-b3aff3ce6e1a": {"node_ids": ["8ae2a5aa-8105-4498-9a26-f119ff9b1aae"], "metadata": {"page_label": "223", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ed99338a-8f5a-4e52-a126-b188170f8ac3": {"node_ids": ["c8a5c780-3a48-4184-a041-4bc15deaa02c"], "metadata": {"page_label": "224", "file_name": "scheduling.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/scheduling.pdf", "file_type": "application/pdf", "file_size": 169500, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d0c9644f-9363-4b47-b654-bab46ffe7129": {"node_ids": ["b16f8589-3d0f-4b12-a9a1-e819eef355e8"], "metadata": {"page_label": "297", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "482a15e4-81de-4ad3-b20d-dc2c329b3546": {"node_ids": ["eed845cf-d032-49ee-a4de-f14c5681ce4c"], "metadata": {"page_label": "298", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "968764ab-bf07-4e25-869e-b2b523b82596": {"node_ids": ["86bdb7b6-e5e0-4e09-bc8a-1f2c145ed0db"], "metadata": {"page_label": "299", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e8752142-6031-487d-9763-25029c1306c4": {"node_ids": ["06087d79-6635-4ff4-8b00-95bb65ce74ab"], "metadata": {"page_label": "300", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "33789f51-26a7-4f00-a805-80a0e048d022": {"node_ids": ["b8986a40-b4ec-4895-8823-9cbfbc17b51f"], "metadata": {"page_label": "301", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "844d4de6-5546-48a4-8e19-52ff5f53db1f": {"node_ids": ["d9c62ba4-b423-49ca-bda9-e273e4ec3fce"], "metadata": {"page_label": "302", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f7181f86-4f43-4e3c-bd98-fac5bd944c09": {"node_ids": ["5e19f9dd-f373-42e3-85ce-1db4a235fac6"], "metadata": {"page_label": "303", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "cfc6e13c-a2bd-4544-9f3e-962289387ad9": {"node_ids": ["2026d110-fc39-43d3-a7c6-31a526f56ed1"], "metadata": {"page_label": "304", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ad738fc2-314f-4daf-8323-49459a457289": {"node_ids": ["8aa9936d-b92c-4621-ba4d-a03ceb189c54"], "metadata": {"page_label": "305", "file_name": "security.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/security.pdf", "file_type": "application/pdf", "file_size": 176083, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "155b8336-3c6a-4660-9090-eca9d4950100": {"node_ids": ["bbda6786-2b92-43aa-b7fd-0be8905a1359"], "metadata": {"page_label": "285", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a1a3ba85-82a9-438d-b0f0-575d72eb6a60": {"node_ids": ["d844cb05-3997-4129-9101-1c5f5deb561c"], "metadata": {"page_label": "286", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "cfd75abe-704e-449a-a0e8-6b029a54bb2a": {"node_ids": ["18aed881-87d5-4444-9de9-c759a8fabaec"], "metadata": {"page_label": "287", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "46c8b4e6-3700-44b5-a09f-c2a27d74c433": {"node_ids": ["f0b38288-8c9d-49c1-9cce-c44bd2d53ab7"], "metadata": {"page_label": "288", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e769ceca-6dde-4184-a601-83a332f11aa5": {"node_ids": ["cfd4409f-967c-4c6b-8c44-f87b5bdb6b3e"], "metadata": {"page_label": "289", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c5cf832c-8969-4bd0-b5a7-e8298744b247": {"node_ids": ["0c92e77e-10d3-4f09-a2c6-c64ac9980110"], "metadata": {"page_label": "290", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3261e187-a18b-4de0-abc0-e4106d8b878c": {"node_ids": ["7f812be7-2960-4b6f-a4b6-1288ff41cc31"], "metadata": {"page_label": "291", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "889978af-4efc-4ae5-ac49-3aca7427c233": {"node_ids": ["65a9e312-cd94-4593-942a-713abbca55c8"], "metadata": {"page_label": "292", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f5b9a272-52f0-46e9-82a7-fc9a7bac64f6": {"node_ids": ["b86abe7e-e9a9-4dd2-a3d0-4cac5540a238"], "metadata": {"page_label": "293", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "1c039564-05c2-4d21-8f8e-404c80798eaa": {"node_ids": ["2ba23a71-ba84-44df-80ef-f77226063a15"], "metadata": {"page_label": "294", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0c051f7f-aca1-4685-b374-3b3d200d86f2": {"node_ids": ["81abed72-4db6-4b2d-8fd8-341e62380811"], "metadata": {"page_label": "295", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9024f802-544f-4a3b-90ec-742cc7fc7c02": {"node_ids": ["fc1db42e-a113-47ae-9e8c-fadd92ba4f33"], "metadata": {"page_label": "296", "file_name": "signals.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/signals.pdf", "file_type": "application/pdf", "file_size": 202056, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c010ea09-376e-4217-9b2c-d5e95baf2ff7": {"node_ids": ["b3bc4f64-d1a1-4168-8d72-83dc563f660d"], "metadata": {"page_label": "129", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "905799e5-769f-4ae3-bac5-391c9b564d86": {"node_ids": ["281a2b78-848f-42f1-8c22-2b0d081ab8ce"], "metadata": {"page_label": "130", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c3a8dc9e-e5fc-4420-960e-35e084b0f6de": {"node_ids": ["eb4971e7-97de-4ee2-99c0-825733e27096"], "metadata": {"page_label": "131", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "614bbbac-9060-4071-8078-a73c0aaaf020": {"node_ids": ["cf089f90-c956-498a-ba8a-cfc65b208317"], "metadata": {"page_label": "132", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4f82ee2f-9dec-4bbd-85ca-6c164ae4e794": {"node_ids": ["e7bba28a-ab03-4471-ac39-ffb4a110f2c4"], "metadata": {"page_label": "133", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "47c52128-3a12-40af-8840-870dbad382ba": {"node_ids": ["9a9bc81a-59df-43de-af38-fe6c97beedd6"], "metadata": {"page_label": "134", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "fc0f6a60-0c1a-426f-9825-756c24a702d6": {"node_ids": ["e2ca87d9-08a6-4511-ab9f-7f6bbbf6b094"], "metadata": {"page_label": "135", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "34e9dd64-72e7-40ba-8c05-70c869a1ce6c": {"node_ids": ["1b709b0a-b58e-4c4b-89b6-d26cb3ca61b8"], "metadata": {"page_label": "136", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "bed28dad-2521-4457-84de-5025f3aa9eec": {"node_ids": ["f47cac14-aea5-4cdb-8909-c47728ee03a4"], "metadata": {"page_label": "137", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "746e8702-e1d2-462f-b68b-a2a580c798e2": {"node_ids": ["7506bae8-0f48-4cf6-9561-583f5a05b14d"], "metadata": {"page_label": "138", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "c6c17ada-9385-4879-943c-0dc4cfab4a51": {"node_ids": ["f749619e-6e28-4835-bee7-1cbb802c44d0"], "metadata": {"page_label": "139", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "838f266c-8f34-48d1-9a8a-9b66a0cf9807": {"node_ids": ["ec04d862-2b1c-43cc-b3d4-3ae07749c72d"], "metadata": {"page_label": "140", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6a869f76-60de-41ad-88ed-b1c56945f82e": {"node_ids": ["a6974ac0-2dc0-405b-a97a-75d472007a6c"], "metadata": {"page_label": "141", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "26c61b21-edd2-45bc-9302-7081e47f61e4": {"node_ids": ["a7dd9efe-df6a-4145-aec3-9537ce37b2f9"], "metadata": {"page_label": "142", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "8a53a2ad-3546-4d7f-9e2b-f254537ebc76": {"node_ids": ["5769d982-3672-4ad5-b18b-61e32c18521c"], "metadata": {"page_label": "143", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4611c81c-c88f-440d-90c7-669b6d7d25df": {"node_ids": ["e8eda7f7-09e2-468b-ad0a-a2065f1d5a72"], "metadata": {"page_label": "144", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "70df3869-c245-40bb-a93b-1c25436bae83": {"node_ids": ["08964ac0-b99d-4d3a-adc6-91e69049df93"], "metadata": {"page_label": "145", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "ff4d22b3-bf1c-4586-8d64-256ff1110ea5": {"node_ids": ["ed8dddbb-7892-43b0-a92f-ec3b00e55259"], "metadata": {"page_label": "146", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "f6d69a42-c29f-479a-817e-23f51227b364": {"node_ids": ["2865d37f-2bc8-478d-be59-0a91b6064bdb"], "metadata": {"page_label": "147", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "30e7205f-3ac3-4711-b58f-811ffe6f0be0": {"node_ids": ["e3848f5b-f0bf-4697-8554-1426b28d8dc3"], "metadata": {"page_label": "148", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0dd0c550-a44a-4b85-9edf-4593ea71542e": {"node_ids": ["5553d4a7-8070-4348-8d2d-56d348eafa97"], "metadata": {"page_label": "149", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "70658702-f82c-42d4-ad07-e53301c7e050": {"node_ids": ["b20367da-475b-4d5a-ba5b-0f0e9aa19585"], "metadata": {"page_label": "150", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5069b1f4-1d39-41c0-8e17-767d13722f84": {"node_ids": ["e329b516-3702-40e7-a848-845b2746b58a"], "metadata": {"page_label": "151", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6858ba3d-159f-44ef-b661-651263c7e3b5": {"node_ids": ["b87d5ee2-641a-4316-b981-c22682295bd3"], "metadata": {"page_label": "152", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7a739bd0-22f9-4e85-a4f9-0646e4800563": {"node_ids": ["6ab665b3-0d0b-41c4-9a8a-7bc2452bfa45"], "metadata": {"page_label": "153", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e68fa4c5-c89a-414e-bb92-2820e59103a9": {"node_ids": ["0fd0fb93-8547-40e8-abe2-fe7444b3bfc8"], "metadata": {"page_label": "154", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "dbeabe24-38d9-4ff1-8221-db3589a23fb3": {"node_ids": ["6c8c11a5-9335-4296-854e-d38f77889450"], "metadata": {"page_label": "155", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b255843f-1d69-4fbe-a89f-d4fb76cfc6c3": {"node_ids": ["9a59bcf2-1690-42c4-a3ee-dcdc6a07eb1e"], "metadata": {"page_label": "156", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5342c86e-c4f6-4594-9a01-ecb17f9b248b": {"node_ids": ["ef4d6e32-ee49-40da-8ea6-de0126ebc7cc"], "metadata": {"page_label": "157", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "50788a88-2280-4b4e-b0d3-30e0cabc936c": {"node_ids": ["04270f5b-207f-46eb-93c7-f761b3db6743"], "metadata": {"page_label": "158", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "93db66c9-b14f-40ed-bcb4-cf5710d62d8f": {"node_ids": ["435b4035-f184-4fe5-8a29-79c637b3c590"], "metadata": {"page_label": "159", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "4b52f1c5-74b9-4641-8048-2a73c819321d": {"node_ids": ["b37fec70-4122-4ccb-b0d4-83715c08b2e3"], "metadata": {"page_label": "160", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e931c90e-c109-435e-80f4-63f676108ddd": {"node_ids": ["9871f313-e4c1-4c77-8b12-6e1c5f7943b5"], "metadata": {"page_label": "161", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "141dfc70-0054-487b-ba69-abaa0c4c07bf": {"node_ids": ["abf92290-8f8b-459d-8900-f4ae73097e04"], "metadata": {"page_label": "162", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "6a1bd7c6-3f1c-40ef-8f7a-8ecb8a6d117e": {"node_ids": ["17b69e14-978a-439f-964b-173695a81a68"], "metadata": {"page_label": "163", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "d7b2d760-9668-494a-8e8f-af6f7c53f00b": {"node_ids": ["54bb80c8-d30b-408b-b3ed-efd1b50e5502"], "metadata": {"page_label": "164", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "bb094c39-8be6-40ed-9575-dfb2ca8e9cfb": {"node_ids": ["60de55e1-e51e-4b81-8ea7-946d54350255"], "metadata": {"page_label": "165", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "09bfd729-7e4c-4dc6-8c49-4e6bd9f34a97": {"node_ids": ["bea2fead-015b-49a8-9613-f57bc9165a89"], "metadata": {"page_label": "166", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "796abaf7-a83b-4a50-8494-12b9a0b3f009": {"node_ids": ["d9134d78-b28b-49a1-8779-cad4bc172302"], "metadata": {"page_label": "167", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0a76efa1-c7ee-4930-99e2-6295784ad09e": {"node_ids": ["35fb3914-4223-437c-a1c1-89bf3d3aa68e"], "metadata": {"page_label": "168", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "5854b555-e73c-4661-ac22-519badc131ce": {"node_ids": ["bbfe787b-8334-4aef-8b19-4d57d7ef6e3a"], "metadata": {"page_label": "169", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e9276e96-4fea-4383-a464-5876d3bcfa28": {"node_ids": ["bc3cbcdc-b8cb-4433-ba0d-1cfeabfb28da"], "metadata": {"page_label": "170", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3890bc5e-c149-4fab-8844-d6444f43e232": {"node_ids": ["8dde49a8-13cc-4270-a51c-4c08049909b7"], "metadata": {"page_label": "171", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0f4062a4-9e47-4ce5-82a8-7b871e60bea0": {"node_ids": ["f8e15691-4060-401a-953b-67af8d6a64e4"], "metadata": {"page_label": "172", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "2dff44f0-219e-48ff-9041-a33b8a37d2ee": {"node_ids": ["bba7c29d-2ea1-411f-be51-3d4b357d4d29"], "metadata": {"page_label": "173", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "2b9f704a-3e4b-4d63-84e2-84310f2675b8": {"node_ids": ["cd97072e-0bb0-4f90-a57b-c86930656291"], "metadata": {"page_label": "174", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "20cbb7c1-cc96-4ad3-8ff3-e25288a11f87": {"node_ids": ["4672f06b-ba93-4364-84f8-9d706787bdde"], "metadata": {"page_label": "175", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a610f46e-cbbf-4f5a-9b4e-9ee79ae31d36": {"node_ids": ["1d969a9f-492b-4650-a18f-eec48cfd03d2"], "metadata": {"page_label": "176", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0307de24-6a4c-41cf-8b56-e1aea18f578c": {"node_ids": ["b468cc24-15df-4797-840e-bbb3ee659919"], "metadata": {"page_label": "177", "file_name": "synchronization.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/synchronization.pdf", "file_type": "application/pdf", "file_size": 387408, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "cc6d33e0-1200-4bef-9303-05d032d40d90": {"node_ids": ["a6ee7a9a-e4b5-4943-a916-c97bb8e152b2"], "metadata": {"page_label": "115", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "7395be4c-cb51-4d67-867a-6154e39a6151": {"node_ids": ["5db8e253-aa58-4f03-a325-d88580aac457"], "metadata": {"page_label": "116", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "994b4c38-83a4-4c99-8386-b634332dbcfa": {"node_ids": ["7707a09e-f561-4f4e-a488-e896c0bd021c"], "metadata": {"page_label": "117", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "0823693c-ea54-4e40-98f4-ee062c4d3b7c": {"node_ids": ["618365eb-7831-4fee-b96d-d49720a0f8a8"], "metadata": {"page_label": "118", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "a11be51c-c7c1-4050-8bd8-ee8f478a7109": {"node_ids": ["da6bdc19-c30c-4e76-a483-316b61143905"], "metadata": {"page_label": "119", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "41e8389e-9056-4db3-aabc-7101af07b372": {"node_ids": ["3e46a656-60fd-4686-82fa-3ff9b95706b8"], "metadata": {"page_label": "120", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "488a1e20-70b7-442a-ba09-c1b234618e5e": {"node_ids": ["738c18ff-7e08-46a8-9fc3-c257f2e370f3"], "metadata": {"page_label": "121", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "9efe6404-82a3-4af7-8203-65ebb280dfd8": {"node_ids": ["3c213e4a-a2ec-4b29-9f05-7ed77e2d7ed8"], "metadata": {"page_label": "122", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "15c74424-8f12-4162-9180-6fbd21284850": {"node_ids": ["a4392b60-3f95-4521-9ad3-8b52dc627c86"], "metadata": {"page_label": "123", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "35c4e781-aee3-4688-a2ea-2b75da09a5ce": {"node_ids": ["5afd04b2-3893-4d3d-bcde-a06dbdc4e3ff"], "metadata": {"page_label": "124", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "3323c86c-d8ea-4a1b-b619-905945b89771": {"node_ids": ["66d34a3a-f51e-4dcf-b049-b88de6d02bff"], "metadata": {"page_label": "125", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "b7dcb9b2-58b4-438c-8f68-dc78c7846e5e": {"node_ids": ["8af7c035-1d3e-475c-bfe2-90c04e25145e"], "metadata": {"page_label": "126", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "529b6c59-00b2-49b2-8f78-9c6f8a599516": {"node_ids": ["0f8f1865-989b-433e-8cc5-6b261fd7f023"], "metadata": {"page_label": "127", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}, "e6b9c5a7-76aa-4b07-bb00-182bb17f2260": {"node_ids": ["6fd13afb-fd96-4db4-8d61-9ead203607c2"], "metadata": {"page_label": "128", "file_name": "threads.pdf", "file_path": "/Users/benwalsh/Desktop/Machine Learning/data/threads.pdf", "file_type": "application/pdf", "file_size": 226485, "creation_date": "2024-08-31", "last_modified_date": "2024-08-31"}}}}